<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SSD修复</title>
    <url>/2022/12/17/Fix%20&amp;%20Crack/SSD%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h2 id="慧荣SM2246EN主控山寨固态修复"><a href="#慧荣SM2246EN主控山寨固态修复" class="headerlink" title="慧荣SM2246EN主控山寨固态修复"></a>慧荣SM2246EN主控山寨固态修复</h2><p><em>在某鱼收了一个120G的所谓金士顿v300固态硬盘，也是受到了一些颗粒玩家的影响想要收来做个U盘，便有了下文…</em></p>
<hr>
<h4 id="初印象"><a href="#初印象" class="headerlink" title="初印象"></a>初印象</h4><p>当时到手后拆开发现内部主控为慧荣SM2246EN，这可不好。。。</p>
<span id="more"></span>

<p>实际上在网上查询得知这款金士顿应该为SF2281的主控。<br>固态上的颗粒印字为Toshiba的TH58TEG7DDLTA00。如下图。</p>
<img src="/2022/12/17/Fix%20&%20Crack/SSD%E4%BF%AE%E5%A4%8D/%E5%A4%96%E8%A7%82.png" class title="整体外观">

<p>基本上认定这是一个山寨产品。</p>
<p>首先还是试一试读写，买了斐讯的Sata转USB3.0转接板，上机发现问题是偶尔能读取，但是无法删除原有文件，也无法新建（重新拔插后全部恢复原样），顺序写入大概70M&#x2F;s，很快掉盘。</p>
<h4 id="尝试修复"><a href="#尝试修复" class="headerlink" title="尝试修复"></a>尝试修复</h4><p>直接考虑进行量产操作。</p>
<p>图片上可以看到左边丝印有标注ROM，用镊子短接然后插USB就可以进入ROM模式，被慧荣SM2246EN的量产工具识别就可以开卡。</p>
<p>但是在慧荣的各个版本量产工具中都找不到这个颗粒型号。<br>关于颗粒类型与命名规则，这里可以参考一些别的文献。<br>这个颗粒按照丝印，应该是15nm制程的MLC，但是在SSD-z中读取为Toshiba 19nm MLC，主控读取为SF2281，但主控固件读取为P0614，这个型号可以看出来很明显是慧荣的一款固件版本。所以说具体颗粒究竟是什么从颗粒丝印不一定是正确的，也可能是重新打字。之前一直尝试使用东芝其他型号颗粒开卡不能开出。</p>
<p>然后用慧荣开卡工具进行Dram Test（下图）</p>
<img src="/2022/12/17/Fix%20&%20Crack/SSD%E4%BF%AE%E5%A4%8D/%E9%87%8F%E4%BA%A7%E5%B7%A5%E5%85%B7.png" class title="测试">
<p>发现Dram Test过不了，最开始的思路是找能不用缓存的固件开卡，但是实在找不到这样的。顺便提一嘴，这个慧荣的量产工具界面要拖动边框有些内容才会显示出来。<br>这时候去翻了翻论坛，了解到：</p>
<blockquote>
<ul>
<li>首先内存型号要选对</li>
<li>过不了可能是虚焊</li>
<li>maybe选别的颗粒就好了</li>
</ul>
</blockquote>
<p>这些不同的观点对我修复这个硬盘的过程造成一些困扰。</p>
<p>图中是南亚的颗粒，Nanya的内存丝印可以看到64M16，<br>意思是64M Bytes16位，这里这个大小按照8Bit算，就是128M，有些颗粒如三星（SEC，Samsung）海力士（SKhynix）会标1G16那种就是1G bits，就是128M Bytes。<br>SM2246主控只支持16位内存。进入参数设置页面设置正确（下图）</p>
<img src="/2022/12/17/Fix%20&%20Crack/SSD%E4%BF%AE%E5%A4%8D/%E9%87%8F%E4%BA%A7%E5%B7%A5%E5%85%B72.png" class title="量产">

<p>但是依然不能开卡。</p>
<hr>
<h4 id="切换思路"><a href="#切换思路" class="headerlink" title="切换思路"></a>切换思路</h4><p>这时候我已经想放弃了，但是考虑到还是有可能是内存颗粒虚焊，当时手头没有热风枪，先用力按住内存和PCB,发现DRAM Test 可以通过，果然是虚焊。用热风枪重新加焊之后，SSD可以直接使用了，不需要量产。<br>但是在跑随机读写的时候还是容易掉盘，而且顺序读写速度很低。本来不想接着折腾了，就装到壳子里面了。然后发现更容易掉盘了，需要重新加焊，这里为什么后面解释。<br>继续可以使用了之后，尝试在固态里面装一个<a href="https://markdown.com.cn/">Deepin</a>，但是每次都会最后掉盘，第三次的时候直接拔掉电源，发现再不能识别硬盘，当时心里一凉，完了。</p>
<h4 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h4><p>这时候已经不可避免要进行量产了，最开始提示Flash没有sync，后来再参数设置里面关掉了sync mode，至于选择颗粒选择了自动匹配ID的Sandisk的128Gb颗粒进行开卡，发现这样子可以通过开卡。<br>速度也有所提升。然是发现装进外壳之后又不能识别，这时候用手轻轻扳动缓存颗粒旁边的PCB边缘，发现不能通过DRAM test,就明白了外壳上螺丝的时候会压到这个pcb使其虚焊。重新加焊之后不再上这个螺丝。<br>另外，这只是这个固态的一部分毛病，之前再固态信息里面看到这个固态的数据量是<strong>120T</strong>…也就说，颗粒很可能已经接近报废，所以这就导致后面的的问题，写入到一部分的时候会掉盘。也就说坏块过多也不能映射备用块。这里说一下，固态和机械有很大的不同，所以diskgenius的扫描坏块是不合适的，比如需要读写，对于固态寿命是有影响的，读出来的结果也并不是真的物理块，但是我这里死马当做活马医，本身只想看个参考，所以跑了测试发现确实有读写错误的部分。</p>
<p>为了解决这个问题，可以通过跑RDT来解决这个问题，量产的时候勾选RDT,这个PCBA在跑的时候会闪灯，所以可以看到跑完结束。跑完RDT之后量产需要直接插上电脑，<strong>不要短接ROM，不要短接不要短接</strong>，那样就失去了RDT信息(如下）<img src="/2022/12/17/Fix%20&%20Crack/SSD%E4%BF%AE%E5%A4%8D/RDT.png" class title="RDT"></p>
<p>而是直接插上硬盘就应该能在量产工具里面检测到。  最开始我的斐讯的JMS576我发现不行，还准备去买别的转接卡，后来发现只要插在USB2.0端口上就可以识别了，然后换了0819A的固件，发现速度也有提升，测试两天后发现没有掉盘，结束。</p>
<hr>
<p>补充：NAND的ID可以复制读出来的第一行数据在这个上面找试试<a href="http://www.flashinfo.top/">www.flashinfo.top</a></p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>折腾有风险，修理费时间，目前稳定使用一年多，不过权当一段经历吧。</p>
]]></content>
      <categories>
        <category>Fix &amp; Crack</category>
      </categories>
      <tags>
        <tag>修理</tag>
        <tag>SSD</tag>
        <tag>Flash</tag>
      </tags>
  </entry>
  <entry>
    <title>佳能EOS350D破解</title>
    <url>/2021/02/23/Fix%20&amp;%20Crack/%E4%BD%B3%E8%83%BDEOS350D%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>1.电池充满电</p>
<p>2.CF卡</p>
<p>3.CF卡读卡器（必备，数据线不行）</p>
<p>4.相机更新到固件1.0.3 <a href="http://web.canon.jp/imaging/eosdigital2/e3kr2_firmware-e.html(%E6%AD%A5%E9%AA%A4%E7%95%A5)">http://web.canon.jp/imaging/eosdigital2/e3kr2_firmware-e.html(步骤略)</a></p>
<p>5.软件包，包含AUTOEXEC.BIN scanled.fir cardtricks.exe（下图）</p>
<p>6.HxD软件或者其他二进制磁盘编辑工具如WinHex（可选）</p>
<img src="/2021/02/23/Fix%20&%20Crack/%E4%BD%B3%E8%83%BDEOS350D%E7%A0%B4%E8%A7%A3/image-20210223155419837.png" class title="image-20210223155419837">

<span id="more"></span>

<h1 id="开始固件更换"><a href="#开始固件更换" class="headerlink" title="开始固件更换"></a>开始固件更换</h1><p>1.格式化CF卡，在电脑上快速格式化即可。</p>
<p>2.复制软件包内的scanled.fir到CF卡根目录，插入相机后在相机内选择更新固件。</p>
<p>（Menu-最后一栏-固件版本-确定），会显示下图。</p>
<img src="/2021/02/23/Fix%20&%20Crack/%E4%BD%B3%E8%83%BDEOS350D%E7%A0%B4%E8%A7%A3/image-20210223155506019.png" class title="image-20210223155506019">

<p>3.这时候应该是蓝色的灯常亮，这时候先拔掉电池，然后拔掉CF卡。</p>
<h1 id="开始制作可启动CF卡"><a href="#开始制作可启动CF卡" class="headerlink" title="开始制作可启动CF卡"></a>开始制作可启动CF卡</h1><p>破解的方法是从CF卡启动固件，需要修改卡内磁盘数据。</p>
<p>1.插入CF卡，打开软件包内的CardTricks</p>
<p>2.按照下图操作</p>
<img src="/2021/02/23/Fix%20&%20Crack/%E4%BD%B3%E8%83%BDEOS350D%E7%A0%B4%E8%A7%A3/image-20210223155601573.png" class title="image-20210223155601573">

<p>3.会提示结果，实际上这个工具就是自动对于FAT16文件系统在0x24处和0x40处写入对应字符。FAT32文件系统同理。所以用磁盘编辑工具也可以手动修改。</p>
<img src="/2021/02/23/Fix%20&%20Crack/%E4%BD%B3%E8%83%BDEOS350D%E7%A0%B4%E8%A7%A3/image-20210223155622050.png" class title="image-20210223155622050">

<h1 id="从CF卡启动"><a href="#从CF卡启动" class="headerlink" title="从CF卡启动"></a>从CF卡启动</h1><p>这一步是放入自动执行固件。</p>
<p>1.拷贝AUTOEXEC.BIN到CF卡根目录。</p>
<p>2.插卡，插电池，开机看到蓝灯闪一下。</p>
<h1 id="验证功能"><a href="#验证功能" class="headerlink" title="验证功能"></a>验证功能</h1><p>新功能都在Info键内。</p>
<p>按一下INFO键，然后按上下键可以翻动条目，按左右键可以修改每一条对应的可选项。（破解前不行）</p>
<img src="/2021/02/23/Fix%20&%20Crack/%E4%BD%B3%E8%83%BDEOS350D%E7%A0%B4%E8%A7%A3/image-20210223155928781.png" class title="image-20210223155928781">

<p>最后，这个卡不要格式化，不然就要重新破解一次了。</p>
]]></content>
      <categories>
        <category>Fix &amp; Crack</category>
      </categories>
      <tags>
        <tag>修理</tag>
      </tags>
  </entry>
  <entry>
    <title>ADS1263性能测试</title>
    <url>/2022/09/25/Work%20with%20the%20world/ADS1263%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>严格来说，应该是功能测试，因为我手上只有6.5位DMM, 我甚至买不起好的基准芯片（心痛价格），对于一个32bit ADC来说可能我测试的条件有点太丐了。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最初想测试这个完全是因为在TB上看见这个正儿八经的ADC片子只需要18块钱（拆机），而ADS1262只少一个24bit 辅助ADC , 价格是8元。 我直接心动。</p>
<p>买来之后，我首先找有没有现成的资料，在电脑上用everything搜索，发现有我写的工程。。。。我发现这玩意儿竟然是我大一的时候参加比赛调过的ADC ,当时做的是组合秤，现在想起来当时好像是说超过200yuan&#x2F;pcs……</p>
<pre><code>拆机片真是个好东西。
</code></pre>
<p>于是大致理了一下之前出现的问题。</p>
<p>当时硬件不是我做的，不过我倒是比较清楚问题，因为最后的输出转换结果实在是太拉了，记得好像是有效位数大概只有12bit，按照手册上最高25bit的无噪分辨率来看这实在是差到没边了。</p>
<p>另外，当时所使用的供电是AMS1117-5.0 ,虽然比直接用开关电源强一点，但是这个1117承担了从外部开关电源转换的重任。。。也就是说很可能对于纹波抑制基本上没啥效果。<br>另外当时还遇到了ADC转换发热较严重的情况，不知道是设计原因还是实际存在。</p>
<p>最后重新看了一下手册和代码，发现当时的代码寄存器配置能让这个ADC跑起来就是个奇迹。。。。当时使用的祖传代码，还有不知道谁说的这个adc只有俩通道，但是代码里面实际开了三个通道，真的难绷。</p>
<p>所以基本上需要解决的问题是：<br>1、基准源<br>2、供电<br>3、修（重写）代码</p>
<pre><code>顺便吐槽一下TI的ADC的寄存器配置，真的难顶，一大堆寄存器，例程也不给，用起来极为麻烦。
</code></pre>
<p>写这篇文之前我已经开始画板了，当时考虑的是能完整测试功能，包括不同供电的影响，时钟的影响和基准的影响。</p>
<p>其实在手册上我感觉内部基准的参数是很不错的，但是大家表示存在水分，所以仍然需要测试外部基准（实际上不用测试，直接氪金就行了），实际上我挂了一个LT1009, 很可能是远不能达标的。</p>
<p>供电设计则选择了可选的LP2985 LP2951 LT3042的组合选择，其中LT3042作为地表最强LDO,没有组合，直接输出5V供电给ADS1263 , 而其他的设计存在级联或者单独出电压的选择，使用跳线帽切换。外部供电则选择之前做的线性电源，虽然可能不咋好但是比开关电源强多了，后期测试则使用18650串联。</p>
<p>时钟则预留了外部有源晶振和无源晶振以及SMA输入口，在设计这个板子的时候还没有意识到内部RC振荡器有多么不稳定，以及没有了解到时钟对Σ-Δ ADC转化的影响（TODO:这里写上参考文章号），幸好多个心眼都给预留了。</p>
<p>当时预留的单片机是CH549, 预留了ADC的SPI接口排针，现在看来，幸好留了排针。。。CH549对于我来说还是太难用了，毕竟51没有仿真功能。所以使用手上有的GD32F350G8单片机。</p>
]]></content>
      <categories>
        <category>Work with the world</category>
      </categories>
      <tags>
        <tag>ADC</tag>
      </tags>
  </entry>
  <entry>
    <title>Multisim仿真画板一气呵成</title>
    <url>/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="首先需要了解的"><a href="#首先需要了解的" class="headerlink" title="首先需要了解的"></a>首先需要了解的</h2><ul>
<li><p>multisim和ultiboard是一套产品，在安装multisim的时候基本都会安装。其中multisim用于原理图和仿真，ultiboard用于PCB. </p>
</li>
<li><p>在multisim仿真中，往往会仿真一些模块，这些模块不是特别复杂但是需要做出来，如果选择脑补焊接或者用别的软件辅助设计又略麻烦，于是有了下文。</p>
</li>
</ul>
<span id="more"></span>

<h2 id="步骤1：仿真原理图与添加封装"><a href="#步骤1：仿真原理图与添加封装" class="headerlink" title="步骤1：仿真原理图与添加封装"></a>步骤1：仿真原理图与添加封装</h2><p>首先当然是绘制原理图。</p>
<p>在绘制原理图的时候，除了必要的元件之外，还可以添加连接件例如排针。在器件库中选择Connectors，选择All families后搜索HDR</p>
<p>,看到HDR1x10,这个就是10pin的2.54mm排针，这里可以找到HDR1x2进行添加。</p>
<p>如下图:</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210313213000992.png" alt="image-20210313213000992" style="zoom:67%;">

<p>然后可以看到上图中的R3为黑色，其余元件有别的颜色，如电阻电容的蓝色。</p>
<p>因为有颜色的是添加了封装。对于具体的器件，有的器件包含默认封装，但是这种基本器件需要自己选择。</p>
<p>双击元件：</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210313213413695.png" alt="image-20210313213413695" style="zoom:67%;">

<p>可以edit package ,进入之后可以挑选一个封装，排序是字母（没找到怎么快点找到，下版改进）。</p>
<p>由于主要用于快速参考或者洞洞板焊接，阻容封装通常可以随意一点。</p>
<p>只需要把自己需要焊接的器件添加封装，不添加封装的不会出现在板子中。</p>
<h2 id="步骤2：元件布局"><a href="#步骤2：元件布局" class="headerlink" title="步骤2：元件布局"></a>步骤2：元件布局</h2><p>添加封装之后，点击transfer，当然这里也可以导出网表用别的软件来画，这里本来就是为了省事，就直接点击transfer to Ultiboard 14.0.</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210313213816011.png" alt="image-20210313213816011" style="zoom:67%;">

<p>你会得到一个ewprj后缀的文件，这时候器件都在底下了，但是还没有连线，首先用鼠标移动器件进行摆放，Ctrl+R可以旋转。</p>
<p>或者使用自动摆放 ：顶部Autoplace parts.</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210319223305830.png" alt="image-20210319223305830" style="zoom:67%;">

<h2 id="3D-预览"><a href="#3D-预览" class="headerlink" title="3D 预览"></a>3D 预览</h2><p>下面这个选项可以查看3D,鼠标左键拖动</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210319223543410.png" class title="image-20210319223543410">

<p>3D 是个新窗口，直接右上角关掉就回到了二维</p>
<p>摆放完成之后，点击Place，点击Line（或者快捷键Ctrl+Shift+L），对元件引脚连接用于自己连线参考。</p>
<p>由于是作为洞洞板参考，最好单层。如下，比较随意：</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210313214659220.png" alt="image-20210313214659220" style="zoom:67%;">

<p>也可以使用自动布线然后手动修改：在一个自动布线的教程中，在开始还做了这个，不知道具体含义：</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210319223412654.png" alt="image-20210319223412654" style="zoom:67%;">

<p>去掉了这个钩（在options-pcb properties里面）。</p>
<p>然后可以进行autoRoute。</p>
<p>洞洞板是2.54mm间距的洞洞，即100mil，为了方便，可以在菜单Edit-Properties，点击第二个Grid &amp;units，修改栅格为100mil或者50mil。</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210313214839186.png" alt="image-20210313214839186" style="zoom:67%;">

<p>到这里就可以参考这个布局进行洞洞板的焊接，当然有兴趣也可以用这个出PCB。</p>
<p>左侧选择Board Outline 可以绘制边框。</p>
<p>这个还提供了一个功能就是全选pcb内的内容可以直接复制到word里面为图片：</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210420001109403.png" alt="image-20210420001109403" style="zoom:67%;">

<p>选到铜皮层，然后place graphics 选择类型可以添加覆铜。</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210420001054814.png" alt="image-20210420001054814" style="zoom:67%;">

<h2 id="步骤3：导出gerber（额外）"><a href="#步骤3：导出gerber（额外）" class="headerlink" title="步骤3：导出gerber（额外）"></a>步骤3：导出gerber（额外）</h2><p>导出gerber比较坑，按照默认选项导出有钻孔也有光绘，用gerber预览看见也应该是正确的，但是在嘉立创下单助手里面不能识别。。。。</p>
<p>这里用用kicad的gerbview导入ultiboard导出的gerber文件，导出到pcb_new,选择正确的层，有些没有就不选，然后可能需要到到kicad里面整理一下边框重新导出是可以使用的，没有琢磨出来能直接导出可以识别的Gerber的方法.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于直接使用原理图的网络，这里焊接只要不连接错网络，在洞洞板焊接中不容易出错，同时对于元件引脚分配好封装之后不需要再查找对应关系，比较方便快速。对于一些小板子，直接用multisim出图也快一点。</p>
<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><p><a href="https://wenku.baidu.com/view/6ee157d028ea81c758f5786e.html">PCB版图设计(Ultiboard) - 百度文库 (baidu.com)</a></p>
<p><a href="https://www.ece.ubc.ca/~robertor/Links_files/Files/Ultiboard-tut-Exporting-Gerber-Files.pdf">https://www.ece.ubc.ca/~robertor/Links_files/Files/Ultiboard-tut-Exporting-Gerber-Files.pdf</a></p>
<p><a href="https://knowledge.ni.com/KnowledgeArticleDetails?id=kA03q000000YG0FCAW&l=zh-CN">https://knowledge.ni.com/KnowledgeArticleDetails?id=kA03q000000YG0FCAW&amp;l=zh-CN</a></p>
<pre><code>更新：由于KiCad也能进行仿真，因此更推荐使用KiCad进行设计。
</code></pre>
]]></content>
      <categories>
        <category>Work with the world</category>
      </categories>
      <tags>
        <tag>Mulstisim</tag>
        <tag>PCB</tag>
        <tag>Spice</tag>
      </tags>
  </entry>
  <entry>
    <title>使用KiCad内置的ngSpice进行电路仿真（0）</title>
    <url>/2022/09/22/Work%20with%20the%20world/%E4%BD%BF%E7%94%A8KiCad%E5%86%85%E7%BD%AE%E7%9A%84NgSpice%E8%BF%9B%E8%A1%8C%E7%94%B5%E8%B7%AF%E4%BB%BF%E7%9C%9F%EF%BC%880%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实几乎所有的EDA工具（这里只是指板级设计工具），都提供了仿真的功能，功能的完善程度取决于这个公司来头多大，例如cadence中的原理图工具，它收购了pspice之后进行了改进并集成到其中，可以进行仿真，同时有巨量的仿真库。</p>
<p>而国内常用的仿真软件multisim和proteus，虽然在课堂上都是用来仿真，但是他们都有配套的PCB工具，还有Tina软件同样包含各种工具，从数字逻辑仿真到模拟仿真到PCB.</p>
<span id="more"></span>

<blockquote>
<p>免费的Tina-TI使用比较多，仿真模型比官方有些缺少，也没有其他更多的功能。<br>另外，ltspice是真就只能仿真。</p>
</blockquote>
<p>仿真的实现方法根据仿真目的和实际需求有很多方法，但是最早诞生于伯克利大学的spice程序则是应用非常广泛的一个（TODO:找资料来），spice对于电路使用网表描述，并根据网表和器件的模型进行方程的解算得到仿真结果，spice是开源的，因此市面上有很多产品都基于类似的设计。<br>下面要使用的ngspice就是基于spice3f5和其他spice仿真工具改进的开源spice仿真工具。</p>
<pre><code>刚刚提到了网表，但是在这个计算机普及的时代，网表概念被弱化了，实际上网表就是用字符串来描述器件如何连接，毕竟一个文本文件在计算机早期时代是更容易输入到电脑上进行计算的（输入图形甚至可能做不到），当然在如今，网表依然是一个不错的描述工具，对于spice程序来说不算过时，大部分spice软件依然可以兼容老旧的器件仿真模型，可以实现导入等操作。
</code></pre>
<p>为什么不用其他工具呢？</p>
<ol>
<li><p>开源 NO.1</p>
</li>
<li><p>不想学了，其实没啥特别多的选择，主要就是cadence</p>
<p> 实际上了解到KiCad的时候最开始我并不知道它可以仿真，直到听到一个国外上学的老哥说要求用这个来做我才知道这东西可以仿真，当时KiCad6还刚出，中文网都没有相关的教程。后来了解到实际上官方的教程还是比较多的（todo:贴官方教程和例子的链接）。包括ngspice的官网教程也是推荐使用KiCad.</p>
</li>
</ol>
<h2 id="Kicad中的仿真可以做什么"><a href="#Kicad中的仿真可以做什么" class="headerlink" title="Kicad中的仿真可以做什么"></a>Kicad中的仿真可以做什么</h2><p>在KiCad中，当前的版本（6.0x）,主要是模拟电路的仿真。</p>
<pre><code>kicad已经更新了，在KiCad得到Net的捐赠后（KiCad Project Awarded NLnet Grant），kicad 在接受捐赠之后承诺要提高仿真的易用性，实际上计划表推到8.0之后了，而个人觉得7.0的仿真bug似乎更多，因此这里还是用6.0版本
</code></pre>
<p>同时，当前的内置功能比较简单，只能进行瞬态仿真、交流仿真、直流转换的图形显示，其他的仿真结果则需要自己导出。</p>
<h2 id="ngspice简述"><a href="#ngspice简述" class="headerlink" title="ngspice简述"></a>ngspice简述</h2><!--more-->






]]></content>
      <categories>
        <category>Work with the world</category>
      </categories>
      <tags>
        <tag>Spice</tag>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客文章的管理</title>
    <url>/2023/02/01/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/0%E3%80%81%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>这篇是一篇随记，其实很简单：</p>
<p><strong>用OBSIDIAN来管理博客的文章就好了</strong>。</p>
<span id="more"></span>
<p>起因是用了obsidian之后就懒得写博客了，加上Typeroa收费，新的markdown编辑器不太好用，至少没有之前那么好用，因此就转移笔记到了obsidian。本来是打算ob编辑结束之后转移回来，但是发现同步这个太痛苦了，突然想到直接在博客源文件这里建立一个ob的库就好了，这样实际上还可以分开管理一些想要发布的东西。</p>
<p>另外，文件夹不影响文章的识别，因此可以在<code>_post</code>文件夹下面用文件夹分类，这个逻辑和obsidian是一样的。</p>
<p>缺点是，另外一个ob库同步到了手机，可以很方便随处编辑，这个库再同步过去感觉多少有点别扭，当然也不是不行，只是感觉手机上的文件很乱不想继续往里面塞东西。</p>
<h1 id="多个公开平台同步"><a href="#多个公开平台同步" class="headerlink" title="多个公开平台同步"></a>多个公开平台同步</h1><p>还没想好除了复制粘贴还有啥方法。<br>知乎可以直接上传mardown文档，但是图片要重新上传，而且那个图片上传对于批量很不友好。<br>CSDN真的不行。<br>b站更是啥都没有。。markdown都不能识别。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>静态博客的搭建</title>
    <url>/2023/03/13/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/1%E3%80%81%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="博客框架的选择"><a href="#博客框架的选择" class="headerlink" title="博客框架的选择"></a>博客框架的选择</h2><p>出于方便的目的，加上可以维护自己的MD文档，这里当然是选择一个框架来构建自己的博客。<br>框架有<strong>Hexo、WordPress、VuePress、Hugo、Solo、Halo 、Jekyll</strong>,<br>但是Gitee pages 支持的服务有Jekyll、Hugo、Hexo。（或者github的）<br>其中Hexo使用比较多，教程也比较多，据说基于Go的Hugo的构建速度比较快，不过目前教程不多，因此这里还是选择了基于node.js的hexo。</p>
<span id="more"></span>
<h2 id="Hexo框架的初始化"><a href="#Hexo框架的初始化" class="headerlink" title="Hexo框架的初始化"></a>Hexo框架的初始化</h2><h3 id="1、安装node-js"><a href="#1、安装node-js" class="headerlink" title="1、安装node.js"></a>1、安装node.js</h3><p>Windows 直接用安装包安装就行，选LTS版本,里面的npm工具要安装上。<br>linux下 就比较简单，直接install nodejs和install npm.</p>
<h3 id="2、安装hexo"><a href="#2、安装hexo" class="headerlink" title="2、安装hexo"></a>2、安装hexo</h3><p>在需要存放自己博客文件的文件夹下面打开命令行(not powershell,可以安装但是不能执行)，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>然后试试执行命令<code>hexo -v</code>看看安装成功没有。</p>
<p>然后初始化hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>也可以新建一个文件夹的方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br><span class="line"><span class="built_in">cd</span> myblog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>这时候这个文件夹下面有：</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
<li><strong>_config.yml: 博客的配置文件</strong></li>
</ul>
<p>测试一下功能正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>然后点开生成的本地服务 localhost:4000可以看到一个自带的页面。</p>
<h3 id="3-连接Github仓库"><a href="#3-连接Github仓库" class="headerlink" title="3 连接Github仓库"></a>3 连接Github仓库</h3><p>新建一个仓库名为   用户名.github.io  ，这样pages的根目录就是这个仓库名，否则是 用户名.github.io&#x2F;仓库名，也不是不能用但是一来不好看，而来后面还要加配置。<br>如果使用Gitee,这里需要新建一个名为用户名的仓库，达到和Github 一样的效果。</p>
<p>然后就是配置Git的那一套，用户名，SSH,这都是全局配置，配过了就不用再配置了。见[[GIT的初始使用方法]]。</p>
<p>在博客文件夹下有配置文件，里面包含了deploy这个项目<br>在文件内文本配置自己的仓库链接：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># repo: https://gitee.com/always_one/always_one.git</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:alwaysmy/alwaysmy.github.io.git</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 注意了，这里GitHub不要使用https链接了，现在不支持，gitee倒是没注意过，要用git链接。<br> 同时<br> 还有配置博客对应的根目录</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="string">url:</span> <span class="string">https://alwaysmy.github.io</span></span><br><span class="line"></span><br><span class="line"><span class="string">root:</span> <span class="string">/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 安装deploy-git，通过hexo命令来部署到Github.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后再hexo所在的文件夹下面执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean&amp;&amp; hexo g&amp;&amp;hexo d</span><br></pre></td></tr></table></figure>

<p>分别是清空，生成和部署。有时候直接生成部署就行，如果修改了Hexo主题相关的东西需要清空。</p>
<p>这时候你直接在生成的.deploy_git文件夹内使用git push当然也可以，但是那样搞复杂了。</p>
<h2 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h2><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>主题的配置需要在主题下对应主题内的_config.yml下修改<br>更换hexo NEXT的主题配置之后必须要先hexo clean才能生成对应的主题</p>
<h3 id="图片的URL问题"><a href="#图片的URL问题" class="headerlink" title="图片的URL问题"></a>图片的URL问题</h3><p>前面已经配置好了,所以我不记得了,下面说点小问题.<br>如果图片在本地预览正确,但是hexo生成的带了绝对路径,那么大概是图片的路径前面多了个&#x2F;,虽然在(Windows)本地&#x2F;不影响这个图片的路径的查找,但是hexo为图片不会生成一个带日期的路径,</p>
<ol>
<li><p>安装插件 asset-image 但是这个插件好像需要一点修改</p>
</li>
<li><p>npm install <a href="https://github.com/CodeFalling/hexo-asset-image">https://github.com/CodeFalling/hexo-asset-image</a></p>
</li>
<li><p>设置图片为相对路径</p>
</li>
<li><p>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s 运行查看<br>hexo配置需要启用post_asset_folder: true<br>关闭动画<br><strong>motion</strong> 修改为false</p>
<h1 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h1><h2 id="评论区如何解决"><a href="#评论区如何解决" class="headerlink" title="评论区如何解决"></a>评论区如何解决</h2><p>博客有评论的功能是最好不过的,不能老让人家发邮件,也不方便整理.</p>
<h2 id="迁移博客到别的平台"><a href="#迁移博客到别的平台" class="headerlink" title="迁移博客到别的平台"></a>迁移博客到别的平台</h2><p>这里需要从gitee迁移到github.<br>首先可以在github中<a href="https://github.com/new/import">Import a Repository (github.com)</a>  复制原来仓库链接进行迁移.<br>修改.deploy_git 下.git中的config文件内包含的远程仓库的地址.或者用命令修改.</p>
</li>
</ol>
<p>本地重新安装node后安装npm,然后这里是hexo博客,就</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后这里不需要hexo init了,直接在原来的博客文件夹下,我这里是myweb,hexo s测试一下结果.<br>使用hexo n “博客标题”来创建博客文章</p>
<p>github相比gitee的pages,仓库名需要alwaysmy.github.io加上后面的github.io才行</p>
<p>修改hexo中_config.yml下的url为github page给出的url,仓库改成git协议的仓库</p>
<p>文章中开头的描述后面需要有空格</p>
<h1 id="添加附加信息"><a href="#添加附加信息" class="headerlink" title="添加附加信息"></a>添加附加信息</h1><h2 id="添加github和邮箱"><a href="#添加github和邮箱" class="headerlink" title="添加github和邮箱"></a>添加github和邮箱</h2><p>打开 <code>~\themes\next\_config.yml</code> 文件，找到 <code>social</code> 相关的设置，取消掉需要的菜单项的注释。</p>
<p>打赏<br>reward:</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客发布插入图片的几种方法</title>
    <url>/2023/02/11/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>这里说的情况都是markdown的文件。</p>
<span id="more"></span>
<p><strong>1、图床外链</strong><br>这需要上传图片，多少有些不方便，还取决于图床稳定。<br><strong>2、上传图片到仓库</strong><br>能解决自建博客的问题，但是复制到别的平台发布的时候有些不方便，不能自动上传图片。不过可以通过<br>复制博客可以obsidian的复制自动转成markdown功能，再发布到别的平台上。<br><strong>3、图片转base64直接嵌入md文档</strong><br>这个图片会跟着文件走，基本上是最稳妥的方式，但是在本地端不太好保存回去成图片。（快捷方法？）而且由于里面字符太多，搜索英文的时候会有很多误判断的结果。<br>可以使用小米笔记编辑博客文档，图片会自动转成base64。<br><strong>4、<a href="../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/OneNote%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/OneNote%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87.md">OneNote复制图片</a></strong><br>OneNote用Ctrl+C复制图片粘贴到Obsidian里面的时候会附带图片的Base64和图片的OCR文字内容</p>
<h1 id="具体语法"><a href="#具体语法" class="headerlink" title="具体语法"></a>具体语法</h1><p>1 最常见的markdown语法<br>2 HTML</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;双路混音器制作记录/image-20211113034220481.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image-20211113034220481&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom: 67%;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./长白山行简记/IMG_20230606_195217-01.jpeg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;600&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="部署之后的显示"><a href="#部署之后的显示" class="headerlink" title="部署之后的显示"></a>部署之后的显示</h1><p>Hexo默认的图片显示方法和md语法不兼容。。。<br>1、如果使用默认md语法：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">{% asset_img "span>" "<span class="string">name</span>" %}</span><br></pre></td></tr></table></figure>
<p>这时候渲染就会出问题。</p>
<p>网上说法很多，我分不太清，实测有效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-image-link --save</span><br><span class="line">npm install hexo-asset-image -- save</span><br></pre></td></tr></table></figure>
<p>然后打开hexo config中的：<br><code>post_asset_folder: true #是否启用资源文件夹（用来存放相对路径图片或文件）</code></p>
<p>这两个似乎不是一个效果，但是考虑到有效我就不折腾了。。。</p>
<p>2、使用HTML插入图片</p>
<p>这个方法和typero一样，也就是上面的方法，这种方法能直接显示的。一般不会遇到问题。缺点是在obsidian里面显示不出来。。。不过TypeDown也可以显示。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>博客的Tags和分类</title>
    <url>/2021/11/01/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/%E5%8D%9A%E5%AE%A2%E7%9A%84Tags%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>上面是个示例，categories不能多个，写两个代表嵌套。</p>
<p>在next主题内，还需要添加：<br>打开 <code>~\themes\next\_config.yml</code> 文件，找到 <code>menu</code> 相关的设置，取消掉需要的菜单项的注释。</p>
<p>categories: - [学习,html] - [学习,http]  这样也可以代表嵌套</p>
<h2 id="本地分类管理"><a href="#本地分类管理" class="headerlink" title="本地分类管理"></a>本地分类管理</h2><p>通过该命令 <code>hexo new post -p /后端/test.md</code> 执行后，会在post文件夹下创建子文件夹 “后端”，并创建一篇test.md博文。<br>可以直接在D:\MyWeb\source_posts下新建需要的文件夹进行分类，这样就可以直接对接在obsidian里面写的文章。</p>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/50787870#:~:text=Hexo%2BGithub%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%9A03%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%201%201%E3%80%81%E5%88%9B%E5%BB%BA%E2%80%9C%E5%88%86%E7%B1%BB%E2%80%9D%E9%80%89%E9%A1%B9%202%201.1%20%E7%94%9F%E6%88%90%E2%80%9C%E5%88%86%E7%B1%BB%E2%80%9D%E9%A1%B5%E5%B9%B6%E6%B7%BB%E5%8A%A0tpye%E5%B1%9E%E6%80%A7%20%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%8D%9A%E5%AE%A2%E6%89%80%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%82%20%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4,-%20jQuery%20-%20%E8%A1%A8%E6%A0%BC%20-%20%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%20%E5%B0%B1%E6%98%AF%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E6%A0%87%E7%AD%BE%E4%BA%86%20">Hexo+Github博客教程：03添加分类 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>已有博客仓库的重建和配置</title>
    <url>/2023/03/13/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/%E5%B7%B2%E6%9C%89%E5%8D%9A%E5%AE%A2%E4%BB%93%E5%BA%93%E7%9A%84%E9%87%8D%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每次重装系统什么的，虽然仓库我做了备份，但是还是要重新配置一下环境，为了以后都能无脑配置，这里集中记录一下过程。</p>
<span id="more"></span>

<p>···</p>
<h2 id="博客源文件重新加入备份"><a href="#博客源文件重新加入备份" class="headerlink" title="博客源文件重新加入备份"></a>博客源文件重新加入备份</h2><p>从NAS上打开MyWeb的Syncthing同步项目，勾选共享到这台电脑，设置一下路径就行，还有排除列表。<br>不过这一项不是必须的，因为如果之前做好了备份，只需要复制AppData下的文件，Syncthing的配置文件就在里面不用自己去修改了，下次重装的时候设置会保持不变。</p>
<p>重新安装nodejs, 不用勾选按照其他模块。<br>如果之前备份了appdata，模块应该还在。<br>尝试在博客存放文件夹下面cmd里面执行hexo -v看看能不能用，如果不能就重新安装hexo.(我没试)</p>
<p>然后后面的步骤就不用操作了，可以直接使用hexo命令了。</p>
<p>由于之前已经修改过git配置了，这里直接使用hexo d，可能会提示git仓库用户不一致，按照提示把git仓库加入安全目录即可发布。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Design an Arbitrary Waveform Generator Using the RP2040 MCU and a Digital-to-Analog Converter</title>
    <url>/2023/06/18/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/Design-an-Arbitrary-Waveform-Generator-Using-the-RP2040-MCU-and-a-Digital-to-Analog-Converter-DAC/</url>
    <content><![CDATA[<p>    标题是AI写的，本来我想写的是<code>用RP2040实现AWG</code> ，AI说我这个标题不够专业，给我改了一大串，我感觉确实挺🐂🍺，就直接贴上来了。</p>
<span id="more"></span>

<h1 id="为什么要写这个"><a href="#为什么要写这个" class="headerlink" title="为什么要写这个"></a>为什么要写这个</h1><p>网上有一堆RP2040实现的AWG的设计，其中有一个传播比较广泛的是一个用python写的<a href="https://www.instructables.com/Poor-Mans-Waveform-Generator-Based-on-RP2040-Raspb/">配合一个10bit R2R DAC实现的AWG设计</a>。然而，我认为它有错误:基本上所有的帖子认为连续的DMA传输直接使用例程中给出的控制传输的方法就可以了，然而这种传输方法会损失一个时钟周期用来搬运DMA配置。这意味着信号周期没有被严格控制。对于主频轻轻松松就可以达到270MHz的RP2040来说这个Bug很难看出来，但是如果生成信号波形周期较短就可以看到。B站有一个对于原开源项目的<a href="https://www.bilibili.com/video/BV1Xq4y1Y7eF">复刻</a>，在输出高频的时候就能看出来了。</p>
<pre><code>这个复刻的视频不够详细，后面我会给出具体测试结果。

不知道为什么RP2040作为树莓派一个很不错的产品，有相当多的讨论和开源环境，但是有些教程却始终是抄来抄去，甚至英文环境也是，可能确实是没啥人用这个做产品就是这样吧。。。包括下载配置，有更好的方法，但是容易找到的教程都是最开始手册上给出的方法。
</code></pre>
<p>一个原因是手册上没有直接给出DMA乒乓传输的例子和说明，而是通过一个称作“控制传输（2.5.6.2. DMA Control Blocks .RP2040-Datasheet）” 来说明如何连续传输数据到外设或者指定地址。我在反复怀疑自己了几天之后，决定直接写代码验证一下。</p>
<blockquote>
<p>Talk is cheap. Show me the code</p>
</blockquote>
<p>    我最开始不甚了解乒乓传输这个概念，说来惭愧，写了几年单片机，就用过一次DMA, 最后还因为操作逻辑不好处理舍弃了，其他时候要么是用垃圾单片机压根没有DMA，要么是没这需求。这里还是第一次正儿八经看看DMA怎么做。</p>
<p>代码验证想法是正确的，分别验证了原来的控制传输确实会出错，测试了信号波形，以及验证了使用PingPong传输能得到想要的结果。</p>
<pre><code>手册中给出的例子确实实现了连续传输不需要CPU介入，但是它从来没说过时序是严格的，单独为DMA循环传输做了功能的有STM32,配置循环就会自动从地址段环回取数据。RP2040的DMA IP核似乎是买的公版IP，不过用下来还是比较好用的。
</code></pre>
<p>下面正文里面详细说设计和测试。</p>
<h1 id="RP2040-DMA"><a href="#RP2040-DMA" class="headerlink" title="RP2040 DMA"></a>RP2040 DMA</h1><p>DMA，顾名思义，直接内存访问，无需使用CPU搬运数据。</p>
<p>有一个触发其他通道的概念比较有意思，可以配置为每个通道传输结束后会自动触发另外一个DMA通道启动，很明显，这样就可以实现一个PingPong传输了，甚至可以多个通道接力最后转回来。遗憾的是它并不能自己触发自己，所以实现连续传输至少需要两个DMA通道.</p>
<p>由于没有自动的循环模式，想要严格控制传输时序，就需要DMA通道在下一次传输前准备好，  </p>
<p>由于DMA通道配置的传输地址并不会自己回到最初的地址，因此每次传输结束后至少要重新配置传输起始地址才能在下一次传输中传输正确的数据。因此，这种方法保证了时间间隔的严格，但是作为牺牲是CPU必然要耗费一定时间参与传输任务。这可能对于其他任务是有影响的。</p>
<pre><code>然而RP2040是双核的，实在优化不出来完全可以扔到另一个核心跑（
</code></pre>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>模电</tag>
        <tag>rp2040</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>SD知识树</title>
    <url>/2022/12/17/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/SD%E7%9F%A5%E8%AF%86%E6%A0%91/</url>
    <content><![CDATA[<p>还没想好怎么写因为一直都没用上要写sd卡的东西了。。。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派RP2040 开发环境配置骨灰版(Raspberry Pico)</title>
    <url>/2022/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/0_RP2040%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="树莓派-RP2040-开发环境配置骨灰版-Raspberry-Pico"><a href="#树莓派-RP2040-开发环境配置骨灰版-Raspberry-Pico" class="headerlink" title="树莓派 RP2040 开发环境配置骨灰版(Raspberry Pico)"></a>树莓派 RP2040 开发环境配置骨灰版(Raspberry Pico)</h1><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><p>RP2040作为一款树莓派的单片机，一开始我以为会有很成熟的开发方案，结果发现网上的配置方法大多数是照着官方给的方法一抄，完全没有解释里面各个部分需要做什么的原因以及有什么过程需要了解学习，甚至没有说这个配置方案就是官方文档给出的【1】</p>
<span id="more"></span>
<p>（我最开始看的手册还没更新树莓派以外平台的写法，所以蒙圈了好久，以为这些环境配置方法是他们经验丰富才能总结出来的）。这些方法基本上都是照着文档来配置，好点的会给几个填坑的说明，然后到了调试配置阶段都是直接默认使用官方给出的picoprobe调试器的配置方法，实在是让人看了捉急，难道你们开发单片机都不用开Debug吗？</p>
<p>    这里总结了方法，先记录下来，当然还有一些东西没来得及琢磨 —- 之前我都是喜欢开箱即用的懒人，然而pico这个官方给的配置方法（C-SDK）实属不当人。</p>
<p>先在这里解释一下公共的部分：</p>
<h3 id="0-1-关于调试使用的Debugger"><a href="#0-1-关于调试使用的Debugger" class="headerlink" title="0.1 关于调试使用的Debugger"></a>0.1 关于调试使用的Debugger</h3><p>官方做了一个特殊的daplink，叫做picoprobe, 就是直接用pico的板子加载一个dap的固件。在之前的说明中，包括现在的文档都指出这个picoprobe所使用的openOCD都需要raspberry分支下的openocd才能用，同样，配置文件也是专用的。       我目前还没试不知道普通的cmsis-dap的配置能不能用，也不知道能不能直接用通用的openocd，因为我没有picoprobe。但是标准的cmsisdap v2是部分可用的，不过实测v1的似乎都不能连接上多核，单核似乎也不行，不过也不是所有v2固件的daplink都可以连接上，具体原因未知。目前测试基本正常的是wch-link。</p>
<p>        另外也可以使用pico-debug这个固件加载自调试，后面调试章节会说到。</p>
<p>        在Windows下如果用picoprobe需要使用Zadig为其安装驱动为libusb-win32。（不知道现在还是不是这样，网上有的教程还提到了需要复制一个dll文件，但是我看现在的openocd.exe目录下已经包含了这个dll）</p>
<p>        而调试服务器在这里一般是使用openocd来完成这个的，不过用pyocd也可以。openocd除了能直接搜到的Github地址之外，也可以从这下载：<a href="https://gnutoolchains.com/arm-eabi/openocd/">Download OpenOCD for Windows (gnutoolchains.com)</a>，不过后者似乎比较老？反正需要下载最新的，目前的0.12 rc1版本存在bug。</p>
<h3 id="0-2-下载UF2固件的方法"><a href="#0-2-下载UF2固件的方法" class="headerlink" title="0.2 下载UF2固件的方法"></a>0.2 下载UF2固件的方法</h3><p>在rp2040运行前按住boot按键然后运行就会让rp2040进入Boot模式，详细看官方手册。</p>
<p>最简单的方法是按住按键然后上电就进入boot模式了，然后电脑上就会出现一个叫做RP2-PI的硬盘驱动器，右键UF2文件，点发送到树莓派对应的驱动器（btw.如果是win11强烈建议改成win10右键菜单）。</p>
<p>复杂一点，如果不想重新上电，可以拉低Run引脚后按Boot，然后释放Run引脚，效果一样，还有软件进入的方法，比如arduino框架的固件配置了软件进入Boot模式，会让下载比较方便。后面会说到。</p>
<p>UF2（USB Flashing Format (UF2)）格式参考：<br><a href="https://github.com/microsoft/uf2">microsoft&#x2F;uf2: UF2 file format specification (github.com)</a></p>
<h3 id="0-3-环境配置的解释"><a href="#0-3-环境配置的解释" class="headerlink" title="0.3 环境配置的解释"></a>0.3 环境配置的解释</h3><p>下面的解释都是默认我们配置了环境变量再来说的，如果有的地方没有提到什么程序加入了环境变量就用了，那就是忘了说，除了说了可以不加。当然这个也很好理解，遇到找不到程序基本上就加环境变量就好了。</p>
<h3 id="0-4-参考文档"><a href="#0-4-参考文档" class="headerlink" title="0.4 参考文档"></a>0.4 参考文档</h3><p>[1] getting-started-with-pico.pdf.官网文档（目前还在更新）</p>
<h3 id="0-5-这篇文章说了些什么"><a href="#0-5-这篇文章说了些什么" class="headerlink" title="0.5 这篇文章说了些什么"></a>0.5 这篇文章说了些什么</h3><p>为了试试哪个环境更顺手，所以我找了好几个方案全都试了试。主要包含MicroPython、PlatformIO的方法、基于第三方IDE的方法和基于官方C-SDk给出的cmake的配置方法和后续的导入IDE的配置方法。除了最后一种，前面三种算是开箱即用，不过如果对于cmake不熟悉，了解一下官方给出的方法还是不错的，已经熟悉的话就很容易看出来怎么回事了。</p>
<p>如果想直接用官方的方法可以直接按目录跳到第四章节。<br>一个纠错：官方方法默认不支持SWD的printf半主机模式，不过实际上可行。</p>
<h2 id="1-MicroPython环境"><a href="#1-MicroPython环境" class="headerlink" title="1 MicroPython环境"></a>1 MicroPython环境</h2><p>这个虽然简单，但是用python我不是很认可，而且micropython不能支持多核操作。<br>简单说一下：</p>
<p>1、<a href="https://www.raspberrypi.org/documentation/pico/getting-started/">Raspberry Pi Documentation - Microcontrollers</a>，选择<strong>Getting Start with MicroPython</strong>，<a href="https://micropython.org/download/rp2-pico/rp2-pico-latest.uf2">下载uf2固件</a>后烧录到rp2040上，打开设备管理器会发现多了一个COM端口（就是串口）。</p>
<p>2、下载<a href="https://thonny.org/">Thonny IDE</a>, 打开Thonny，右上角点击切换至一般模式，然后点击视图，勾选上这三个：Shell、变量、文件，当然还有别的，这几个最常用。</p>
<p>3、Thonny：工具-设置-解释器-选择Raspberry Pi Pico的解释器，然后选择串口端口，这个端口可以看刚刚设备管理器多出来的那个端口就是的。也可另外用别的工具直接连板子上的串口，波特率是115200。</p>
<p>4、进入shell直接依次执行python语句测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line">led = Pin(<span class="number">25</span>, Pin.OUT)</span><br><span class="line">led.value(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>5、写python文件</p>
<p>在Thonny里面编辑文本后保存的时候选择保存到pico就行了，开机默认自动运行main.py .</p>
<p>6、资料：<br><a href="https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-python-sdk.pdf">Raspberry Pi Pico Python SDK</a>    <a href="https://www.raspberrypi.com/documentation/microcontrollers/micropython.html">Raspberry Pi Documentation - MicroPython</a></p>
<p>8、至于开发，随便找个帖子吧：<a href="https://zhuanlan.zhihu.com/p/359823300">目前全网最详细的树莓派 Pico入门指南！ - 知乎 (zhihu.com)</a></p>
<p>开发相对容易，导入包很简单，也支持pio操作，所以说效率上如果用了pio也是可以接受的。</p>
<p>还有一个VSCODE插件：<br><a href="https://marketplace.visualstudio.com/items?itemName=paulober.pico-w-go">Pico-W-Go - Visual Studio Marketplace</a></p>
<h2 id="2-PlatformIO环境"><a href="#2-PlatformIO环境" class="headerlink" title="2 PlatformIO环境"></a>2 PlatformIO环境</h2><p>如果不喜欢用PlatformIO的话另外说，比如它经常不显示出来主页，不知道为啥给我的感觉就是有点卡。</p>
<h3 id="2-1-Arduino框架环境"><a href="#2-1-Arduino框架环境" class="headerlink" title="2.1 Arduino框架环境"></a>2.1 Arduino框架环境</h3><p>个人认为，不在乎那个arduino框架的占用，其实还是一个很好的开发平台，对仿真器的支持也还可以。</p>
<p><strong>安装方式：</strong></p>
<p>板子里面搜rp2040或者rasp，安装对应的平台。</p>
<p><strong>文档：</strong></p>
<p><a href="https://arduino-pico.readthedocs.io/en/latest/sdk.html">Using the Raspberry Pi Pico SDK (PICO-SDK) — Arduino-Pico 2.6.2 documentation</a></p>
<p><strong>功能：</strong></p>
<p>支持arudino框架，配置有arduino风格的函数。</p>
<p>也支持在arduino框架下直接使用pico-sdk的函数，看文档应该是支持pio，支持多核，因为本身就是基于C-SDK的。</p>
<p><strong>下载调试：</strong></p>
<p>这个框架一般会自动选择调试工具，如果要更改就在工程下的ini文件里面添加两行，例如：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">upload_protocol</span> = picotool</span><br><span class="line"><span class="attr">debug_tool</span> = cmsis-dap</span><br></pre></td></tr></table></figure>

<p>上面的上传和debug参数可以分别改成</p>
<ul>
<li><p>cmsis-dap, 这个就是一般的cmsis-dap调试器（现在应该叫做daplink）</p>
</li>
<li><p>jlink ，</p>
</li>
<li><p>picotool ，就是UF2文件的上传工具</p>
</li>
<li><p>raspberrypi-swd ，就是用picoprobe作为调试器。</p>
</li>
<li><p><input disabled type="checkbox"> 
如果手上没有调试器或者不在意使用调试功能，那么点编译后在工程目录下.pio&#x2F;build下有uf2文件，首次需要手动上传arduino框架的uf2固件，之后后面就可以直接用platformio的上传功能，不用拔电上传了，盲猜固件内置了进入boot的代码，观察到确实运行时候点上传会进入大容量设备状态，但是实测接着上传不成功。。。（别的帖子说是可以的).</p>
</li>
<li><p><input disabled type="checkbox"> 
如果用openocd调试，点击侧边的调试，有一个pio debug的选项。如上所说支持三种外部debugger，不过我用dap v1的时候也不好使 ，自调试固件也不好使，别人说用官方的picoprobe是可以正常调试的（见参考链接）。实测使用WCH-link可以调试，能正常显示双核。点上传似乎不太好使，要点左边的调试，显示为PIO debug。下图为arduino框架下的调试。</p>
</li>
</ul>
<p><img src="/2022/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/0_RP2040%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/MyProjects\4_MyOutputs\学习内容的输出\单片机开发环境的配置\RP2040开发环境搭建\0_RP2040开发环境搭建\arduino框架可以调试双核-wchLink.png"></p>
<p>参考链接：<a href="https://community.platformio.org/t/cannot-debug-pi-pico-with-cmsis-dap-cmsis-dap-command-cmd-dap-swj-clock-failed/21300/8">Cannot debug Pi Pico with CMSIS-DAP - “CMSIS-DAP command CMD_DAP_SWJ_CLOCK failed” - PlatformIO IDE - PlatformIO Community</a></p>
<h3 id="2-2-基于pico-sdk的裸环境Wiz-IO"><a href="#2-2-基于pico-sdk的裸环境Wiz-IO" class="headerlink" title="2.2 基于pico-sdk的裸环境Wiz-IO"></a>2.2 基于pico-sdk的裸环境Wiz-IO</h3><p><a href="https://github.com/Wiz-IO/wizio-pico">Wiz-IO&#x2F;wizio-pico: Raspberry Pi Pico development platform for PlatformIO (github.com)</a></p>
<p>个人认为，如果这个方法不是存在一点调试的bug的话，应该是最快最完整的C-SDK的方法。目前调试只支持Windows。</p>
<p><strong>安装方式</strong></p>
<ul>
<li>PIO Home &gt; Platforms &gt; Advanced Installation</li>
<li>粘贴： <a href="https://github.com/Wiz-IO/wizio-pico">https://github.com/Wiz-IO/wizio-pico</a></li>
<li>点击INSTALL</li>
</ul>
<p><strong>功能</strong></p>
<p>支持原生C-SDK编写方式，所以功能都能支持，没有arduino框架当然也就不能支持UF2文件自动上传了。</p>
<p>写着下载支持cmsisdap picoprobe uf2，目前只支持Windows。</p>
<p><strong>下载调试：</strong></p>
<p>下载默认是uf2下载，需要rp2040先手工进入BOOT模式，稍微有点麻烦，可以参考后面的调试方法里面的一键进入BOOT.</p>
<p>如果要调试，在<code>platformio.ini</code>  里面添加对应的方式，比如</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">upload_protocol</span> = picoprobe</span><br><span class="line"><span class="attr">debug_tool</span> = picoprobe</span><br></pre></td></tr></table></figure>

<p>上面的值可以改成：cmsis-dap，picoprobe, uf2</p>
<p>不过我测试的时候感觉我的wch-link就没被调用过，，可能实际上这个框架里面估计也就picoprobe好使，不清楚是不是我的问题。</p>
<p>这个框架附带了picoprobe的固件，<code>picoprobe.uf2</code> have in <code>tool-pico-openocd</code> folder，看起来作者可能也就写了这么多。</p>
<h2 id="3-基于第三方IDE配置"><a href="#3-基于第三方IDE配置" class="headerlink" title="3 基于第三方IDE配置"></a>3 基于第三方IDE配置</h2><p>下面这几个都很方便，因为他们都提供了集成的SDK下载和模板工程的创建，不需要官方那一套配置。</p>
<h3 id="3-1-基于VisualGDB的Visual-Studio创建工程"><a href="#3-1-基于VisualGDB的Visual-Studio创建工程" class="headerlink" title="3.1 基于VisualGDB的Visual Studio创建工程"></a>3.1 基于VisualGDB的Visual Studio创建工程</h3><p>先安装visualGDB,这是一个给VS提供的跨平台包，关键词：VisualGDB的基本使用。</p>
<p>然后按照下面的方法，新建工程选模板，下sdk就好。</p>
<p><a href="https://visualgdb.com/tutorials/raspberry/pico/">Developing Raspberry Pi Pico Projects with Visual Studio – VisualGDB Tutorials</a></p>
<p>但是VisualGDB是收费的，告辞，看起来很简单，我没试过，也有人说用起来有Bug.</p>
<h3 id="3-2-基于Embedded-Studio"><a href="#3-2-基于Embedded-Studio" class="headerlink" title="3.2 基于Embedded Studio"></a>3.2 基于Embedded Studio</h3><p>下载链接：<a href="https://www.segger.com/downloads/embedded-studio/">SEGGER - The Embedded Experts - Downloads - Embedded Studio</a></p>
<p>社区版本免费，支持Jlink, GDB server，其中gdb server可以选 <code>jlink openocd pyocd st-link</code>这几种。</p>
<p>自带仿真器，自带rp2040例程，不过他的例程似乎都是干寄存器，似乎没有引用官方的pico-sdk，但是pico-sdk的文件是被包含在内的，只是有一些路径没有被包含，示例程序还是没用上SDK的内容。</p>
<p>编译较快，可以使用printf的特性直接输出到窗口（内建默认方法是RTT,也可以选semihost）首选项，Code &gt; Library &gt; Library I&#x2F;O。<br>    （<a href="https://www.cnblogs.com/jieruishu/p/8559595.html">RTT - 杰瑞鼠 - 博客园 (cnblogs.com)</a>  RTT（ Real Time Terminal）是SEGGER公司在<strong>jlink V</strong>4.90之后，针对Cortex-M和RX系列推出的嵌入式应用与用户进行交互的实时终端。MCU通过J-link与电脑连接并将打印信息输出到电脑上，电脑同时可以通过键盘等向MCU发送数据。无需复杂的工程配置，没有MCU内核的限制，并且打印字符还非常的流畅。其实现原理就是J-link与MCU共享内存。）</p>
<p>速度取决于the target buffer size。</p>
<p>而且软件支持多平台，工程配置很方便。</p>
<p>对于指定的工程，打开之后按F1会给出一些手册和提示。下面是具体的步骤。</p>
<h4 id="安装SDK"><a href="#安装SDK" class="headerlink" title="安装SDK"></a>安装SDK</h4><p>点Tools - Package manager,搜pico，点一下，然后点next，就可以安装好sdk了。</p>
<h4 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h4><p>点Project-Add project，选树莓派的第一个pico是官方的板子的，程序里面会给个bsp，不带pico就是裸片的工程，区别不大。</p>
<p>然后是工程配置：</p>
<blockquote>
<p><em>目标处理器选0或者1，对应核心，</em></p>
<p><em>编译器可以选gcc或者segger，</em></p>
<p><em>剩下一些配置默认就行，根据需要选</em></p>
</blockquote>
<p>然后编译，debug。</p>
<p>默认没有生成uf2文件。</p>
<p>工程配置可以修改C&#x2F;C++的包含路径，工程本身包含了部分pico-sdk的include路径，但是没有完全包含—-不知道具体原因是为啥—-没有被默认配置到包含路径的的包括hardware_xxx下的外设的库，这个路径对应</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">....\SEGGER Embedded Studio\v3\packagesRP2040_Pico_BSP\pico-sdk\src\rp2_common</span><br></pre></td></tr></table></figure>

<p>而且这个pico-sdk是不包含第三方库的。应该是可以自己加上去的，没有仔细试过（不知道会不会出现stdlib不兼容的情况，因为pico的c-sdk里面自己定义了个stdlib.h)<br>不过按照和前面的Cmakelist的路径添加，应该是可以做到这个工程和官方方法的工程代码兼容的方法的）</p>
<h4 id="仿真下载调试"><a href="#仿真下载调试" class="headerlink" title="仿真下载调试"></a>仿真下载调试</h4><h5 id="J-link"><a href="#J-link" class="headerlink" title="J-link"></a>J-link</h5><p>不支持V10以下的Jlink。。。也有的说能支持，但是反正我的Jlink Lite V9显示不支持multi-drop，也有人说需要Jlink v11才行。</p>
<p>参考链接：<a href="https://forum.segger.com/index.php/Thread/7762-SOLVED-RP2040-Support/?s=e9995ac861bb4d522b6c8a0165f8c96f24726aec">[SOLVED] RP2040 Support - J-Link&#x2F;Flasher related - SEGGER - Forum</a></p>
<p>官方文档指出至少需要v11:</p>
<ul>
<li>J-Link HW revision 11 or later (J-Link EDU Mini and J-Trace PRO V1 or later also supported)</li>
<li><a href="https://wiki.segger.com/Raspberry_Pi_RP2040">Raspberry Pi RP2040 - SEGGER Wiki</a></li>
</ul>
<p>合着来卖配件了，5块钱的单片机配不上这个尊贵的JLink.</p>
<h5 id="Daplink（Openocd）"><a href="#Daplink（Openocd）" class="headerlink" title="Daplink（Openocd）"></a>Daplink（Openocd）</h5><p>1、在Shell或命令行里面开一个openocd server等待连接，如：(这一步实际上可选)</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">openocd -f board/pico-debug.cfg</span><br></pre></td></tr></table></figure>

<p>这里这个配置文件是openocd自带的，其配置实际上调试的是rp2040的core0，也就是调试的是单个核心。</p>
<p>2、配置工程调试选项</p>
<p>工程上右键 - option - debug - debugger- 选gdb server，然后点gdb server选项，选openocd。</p>
<p>如果自己开命令执行的话就这样配置就可以了，点Debug就会启动gdb连接到刚刚开的openocd这个gdb server。</p>
<p>实际上第一步手动开一个openocd等待的过程可以省掉：</p>
<p>可以勾选工程选项里面debug下面的 <code>GDB Server-auto start gdb server</code> 为yes 。</p>
<p>然后填写<code>Debug &gt; GDB Server &gt; GDB Server Command Line</code>：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">openocd.exe -f board/pico-debug.cfg</span><br></pre></td></tr></table></figure>

<p>这个openocd要加入环境变量，或者使用绝对路径。</p>
<p>实测中，单核使用自调试固件的单核配置（也就是pico-debug.cfg这个配置），多核使用WCH-link使用标准的配置，都可以正常调试、查看变量寄存器。</p>
<p>如果想调试多核，标准多核的配置为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openocd -f interface/cmsis-dap.cfg -f target/rp2040.cfg</span><br></pre></td></tr></table></figure>

<p>只是如果使用单核的配置的情况下使用外部daplink的时候就不要让它自己启动openocd,不然连接不上(不知道为啥)。</p>
<p>在Embedded Studio中，默认调试支持半主机模式（semihosting），也就是支持printf输出到主机的debug窗口。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://discuss.em-ide.com/d/199-openocddap">在烧入配置中选择OpenOCD，用DAP仿真器进行下载。 - Embedded IDE Forum (em-ide.com)</a></p>
<p>这有个网上找的工程模板：<a href="https://github.com/majbthrd/pico-demos/tree/master/pico-ses">pico-demos&#x2F;pico-ses at master · majbthrd&#x2F;pico-demos (github.com)</a> 不过似乎没必要用，这个模板很老了，估计是还不支持rp2040 sdk的时候的时候做的，也是全都是干寄存器，配置的处理器类型也是一个通用M0+。所以按照最上面那样配置就可以了。</p>
<h3 id="3-3-基于RT-Thread-Studio"><a href="#3-3-基于RT-Thread-Studio" class="headerlink" title="3.3 基于RT-Thread Studio"></a>3.3 基于RT-Thread Studio</h3><p>国产软件，评价很高，社区版免费。<a href="https://www.rt-thread.org/download.html#download-rt-thread-studio">下载链接</a></p>
<p>如果不介意用rt-thread的话，那么可以去使用rt-thread studio（因为目前他支持rtt的工程使用官方给sdk模板）</p>
<p>支持jlink daplink，不过好像都不怎么好使。。</p>
<p>使用要登陆。。。有点蠢，bug也还不少。。安装的时候会出现超长路径导致不能放到比较长的路径里面（我已经关了路径长度限制）</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>先下载SDK, 随便开个窗口或者新建工程点进下载SDK的界面。</p>
<p>对于Pico,只能创建rtt工程，显示三种调试工具可选，点下载程序的小箭头可以改调试下载方式。</p>
<p>openocd调用的是pyocd，实测我手上的这个daplink v1不支持，已经测过ok的自dap是v2的也不好使，所以不知道好不好使,</p>
<p>jlink也是需要jlink支持，我的版本不够。</p>
<p>stlink不可能支持的。。只是显示出来了。</p>
<p>要先点一下调试配置，改一下可执行程序的位置和名称，默认的位置不对。。。点一下搜索项目按钮，选elf那个文件。（目前的版本是这样）</p>
<p>有人使用picoprobe替换驱动为libusb后用来调试（没看见他发调试成功的图啊）我也没成功过，所以不知道调试行不行。</p>
<p>参考链接：<a href="https://club.rt-thread.org/ask/article/5b94f05666f693db.html">RT-Thread-在 RT-Thread Studio 中使用树莓派 Pico 开发板RT-Thread问答社区 - RT-Thread</a></p>
<h3 id="3-4-Keil-MDK"><a href="#3-4-Keil-MDK" class="headerlink" title="3.4 Keil MDK"></a>3.4 Keil MDK</h3><p><a href="https://github.com/GorgonMeducer/Pico_Template">GorgonMeducer&#x2F;Pico_Template: An MDK template for Raspberry Pi Pico (github.com)</a></p>
<p>用这个模板，看起来还行，我就不测试了，不喜欢Keil。</p>
<p>参考链接：</p>
<p><a href="https://cloud.tencent.com/developer/article/1887970">MDK震惊！树莓派Pico的调试还能“单体自助”的？ - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p>使用方法：</p>
<pre><code>git clone https://github.com/GorgonMeducer/Pico_Template .

git submodule update --init
</code></pre>
<h3 id="3-5-其实还有很多方法"><a href="#3-5-其实还有很多方法" class="headerlink" title="3.5 其实还有很多方法"></a>3.5 其实还有很多方法</h3><p>基本上就是使用CortexM0+的对应文件并正确包含pico-sdk库的文件就可以了，其实后面CMakelist同理。</p>
<p>我看还有人用CrossWorks for ARM,很贵，不多说了。上面介绍的方法都是基于工程模板的，后面介绍的就是对应pico官方给出的基于Cmakelist的构建方法。</p>
<h2 id="4-基于官方C语言环境搭建"><a href="#4-基于官方C语言环境搭建" class="headerlink" title="4 基于官方C语言环境搭建"></a>4 基于官方C语言环境搭建</h2><p>关于CMake和CMakelist这里不再赘述，网上内容很多，先了解一下比较好。</p>
<h3 id="4-1-官方文档的方法总结"><a href="#4-1-官方文档的方法总结" class="headerlink" title="4.1 官方文档的方法总结"></a>4.1 官方文档的方法总结</h3><p>网上找的方法绝大多数都是基于getting-started-with-pico.pdf这个手册上的方法，最开始这个手册只更新了基于树莓派系统的配置，直接执行setup脚本就行了。</p>
<p>官方的配置里面很多配置文件问题一堆，比如上面的setup脚本，很可能自己的环境用不了。另外，配置中如果遇到问题，重新git pull或者直接覆盖更新自己之前下载的文件是最有可能能解决问题的方法。</p>
<p>总的来说，工程包含下载pico-sdk和pico-example–也就是例程–还有工程模板生成器来避免自己来配置一个工程重复的部分。然后需要CMake构建生成对应的makefile并构建，这其中需要对应的c编译器和arm c编译器完成上述过程。具体过程如下。</p>
<ul>
<li><p><input disabled type="checkbox"> 
<strong>安装需要的开发工具</strong></p>
<p>见下面的内容。</p>
</li>
<li><p><input disabled type="checkbox"> 
<strong>下载例程、SDK、模板生成工具</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/raspberrypi/pico-project-generator.git</span><br><span class="line">git clone -b master https://github.com/raspberrypi/pico-sdk.git</span><br><span class="line">cd pico-sdk/</span><br><span class="line">git submodule update --init</span><br><span class="line">cd ..</span><br><span class="line">git clone -b master https://github.com/raspberrypi/pico-examples.git</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这里配置更新子模块的时候如果报错，就更新到最新的SDK，大概是之前写的有问题。找不到子模块什么的。</p>
<ul>
<li><input disabled type="checkbox"> <strong>编译</strong></li>
</ul>
<p>后面的步骤里面详细说，大致就是：</p>
<p>cmake .. </p>
<p>make</p>
<ul>
<li><input disabled type="checkbox"> <strong>下载调试</strong></li>
</ul>
<p>需要安装openocd，后面细说。</p>
<p>调试参考getting-started-with-pico.pdf 5.3章节 第六节</p>
<p>swd的使用，调试也就是基于GDB的调试。</p>
<p>而且手册上的第七节讲了vscode的使用，后面具体说。</p>
<h3 id="4-2-Windows下的RP2040环境配置"><a href="#4-2-Windows下的RP2040环境配置" class="headerlink" title="4.2 Windows下的RP2040环境配置"></a>4.2 Windows下的RP2040环境配置</h3><p>目前我的环境是Windows11,不过Win10同理了。</p>
<h4 id="4-2-1-安装各类工具链"><a href="#4-2-1-安装各类工具链" class="headerlink" title="4.2.1 安装各类工具链"></a>4.2.1 安装各类工具链</h4><p><strong>cmake</strong>：</p>
<p>官方生成器是基于cmake构建的，安装的时候要勾选添加环境变量for all users。实际上就是系统环境变量。</p>
<p><strong>gcc-arm-none-eabi</strong>: </p>
<p> <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain">Arm GNU Toolchain</a>  ,这里没啥特殊要求，可以下最新的。安装完了之后手动勾选添加到路径，还要检查一下能不能直接在cmd里面使用arm-none-eabi-gcc命令，否则说明他添加的路径有问题，手工改一下（现在的版本应该直接可用）</p>
<p><strong>python</strong>：</p>
<p>后面用他的生成器要用。勾选环境变量，解除长路径限制。</p>
<p><strong>git:</strong></p>
<p>不用说。</p>
<p>上面的直接到官网下载最新版安装就行了，不用纠结版本要不要旧一点。</p>
<p><strong>Windows下的编译器</strong>：</p>
<p>这里有两种选择，现在这里说一下区分，一个是安装visual studio，一个是安装其他的比如MinGW。其中，前者的工具为NMake，使用的时候需要先启动vs的工作环境，得到配置的环境变量（或者直接加载环境变量也可以），后者的工具为Mingw32-make，配置更简单，只需要把bin目录加到环境变量就行，至于其他没有对比。</p>
<h5 id="a-visual-studio"><a href="#a-visual-studio" class="headerlink" title="a. visual studio"></a>a. visual studio</h5><p>需要调用vs的nmake，要用他的命令环境。从微软安装vs的社区版就好了，如果本来就有vs没有mingw又懒得装可以用这个方法，不然还是建议用MinGW。因为后面都需要从Visual Studio 2022 Developer Command Prompt这里打开其他的应用程序，使其具有内置的环境。</p>
<h5 id="b-使用MinGW替代visual-studio的方法"><a href="#b-使用MinGW替代visual-studio的方法" class="headerlink" title="b. 使用MinGW替代visual studio的方法"></a>b. 使用MinGW替代visual studio的方法</h5><p>实际上vs是可选的，只是官方手册里面提供的方法是VS,实际上启动vs的环境非常不方便。</p>
<p>可以用mingw的minge32-make来替代vs的Nmake。</p>
<p>下载MinGW,把其bin目录加入环境变量。</p>
<p>目前mingw新的是mingw-w64,下载网址： <a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW-w64 - for 32 and 64 bit Windows - Browse Files at SourceForge.net</a></p>
<p>点下面的MinGW-W64 GCC-8.1.0标题下面的包，因为在线安装包压根连不上。</p>
<ul>
<li><a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z">x86_64-win32-seh</a>这个表示64位pc windows系统 seh错误处理的包（具体怎么选可以搜一下mingw-w64的安装)</li>
</ul>
<p>（或者mingw32下载链接：<a href="https://osdn.net/projects/mingw/#">https://osdn.net/projects/mingw/#</a> 上面是旧版mingw32，2017年就停更了，可能也能用，没试过）</p>
<p><strong>p.s.</strong> </p>
<p>使用旧版的mingw64可能编译报错，编译的时候可能会出现类似于<code>&#39;C:/Program&#39; 不是内部或外部命令，也不是可运行的程序</code>这样的问题。这里最终用刚刚下载的mingw -w64，测试OK.</p>
<p>c. 其实别的工具也可以ninja或者其他的gcc替代品，不复杂介绍了，</p>
<h4 id="4-2-2-配置路径SDK"><a href="#4-2-2-配置路径SDK" class="headerlink" title="4.2.2 配置路径SDK"></a>4.2.2 配置路径SDK</h4><p>上一步中，下好了pico-sdk,examples,还有generator，把pico-sdk放到自己指定的位置，然后把其目录加到环境变量里面，名称是PICO_SDK_PATH. 这个环境变量的路径是给配置出来的CMakelist引用的，还有后面的模板生成器也需要配置这个环境变量，配置方法如下：</p>
<p>a.可以使用使用powershell</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">setx PICO_SDK_PATH <span class="string">&quot;youpath\pico-sdk&quot;</span> </span><br></pre></td></tr></table></figure>

<p>b.或者Windows下面直接搜path，就能找到编辑系统环境变量的选项。</p>
<p>(其实这里没加也没关系，有别的方法，但是最好加上，因为generator默认用的是环境变量配置)。</p>
<p>c.当然也可以临时配置环境变量，但是没必要这样做, 不然每次都要重新导入环境变量：</p>
<p>在powershell内执行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$env:PICO_SDK_PATH</span>=pico<span class="literal">-sdk</span>的路径</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-编译例程测试"><a href="#4-2-3-编译例程测试" class="headerlink" title="4.2.3 编译例程测试"></a>4.2.3 编译例程测试</h4><p>其实这个步骤不是必须的，但是最好测试一次，同时也演示了不配置IDE怎么编译。</p>
<h5 id="a-如配置的是visual-studio的编译器"><a href="#a-如配置的是visual-studio的编译器" class="headerlink" title="a. 如配置的是visual studio的编译器"></a>a. 如配置的是visual studio的编译器</h5><p>也就是官方手册指出的方法，那么打开Visual Studio 2022 Developer Command Prompt：</p>
<p>使用快捷方式或者WindowsTerminal打开（Windows Terminal点加号旁边的下拉，里面有选项），打开之后会提示</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">**********************************************************************</span><br><span class="line">** Visual Studio <span class="number">2019</span> Developer Command Prompt v16.<span class="number">7</span>.<span class="number">2</span></span><br><span class="line">** Copyright (c) <span class="number">2020</span> Microsoft Corporation</span><br><span class="line">**********************************************************************</span><br><span class="line">[vcvarsall.bat] Environment initialized <span class="keyword">for</span>: &#x27;x86_x64&#x27;</span><br></pre></td></tr></table></figure>

<p>类似于上面这样表示加载了vs的环境，实际上也可以直接打开命令行之后通过执行<code>vcvars64.bat</code>这个文件来加载环境，也会给出一样的提示。</p>
<p>从刚刚打开的命令行或者powershell，进入<code>pico-example</code>目录：</p>
<p><em>（上一步可以选使用cmd还是powershell，如果用cmd，工程切换到别的盘先要换盘符，然后cd进去；</em></p>
<p><em>powershell可以直接进去）</em></p>
<p>然后，在build目录里面执行 <code>cmake .. </code>，表示取上层目录的cmakelist.txt，这里需要添加参数<code>-G &quot;NMake Makefiles&quot;</code>,表示生成的是Nmake对应的makefile。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. <span class="literal">-G</span> <span class="string">&quot;NMake Makefiles&quot;</span> </span><br></pre></td></tr></table></figure>

<p>如果这里能正常找到对应sdk、toolchain的路径，就不会报错。(就是前面都配置好PICO-SDK和arm-none-eabi-gcc.exe的环境变量了)</p>
<p>继续编译一个例程，比如blink这个程序，可以继续cd到pico-examples&#x2F;build目录下的blink(随着上面的步骤做完了，目前shell下的未知已经在build文件夹里面了)，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blink</span><br><span class="line">nmake</span><br></pre></td></tr></table></figure>

<p>这时候看编译信息，可以看到正常生成的信息。</p>
<p>进入build&#x2F;blink，右键xxx.uf2, 选择发送到RPI-RP2这个驱动器，发送完会自动运行。</p>
<p>对于pico-example，也可以进入example下的build目录后执行make（对应nmake或者mingw32-make）后直接编译全部例程，但是这样耗时比较长，没有必要这样做。</p>
<h5 id="b-如果配置的是MinGW"><a href="#b-如果配置的是MinGW" class="headerlink" title="b. 如果配置的是MinGW"></a>b. 如果配置的是MinGW</h5><p>直接在build目录打开shell，指定生成格式的makefile（不需要从那个VS的环境进）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake .. -G &quot;MinGW32 Makefiles&quot;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>mingw32-make</code>就可以编译了,其他的步骤和上面一样。只需要替换nmake命令为现在使用的mingw的mingw32-make。</p>
<p><strong>p.s.</strong> </p>
<p>如果在工程中先使用nmake的参数生成了makefile，再想要换成mingw32-make，这时候直接使用 <code>cmake -G &quot;MinGW32 Makefiles&quot;</code>生成makefile的话，会报错之前使用的不符合现在的配置，与之前的cmake generator不符，需要将build下的cmakecache文件删掉，再指定MinGW Makefiles.(也可以使用cmake-gui.exe直接手动切换)。不过实际操作用generator生成模板的时候可能有好几个cmakecache.txt都要删除，不然还是会报错。所以建议一开始就搞好。</p>
<h5 id="解释一下上面的语句"><a href="#解释一下上面的语句" class="headerlink" title="解释一下上面的语句"></a>解释一下上面的语句</h5><p>这里cmake是生成make工具对应的makefile。-G后面的参数用来指定工具，也可以用来生成IDE对应的工程文件。</p>
<p>使用<code>cmake --help</code>可以看到很多指令参数，里面有各种generator的名称，注意大小写,例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Borland Makefiles            = Generates Borland makefiles.</span><br><span class="line">NMake Makefiles              = Generates NMake makefiles.</span><br><span class="line">NMake Makefiles JOM          = Generates JOM makefiles.</span><br><span class="line">MSYS Makefiles               = Generates MSYS makefiles.</span><br><span class="line">MinGW Makefiles              = Generates a make file for use with</span><br><span class="line">                               mingw32-make.</span><br><span class="line">Green Hills MULTI            = Generates Green Hills MULTI files</span><br><span class="line">                               (experimental, work-in-progress).</span><br><span class="line">Unix Makefiles               = Generates standard UNIX makefiles.</span><br><span class="line">Ninja                        = Generates build.ninja files.</span><br><span class="line">Ninja Multi-Config           = Generates build-&lt;Config&gt;.ninja files.</span><br><span class="line">Watcom WMake                 = Generates Watcom WMake makefiles.</span><br></pre></td></tr></table></figure>

<p>比如也有人用Ninja，但是那需要ninja的构建文件，同mingw步骤。</p>
<p>以上就是标准的例程配置方法。</p>
<h4 id="4-2-4-生成自己的工程并编译烧录"><a href="#4-2-4-生成自己的工程并编译烧录" class="headerlink" title="4.2.4 生成自己的工程并编译烧录"></a>4.2.4 生成自己的工程并编译烧录</h4><p> 这一步就是使用pico-project-generator生成工程，下文中把pico-project-generator称作生成器。</p>
<p>**p.s.**（这里提前说一下，如果生成器启动有问题，首先更新pico-project-generator到最新的python文件；与有的早期教程不同，现在生成器在windows下面没有问题，能正常使用，不需要改动python的源码等步骤（是新版的python没有这个问题，3.10））)</p>
<p>进入pico-project-generator目录下，右键打开shell，运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python ./pico_project.py --gui</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">python ./pico_project.py -g</span><br></pre></td></tr></table></figure>

<p>这里建议找到pico_project.py 647行的self.locationName.set(os.path.abspath(os.getcwd()),改成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.locationName.<span class="built_in">set</span>(os.path.abspath(os.path.join(os.getcwd(), <span class="string">&quot;..&quot;</span>)))</span><br></pre></td></tr></table></figure>

<p>这样默认路径是pico_project.py的上层目录而不是与生成器的python文件在同级目录。</p>
<p>然后建议去掉开头那个logo，，，因为屏幕太小了话不合适的缩放会导致最后点不到确定按钮。，就是下面这两行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.logo = tk.PhotoImage(file=GetFilePath(<span class="string">&quot;logo_alpha.gif&quot;</span>))</span><br><span class="line">logowidget = ttk.Label(mainFrame, image=self.logo, borderwidth=<span class="number">0</span>, relief=<span class="string">&quot;solid&quot;</span>).grid(row=<span class="number">0</span>,column=<span class="number">0</span>, columnspan=<span class="number">5</span>, pady=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>这样就打开了生成器，然后按照需要勾选内容, 如下：</p>
<p><img src="/.%5C0_RP2040%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%5Cpico-project-generator1.png"></p>
<p>这样生成器就会根据指定的参数和默认的参数来生成工程需要的cmakelist和其他文件，其中指定参数至少需要指定PICO_SDK_PATH和把armgcc的bin目录加入环境变量，否则生成器会报错，而其他的参数可以使用默认值。</p>
<p>生成器的作用是复制需要的文件和生成对应的cmakelist，同时自动执行<code>cmake -G &#39;xxxmake Makefile&#39;</code>. （个人认为其实这个没有必要，后面使用ide的时候也会配置cmake的生成参数的，不过生成器没直接提供不执行cmake -G的方法）</p>
<p>具体可以看<a href="https://github.com/raspberrypi/pico-project-generator">raspberrypi&#x2F;pico-project-generator: Tool to automatically generate a Pico C SDK Project (github.com)</a>项目的readme，或者在命令下加上 –help来查看帮助。生成器本身也可以只在命令环境下执行，看需要自由发挥了。</p>
<p><strong>p.s.这里得注意</strong>，默认情况下，mingw的优先级高于vs，所以配置了两者都有的话，生成器优先生成基于mingw的工程，当然了，只是cmake -G的参数不同，可以改也可以自己切换。但是mingw挺好的。（不知道是不是环境变量的配置原因，我没深究，反正直接打开生成器生成的是会按照mingw的参数生成）</p>
<p><strong>在前面配置的编译器是vs的编译器的情况下，</strong></p>
<p>这里如果勾选Run build afer generation，那么需要先进入Visual Studio 2022 Developer Command Prompt的环境，然后打开在命令行里面这个生成器，不然缺环境来执行build，但是一般没有这个必要，不要勾选这个选项就行。</p>
<p>生成之后，进入工程目录下，只有一个 工程名.c 文件，main函数就在里面，编写这个文件就可以了。</p>
<p>如果只有这一个.c文件，也就是cmakelist不需要改动，那么直接从Visual Studio 2022 Developer Command Prompt进入工程下build目录，执行nmake就行了。</p>
<p>如果添加了其他的文件，就修改cmakelist.txt , 然后重新执行cmake -G “NMake Makefiles”，然后nmake就好.</p>
<p><strong>在前面配置的编译器是MinGW的情况下：</strong></p>
<p>直接打开生成器生成工程，然后直接在build目录下执行<code>mingw32-make</code> 就可以编译了，更新makefile的话就是，<code>cmake -G &quot;MinGW32 Makefiles&quot;</code></p>
<p>这时候，uf2，elf文件都在工程下build里面。</p>
<p>以上，就是标准的工程创建和配置流程。</p>
<p>至于cmakelist.txt怎么用，参考文档<a href="%E8%BF%99%E9%87%8C%E8%BF%98%E6%B2%A1%E5%86%99">xxxxx</a></p>
<h4 id="4-2-5、官方方法工程配置总结"><a href="#4-2-5、官方方法工程配置总结" class="headerlink" title="4.2.5、官方方法工程配置总结"></a>4.2.5、官方方法工程配置总结</h4><p>其实前面说过了，姑且当他首尾呼应吧。</p>
<p>1、配置好环境，下好官方sdk和例程还有生成器，配置好环境变量。</p>
<p>2、使用生成器生成工程（其实自己写cmakelist或者复制例程里面的cmakelist改一改然后复制必要的文件，自己做成模板是也可以）</p>
<p>3、使用nmake或者make（mingw32-make)编译</p>
<p>4、编译得到的uf2可以直接从usb启动，得到的elf可以使用swd烧录或调试（调试需要之前就编译参数指定为debug），bin文件可以烧录到flash</p>
<p>5、注意工程路径最好不要有中文。</p>
<h3 id="4-3-配置自己的IDE"><a href="#4-3-配置自己的IDE" class="headerlink" title="4.3 配置自己的IDE"></a>4.3 配置自己的IDE</h3><p>这一步基于上一步来完成，而不是前面说的已经官方集成模板的IDE。上一步中，直接打开文件夹里面文件编辑和编译，配置文件也不方便，编译烧录调试更不方便，这些都需要在命令行里面执行，添加文件还要自己写cmakelist（有自动扫描的方法，后面说），在生成了工程的前提下，选择一个IDE打开工程方便编辑。</p>
<ol>
<li><p><strong>首先选的可以是使用CMakelist作为配置的ide</strong>，这样直接建立工程就能用而不需要修改配置。比如：</p>
<ul>
<li><p>QtCreator</p>
</li>
<li><p>Netbeans</p>
</li>
<li><p>KDevelop Kdevelop 使用CMake作为其主要的项目配置方式。除此之外还支持qmake、makefile</p>
</li>
<li><p>codelite</p>
</li>
<li><p>Clion</p>
</li>
</ul>
<p>然而这里先说结论，除了CLion，其他的似乎都没有对嵌入式编程的调试有任何优化，编译很容易，但是调试很难配置，调试起来也麻烦，下面说。</p>
</li>
<li><p><strong>其他IDE</strong></p>
<p>CMake能够生成一些IDE的工程配置文件（如Visual Studio、CodeBlocks、XCode，Kate，CodeLite），比如Eclipse就有MCU的插件（这也是官方文档给出的方法之一），具体生成参数还是使用cmake –help来查询。剩下还有</p>
</li>
<li><p>VSCODE这种编辑器</p>
<p>后面说。</p>
</li>
</ol>
<p><strong>一般配置方法</strong></p>
<p>无论哪种方法，如果前面没有配置系统环境变量，那么需要在IDE内配置环境变量，但是如果之前配置过了系统环境变量，或者比如有的IDE集成了armgcc可选，那么这一步就忽略就好了：</p>
<p>PICO_SDK_PATH&#x3D;D:\MyProgramData\MCU_SDK\pico-sdk</p>
<p>PICO_TOOLCHAIN_PATH&#x3D;C:\Program Files (x86)\GNU Arm Embedded Toolchain\10 2021.10\bin\arm-none-eabi-gcc.exe</p>
<p>（其实这个arm gcc电脑上各个软件内的都下了好几个了，从platformio共用一个都行）</p>
<h4 id="4-3-1-CLion"><a href="#4-3-1-CLion" class="headerlink" title="4.3.1 CLion"></a>4.3.1 CLion</h4><p>使用CMakelist来构建的IDE其中最有名的可能是CLion了，官方start文档也给出了怎么配置基于CLion来配置.</p>
<p>如果需要配置环境，打开Clion后点设置，选 构建、执行、部署 ，CMake，点环境：增加用户环境变量。</p>
<p>在Clion中文件的路径，来源，函数来源都显示很清楚，引用的sdk也能直接显示出来，使用是比较方便的。</p>
<p>他确实方便，直接打开前面步骤中配置好的文件夹为Clion工程，配置一下openocd就可以用了。文件编辑什么的都很方便。</p>
<p>不过似乎不支持printf定向到IDE的debug输出。</p>
<p>编译比vscode快不少。</p>
<p>具体方法：我的文档【CLion配置rp2040工程】</p>
<p><strong>参考：</strong></p>
<p>官方文档：getting-started-with-pico.pdf 10.2. Using CLion</p>
<p><a href="https://www.stlee.tech/2021/06/14/CLion-%E4%B8%AD%E5%BC%80%E5%8F%91-RaspberryPi-Pico/">CLion 中开发 RaspberryPi Pico | St.Lee的个人站 (stlee.tech)</a></p>
<h4 id="4-3-2-VScode作为IDE"><a href="#4-3-2-VScode作为IDE" class="headerlink" title="4.3.2 VScode作为IDE"></a>4.3.2 VScode作为IDE</h4><p>通过插件支持完成对嵌入式设备的调试和对Cmake的支持。需要安装CMakeTool cortex-debug，实际上配置了cmake或者cortex-debug之后就不用自己写task.json了，还算方便。下面是步骤。</p>
<p><strong>a. 安装CMake插件</strong></p>
<p>打开设置，搜索 CMake Tools Configuration</p>
<p>找到Configure Environment, 添加上面最开始说的两个环境变量，如果已经有配置好的系统环境变量就可以不用配置。</p>
<p>找到CMake Tools Configuration - Generator，设置为NMake Makefiles或者MinGW Makefiles. 前者是对应使用VS的编译器，后者是对应使用mingw的编译器。</p>
<p>打开项目文件夹，第一次打开的时候会提示选择工具包，点一下选择有arm-none-eabi的这一项。选错过了也没关系，就在最下面的底边栏。</p>
<p></p>
<p><strong>b. 安装插件：cortex-Debug</strong></p>
<p>打开文件夹之后，按F7是Cmake的build，F5是cortex-debug的调试，当然具体快捷键是什么得看自己vscode的配置，这两种都能编译，后者会编译后启动openocd进行调试。</p>
<p><strong>c. 创建工程</strong></p>
<p>前面使用生成器的时候，勾选IDE Options上的创建vscode project，会自动生成vscode的配置.vscode。不过目前这个生成器的参数反正是有问题的，后面自己改一下保存成模板，以后自己复制到工程文件夹就行。</p>
<p>可以直接从Windows terminal里面加号打开Visual Studio 2022 Developer Command Prompt</p>
<p>使用vs的编译器：</p>
<p>首先，使用visual studio的命令行Developer Command Prompt for VS 2022，或者powershell也行，前面说了怎么打开了。</p>
<p>输入code打开vscode(vscode安装的时候默认添加到环境变量里面了)，这个实际上是%comspec% &#x2F;k “C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\Tools\VsDevCmd.bat”来进入命令，</p>
<p>说个简单点的启动方法：</p>
<p>找到电脑上的C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat 如果是32位机器就选后缀32的（现在应该不会了吧）然后打开，然后执行code。</p>
<p>可以写成脚本：</p>
<pre><code>call &quot;C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat&quot;
code
</code></pre>
<p>然后直接点击运行就行了。</p>
<p>developer Command Prompt for VS 2022</p>
<p>%comspec% &#x2F;k “C:\Program Files (x86)\Microsoft Visual Studio\2019\BuildTools\Common7\Tools\VsDevCmd.bat”</p>
<p>Pico CDC&#x2F;ACM USB 串口在Windows10、linux、Mac上是自动支持的，在win7上可能需要抓换usb驱动，下载Zadig &lt;<a href="https://link.zhihu.com/?target=https://zadig.akeo.ie/">https://zadig.akeo.ie/</a>&gt; 安装相应的驱动程序。选择 USB ID<code>2E8A</code>并使用驱动程序。<code>USB</code> <code>Serial</code> <code>(CDC)</code></p>
<p><strong>d. 配置Debug</strong></p>
<p>这里关键是配置.vscode下的配置json文件,下面分每个文件说一下。</p>
<p>launch.json：</p>
<p>自动生成的首先是gdb的路径没有适配系统，原来默认gdbPath是gdb multiarch, 在Windows下要改成 arm-none-eabi-gdb</p>
<p>然后configFiles的内容根据自己用的仿真器修改。</p>
<p>setting.json：</p>
<p>全局设置已经配置好的话，这里可以不修改，也可以把之前的插件设置的全局设置挪到这里来变成工程设置，比如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  &quot;cortex-debug.armToolchainPath&quot;: &quot;&quot;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &quot;cortex-debug.openocdPath.windows&quot;: &quot;D:\\MyPrograms\\1_DevelopTools\\MCU_Tools\\openocd-04887d3b6-i686-w64-mingw32\\bin\\openocd.exe&quot;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &quot;cortex-debug.openocdPath&quot;: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;cmake.generator&quot;: &quot;MinGW Makefiles&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;cmake.generator&quot;: &quot;NMake Makefiles&quot;</span></span><br></pre></td></tr></table></figure>

<p>同时cmaketool的几个按钮它默认候隐藏了，实际上确实没啥用，可以单独把Build按钮显示出来方便单独编译，就是改成default。</p>
<p>extensions.json：</p>
<p>就是推荐的插件，不用改。</p>
<p>上面几个文件配置好了之后自己备份一下，用来复制用。</p>
<p>另外，打开工程后，会提示使用Cmake的智能感知，这会在build下添加一个json用来给c_cpp的智能感知添加一个包含路径的配置，这样就能正确识别SDK的文件路径。</p>
<p>总结：</p>
<p>使用vscode的缺点是启动相当慢,差不多要两分钟，后面每次大概半分钟，应该可以改编译配置吧，没仔细看。</p>
<p>启动调试快捷键是ctrl+shift+D或者F5 ,F7只能编译。</p>
<p>同样不具备定向printf到debug窗口的功能。</p>
<p><strong>参考链接</strong>：</p>
<p><a href="https://blog.csdn.net/tianizimark/article/details/123060724">Raspberry-Pi-PICO系列–第四篇 开发环境搭建-Windows系统 + Visual Studio Code开发_coder.mark的博客-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/360721924">树莓派学习笔记4-pico的vscode c&#x2F;c++工程配置 - 知乎 (zhihu.com)</a></p>
<p>参考：<a href="https://blog.csdn.net/tianizimark/article/details/122708534">(104条消息) Raspberry-Pi-PICO系列–第一篇 初识RP2040_coder.mark的博客-CSDN博客_rp2040</a></p>
<h4 id="4-3-3-其他IDE配置"><a href="#4-3-3-其他IDE配置" class="headerlink" title="4.3.3  其他IDE配置"></a>4.3.3  其他IDE配置</h4><p>下面的配置都不太好用我觉得。。</p>
<h4 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -G &quot;Eclipse CDT4 - MinGW Makefiles&quot;</span><br></pre></td></tr></table></figure>

<p>参考官方教程，很详细。如果不想单独下个eclipse的话，看看电脑上哪个基于eclipse的IDE不是阉割的可以直接拿来用,不过我没找到。。</p>
<h4 id="Kdevelop："><a href="#Kdevelop：" class="headerlink" title="Kdevelop："></a>Kdevelop：</h4><p><a href="https://www.kdevelop.org/download">Download | KDevelop</a></p>
<p>更新有点慢，上次更新还是两年前。。怎么用Windows编译器的文档上次更新还是六年前。。。</p>
<p>然而，这个IDE没啥用，添加文件还是要自己写cmakelist。。。。并没有方便，虽然cmakelist可以图形管理。。<br>甚至编译后生成的文件都要重新加载才能显示。</p>
<p>所以，打开仍然需要从vs命令行打开，当然如果用mingw的话就不需要了。</p>
<p>debug配置方法：</p>
<p>运行-配置启动-然后更改gdb选项就可以用gdb调试了。</p>
<p>for the target set it to executable and the path to <code>build/your-project-name.elf</code></p>
<p>Click on the Debug part of the launch configuration and set the debugger executable to <code>/usr/bin/arm-none-eabi-gdb</code></p>
<p>Set the Run gdb script to the script created in the previous step. Click apply.</p>
<p>脚本内容：</p>
<pre><code>target remote localhost:3333

# monitor arm semihosting enable
mon reset halt
# openocd must be running in the correct dir for the relative paths to work

# Flash
mon flash write_image erase unlock build/your-project-name.bin 0x08000000
mon verify_image build/your-project-name.bin 0x08000000
mon reset halt


# Not sure why but this is needed for KDevelop
file build/your-project-name.elf
load
mon reset halt
disconnect
target remote localhost:3333
</code></pre>
<p>然后：</p>
<pre><code>openocd -f interface/stlink.cfg -f board/stm32h7x3i_eval.cfg
</code></pre>
<p>下面是参考资料：</p>
<p><a href="https://github.com/KDE/kdev-embedded">KDE&#x2F;kdev-embedded: Plugin for KDevelop to support the development of embedded systems (github.com)</a></p>
<p><a href="https://www.codelv.com/blog/2019/7/use-kdevelop-with-openocd-and-mbed-os">Use KDevelop with OpenOCD and mbed-os - CodeLV</a></p>
<p>放弃，我这里会提示elf不是启动文件，上面的教程是kdevlop3.</p>
<p>至于那个插件，是七年前的了。</p>
<p>安装，工程-打开&#x2F;导入-选择刚刚生成的工程文件夹，点构建就可以构建了。<br>使用yay -S gdb-multiarch 安装gdb-multiarch </p>
<p>linux下可以直接打开工程并构建，linux下的版本也更新，5.9到了。</p>
<h4 id="Kate"><a href="#Kate" class="headerlink" title="Kate"></a>Kate</h4><p>这个编辑器倒是算是正常。<br>不过仍然是linux下比较正常，windows下有bug，而且没有默认的gdb前端插件，所以没法调试，可能可以写插件来支持。。。</p>
<p>在linux下<br>使用yay -S gdb-multiarch 安装gdb-multiarch<br><a href="https://aur.archlinux.org/packages/gdb-multiarch">https://aur.archlinux.org/packages/gdb-multiarch</a><br>如果报错patch的话就显pamac install patch</p>
<p>点下面的构建，然后<br>构建插件编写为：<br>cd .&#x2F;build &amp;&amp; make<br>添加一个cmake构建命令<br>cmake -G “Kate - Unix Makefiles”&#x2F;&#x2F;或者Kate - MinGW Makefiles<br>添加一个构建cmake并编译命令<br>cmake -G “Kate - Unix Makefiles”&amp;&amp;cd .&#x2F;build &amp;&amp; make</p>
<p>这样就可以完成编译功能了。</p>
<p>调试功能：（只有linux下支持这个插件。。）</p>
<p>配置GDB<br>点下面的调试<br>GDB 设置<br>高级设置<br>改成远程TCP<br>自定义初始化脚本：不知道咋搞，应该和上面kdevelop的差不多。</p>
<p>如果不需要这个gdb前端的功能只需要烧录的话，可以使用外部工具的功能执行命令来调用swd烧录elf文件。</p>
<h4 id="Codelite"><a href="#Codelite" class="headerlink" title="Codelite"></a>Codelite</h4><p>这个IDE也是可以基于Cmake的，可以直接用cmake -G “CodeLite - MinGW Makefiles”来转一个工程出来</p>
<p>实测能用，效果还不错，但是配置调试比较麻烦，而且不管调试器连接没连上，都会提示连上了。。。而且似乎压根没法调试。但是确实能连上openocd。</p>
<p>利用外部工具执行烧录还是可以的。</p>
<p>同理：</p>
<p>CodeBlocks - MinGW Makefiles</p>
<p>参考：下面这是个stm32的配置<a href="https://blog.csdn.net/u012750409/article/details/52516653">https://blog.csdn.net/u012750409/article/details/52516653</a></p>
<h4 id="Embedded-IDE-on-vscode"><a href="#Embedded-IDE-on-vscode" class="headerlink" title="Embedded IDE on  vscode"></a>Embedded IDE on  vscode</h4><p>这个插件很强大，同时支持导入eclipse gcc的项目，所以可以通过</p>
<p>cmake -G “Eclipse CDT4 - MinGW Makefiles”来生成eclipse的GCC项目导入到vscode 的embedded IDE</p>
<p>就是这样有点麻烦。</p>
<p>由于 Eclipse CDT 和 EIDE 之间的设计差异，EIDE 暂时不能兼容 Eclipse 项目中的一些项目属性和构建设置</p>
<p>导入完成后，将生成一个 <code>.warning.txt</code> 文件，其中记录了所有不兼容的 Eclipse 项目属性</p>
<p>您需要根据这些属性的 <code>名称</code> 和 <code>值</code> 的含义修改 EIDE 项目的 <code>构建器选项</code>，直到可以正确编译</p>
<p>但是，它同样需要cortex-debug插件来支持调试。所以。。。没啥意义似乎。</p>
<h3 id="4-4-Linux环境的配置"><a href="#4-4-Linux环境的配置" class="headerlink" title="4.4 Linux环境的配置"></a>4.4 Linux环境的配置</h3><p>由于各种原因，Linux下配置简单一点。但是其实差不多。</p>
<h4 id="4-3-1-基于WSL安装PICO-C-SDK环境"><a href="#4-3-1-基于WSL安装PICO-C-SDK环境" class="headerlink" title="4.3.1 基于WSL安装PICO C-SDK环境"></a>4.3.1 基于WSL安装PICO C-SDK环境</h4><p>如果是Windows ，就安装WSL,参考笔记wsl安装</p>
<p><a href="https://www.cnblogs.com/tcjiaan/archive/2021/09/19/15307912.html">https://www.cnblogs.com/tcjiaan/archive/2021/09/19/15307912.html</a></p>
<p><a href="https://forums.raspberrypi.com/viewtopic.php?t=303209">https://forums.raspberrypi.com/viewtopic.php?t=303209</a></p>
<p><a href="https://www.rustyelectrons.com/posts/3-rp2040-development-with-wsl/">RP2040 Development with WSL | Rusty Electrons</a></p>
<p>假设这里已经安装好了前面对应的pico-sdk，example，generator，</p>
<p>还有需要的cmake make git armgcc：</p>
<p>sudo apt install cmake gcc-arm-none-eabi libnewlib-arm-none-eabi libstdc++-arm-none-eabi-newlib make</p>
<p>然后配置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> pico-sdk</span><br><span class="line"><span class="built_in">export</span> PICO_SDK_PATH=`<span class="built_in">pwd</span>` </span><br></pre></td></tr></table></figure>

<h4 id="下载例程编译例程"><a href="#下载例程编译例程" class="headerlink" title="下载例程编译例程"></a>下载例程编译例程</h4><p>和windows的步骤类似，简单点</p>
<p>下面是废弃步骤做个记录：</p>
<p>编译的时候提示cmake版本不够，直接编译新版的cmake安装。。。</p>
<p>sudo chmod 777 -R cmake-3.25.0-rc1&#x2F;</p>
<ol>
<li><p>.&#x2F;configure</p>
</li>
<li><p>make</p>
</li>
<li><p>sudo make instal</p>
</li>
</ol>
<p>sudo ln -sf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cmake &#x2F;usr&#x2F;bin  如果有老版本的cmake</p>
<p>然后编译cmake的时候发现没有g++。。。。。这个环境怎么什么都没有。。。</p>
<p>然后发现是国内源的问题，先换回官方源了。。。</p>
<p>正确步骤：</p>
<p>找到正确的源。。。</p>
<p><strong>编译例程</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/raspberrypi/pico-examples.git</span><br><span class="line"><span class="built_in">cd</span> pico-examples</span><br><span class="line"><span class="built_in">mkdir</span> -p build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到相应目录下找到 <code>*.uf2</code> 文件，将其复制到 RPI-RP2 的移动硬盘 即可完成下载。</p>
<h4 id="使用pico-project-generator生成自己的工程"><a href="#使用pico-project-generator生成自己的工程" class="headerlink" title="使用pico-project-generator生成自己的工程"></a>使用pico-project-generator生成自己的工程</h4><p>和Windows下类似，只不过如果是WSL下需要先需要手工安装tkinter（一般不需要）</p>
<p>sudo apt-get install python3-tk</p>
<p>使用python启动生成器。</p>
<pre><code>python3 pico_project.py --gui
</code></pre>
<p>生成的工程进入build</p>
<p>cmake ..</p>
<p>就可以编译了，直接make。</p>
<h2 id="5-其他另类方法"><a href="#5-其他另类方法" class="headerlink" title="5 其他另类方法"></a>5 其他另类方法</h2><p><a href="https://make.playpiper.com/">Piper Make (playpiper.com)</a><br>拖拽式网页图形编程。</p>
<h1 id="全局总结"><a href="#全局总结" class="headerlink" title="全局总结"></a>全局总结</h1><p>不是我说，官方方法是真他娘的复杂。(更新：收回此句吐槽。)</p>
<p>免费且最省事儿方法：</p>
<p>1、RTT studio -缺点，要登陆。。。</p>
<p>2、segger embedded studio -免费，知道怎么写程序的话可能是最省事儿的。</p>
<p>免费省事儿且可商用的方法：</p>
<p>1、platformIO</p>
<p>(arduino就是个框，引用函数都可以写一样) ，而且有别人做的包（<a href="https://github.com/Wiz-IO/wizio-pico%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%A3%B8%E7%8E%AF%E5%A2%83%E3%80%82">https://github.com/Wiz-IO/wizio-pico），可以使用裸环境。</a></p>
<p>缺点，platformIO容易崩溃，能用就不要动配置。</p>
<p>不省事，免费，能用，原生C SDK：</p>
<p>1、VScode 凑合用，配置完了也能调试</p>
<p>2、kdevelop 主要是这个软件不争气，起码作为ide管理文件还是方便的，基本上没法调试还不如kate</p>
<p>不免费但是好用：</p>
<p>Clion。</p>
<h1 id="swd下载方法"><a href="#swd下载方法" class="headerlink" title="swd下载方法"></a>swd下载方法</h1><p>openocd -f interface&#x2F;raspberrypi-swd.cfg -f target&#x2F;rp2040.cfg -c “program blink.elf verify reset exit”<br>openocd -f interface&#x2F;cmsis-dap.cfg -f target&#x2F;rp2040.cfg -c “program blink.elf verify reset exit”</p>
<h1 id="开发方法总结："><a href="#开发方法总结：" class="headerlink" title="开发方法总结："></a>开发方法总结：</h1><h2 id="1、如果不需要调试功能"><a href="#1、如果不需要调试功能" class="headerlink" title="1、如果不需要调试功能"></a>1、如果不需要调试功能</h2><p>（起码目前SWD连接体验很差，jlink有版本要求，daplink也不一定能用，picoprobe要单独做一个或者买一个）</p>
<p>先用arduino框架开发个大概，因为arduino框架不需要掉电重启进入boot模式，然后切换到wio的包用裸模式开发，这应该是体验最好而且免费开源的方法。缺点是编译比较慢。</p>
<p>至于其他的IDE即使不调试，也不一定好用。</p>
<p><strong>一键下载uf2</strong></p>
<p>上图所示，接线非常简单，只需要将GND和RUN引脚连接在一起，在需要更新固件时，我们只要按住我们刚添加的RESET按钮，BOOTSEL按钮；释放RESET按钮，然后释放BOOTSEL按钮，即可访问pico的flash，然后更新固件！</p>
<p>步骤：</p>
<p>按住我们刚添加的RESET按钮和BOOTSEL按钮释放RESET按钮释放BOOTSEL按钮拖动文件更新固件</p>
<p>参考：<a href="https://blog.csdn.net/qq_35181236/article/details/115297790">https://blog.csdn.net/qq_35181236/article/details/115297790</a></p>
<h2 id="2、需要调试的开发方法"><a href="#2、需要调试的开发方法" class="headerlink" title="2、需要调试的开发方法"></a>2、需要调试的开发方法</h2><h3 id="2-1-自调试"><a href="#2-1-自调试" class="headerlink" title="2.1 自调试"></a>2.1 自调试</h3><p>单核开发，不需要调试USB的情况下可以使用。</p>
<p>优点：不用说，只需要一根线就能调试了。</p>
<p>代价是占用16k内存（</p>
<ul>
<li>GIMMECACHE only: SRAM 0x2003C000 to 0x2003FFFF must not be used by user code）</li>
<li>，占用USB,占用一个核心。不过实际上，如果USB的功能最后再加进去，也可以下载进去，开发另外一个核心同理，只是不能调试了。如果用另外一个模式就会占用flash cache。</li>
<li>user code cannot reconfigure the PLL_USB, as the USB peripheral needs this（本来PLL_USB也就是固定48Mhz的吧）</li>
</ul>
<h4 id="基本使用方法："><a href="#基本使用方法：" class="headerlink" title="基本使用方法："></a>基本使用方法：</h4><p>下载 pico-debug-gimmecache.uf2 固件到rp2040，然后命令行</p>
<pre><code>openocd -f board/pico-debug.cfg
</code></pre>
<p>回显会提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Warn : rp2040-core0.cfg configuration file is deprecated and will be removed <span class="keyword">in</span> the next release. Use following parameters instead: -c <span class="string">&#x27;set USE_CORE 0&#x27;</span> -f target/rp2040.cfg</span><br></pre></td></tr></table></figure>

<p>这个pico-debug.cfg实际上就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source [find interface/cmsis-dap.cfg]</span><br><span class="line"></span><br><span class="line">adapter speed 4000</span><br><span class="line"></span><br><span class="line">set CHIPNAME rp2040</span><br><span class="line"></span><br><span class="line">source [find target/rp2040-core0.cfg]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openocd -f interface/cmsis-dap.cfg -f target/rp2040-core0.cfg -c  <span class="string">&#x27;adapter speed 4000&#x27;</span> -c <span class="string">&#x27;set CHIPNAME rp2040&#x27;</span></span><br></pre></td></tr></table></figure>

<p>按照提示,下面的方法一样（<code>set USE_CORE 0</code>要放中间）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openocd -f interface/cmsis-dap.cfg -c  <span class="string">&#x27;set USE_CORE 0&#x27;</span>-f target/rp2040.cfg  -c <span class="string">&#x27;adapter speed 4000&#x27;</span> -c <span class="string">&#x27;set CHIPNAME rp2040&#x27;</span> </span><br></pre></td></tr></table></figure>

<h5 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h5><p>上面那个会保持等待连接，然后另外开一个terminal， attach gdb to openocd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux下输入：</span></span><br><span class="line">gdb-multiarch picoboard_blinky.elf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在Windows下输入：</span></span><br><span class="line">arm-none-eabi-gdb.exe picoboard_blinky.elf</span><br></pre></td></tr></table></figure>

<p>然后连接gdb上去：</p>
<pre><code>(gdb) target remote localhost:3333 或者
target remote :3333 或者
target extended-remote :3333
同理，也可以远程调试，比如
target remote 192.168.31.16:3333
</code></pre>
<p>当然，远程连接的时候要先检测对应端口有没有被防火墙拦。<br>and load picoboard_blinky.elf into flash:</p>
<pre><code>(gdb) load
</code></pre>
<p>然后运行：</p>
<pre><code>(gdb) monitor reset init
(gdb) continue
</code></pre>
<p>如果需要下断点，就提前下好然后continue，也可以在编译之前时候就下好断点：</p>
<pre><code>(gdb) monitor reset init
(gdb) b main
(gdb) continue
</code></pre>
<p>也可以中途使用 <code>file filename.elf</code> 来更换执行文件，更换后用<code>load</code>加载。</p>
<p>ctrl+c来暂停正在运行的程序。</p>
<p>windows下输入<code>exit</code>或者ctrl-d退出gdb调试。</p>
<p>注意自调试下不要调试带usb的程序，会出bug，因为daplink本身就用了USB,会导致daplink失效，不过这样依然能把程序通过SWD下进去。</p>
<h4 id="基于VSCode的自调试"><a href="#基于VSCode的自调试" class="headerlink" title="基于VSCode的自调试"></a>基于VSCode的自调试</h4><p>前面打开工程的方法还是一样：</p>
<p><a href="https://blog.csdn.net/tianizimark/article/details/123060724">Raspberry-Pi-PICO系列–第四篇 开发环境搭建-Windows系统 + Visual Studio Code开发_coder.mark的博客-CSDN博客_树莓派pico开发环境</a></p>
<p>前面的配置步骤还是一样，就是哪些使用picoprobe的程序配置，后面只需要更改launch.json文件里面的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">configuration<span class="punctuation">:</span></span><br><span class="line"></span><br><span class="line">                <span class="attr">&quot;configFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;/interface/picoprobe.cfg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;/target/rp2040.cfg&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;configFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;interface/cmsis-dap.cfg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;target/rp2040-core0.cfg&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;openOCDLaunchCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;transport select swd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;adapter speed 4000&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>或者替换为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;configFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;interface/cmsis-dap.cfg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;target/rp2040.cfg&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;openOCDLaunchCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">   <span class="string">&quot;set USE_CORE 0&quot;</span></span><br><span class="line">    <span class="string">&quot;transport select swd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;adapter speed 4000&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>然后，把configurations下面的花括号以及其内容复制一份，加个逗号后加在后面做一些修改，用来增加一份配置方便切换。目的是方便在单核自调试和外部仿真器调试多核中切换。</p>
<p>同样的方法可以添加一份linux的配置。用来方便跨平台。</p>
<p>参考：</p>
<p><a href="https://github.com/majbthrd/pico-debug/blob/master/howto/openocd.md">pico-debug&#x2F;openocd.md at master · majbthrd&#x2F;pico-debug (github.com)</a></p>
<p><a href="https://github.com/majbthrd/pico-debug">majbthrd&#x2F;pico-debug：RP2040“Raspberry Pi Pico”的虚拟调试盒，无需添加硬件 (github.com)</a></p>
<h3 id="2-2-使用外部debug工具"><a href="#2-2-使用外部debug工具" class="headerlink" title="2.2 使用外部debug工具"></a>2.2 使用外部debug工具</h3><h4 id="2-2-1-买一个rp2040做一个picoprobe"><a href="#2-2-1-买一个rp2040做一个picoprobe" class="headerlink" title="2.2.1 买一个rp2040做一个picoprobe."></a>2.2.1 买一个rp2040做一个picoprobe.</h4><p>这绝对是体验最好的方法。既然用了picoprobe也可以就去配置vscode，也能调试，但</p>
<p>然后用platformIO的wio框架开发裸环境，这是最快的方法。是比较麻烦。</p>
<p>专用的openocd直接从platformio的platformio&#x2F;tool-openocd-raspberrypi下面扣一个。或者下载别人编译好的。（btw，现在好像不需要专用的openocd了）</p>
<h4 id="2-2-2-其他的daplink或者jlink"><a href="#2-2-2-其他的daplink或者jlink" class="headerlink" title="2.2.2 其他的daplink或者jlink"></a>2.2.2 其他的daplink或者jlink</h4><p>首先需要保证手上的cmsis-dap能用，这是大前提，有的dap在openocd里面效果有问题。尽管十块钱的wch-link就能调试了，但是很玄学，在win10上不行，在win11上又行。</p>
<h5 id="使用IDE来调试"><a href="#使用IDE来调试" class="headerlink" title="使用IDE来调试"></a>使用IDE来调试</h5><p>见前面的IDE配置文档。</p>
<h5 id="使用pico-generator生成工程"><a href="#使用pico-generator生成工程" class="headerlink" title="使用pico-generator生成工程"></a>使用pico-generator生成工程</h5><p>Clion体验组好，支持openocd</p>
<p>然后是vscode，配置很麻烦，cmakelist也要自己写，基本不考虑。</p>
<p>kdevelop是个five，不如vscode。</p>
<p>经过尝试，同样的openocd语句，板载的dap可以连上，我自己的就不行。</p>
<p>调试方法</p>
<p>probe的驱动需要安装为libusb-win32</p>
<p>关于openocd，除了picoprobe似乎没必要下载专用的openocd了，新的已经支持了，不过还没试过。</p>
<p>实测：</p>
<p>jlink需要v10以上，v9可认但是提示不支持。如果用openocd来的话需要替换驱动为winusb（zadig），当然我手上这个jlink lite v9还是不支持连接。<a href="https://zadig.akeo.ie/">Zadig - USB driver installation made easy (akeo.ie)</a></p>
<p><a href="https://imcbc.github.io/2022/04/09/pipico-swd/">使用Jlink-SWD下载与调试Raspberry Pi Pico | CBC Notes (imcbc.github.io)</a></p>
<p>普通daplink目前是连不上的，和openocd本身的问题可能有关吧。</p>
<p>如果启用了使用USB打印，确实运行的时候会初始化一个串口设备，第一次也会弹出安装“Pico”成功，这个串口设备也能连接，但是似乎串口助手没有收到东西。但同时有个启动失败的叫做Reset的设备，不知道是不是和驱动有关，</p>
<p>svd file就是CMSIS SVD(System View Description) ，相当于给编译器看的数据手册。</p>
<p>很奇怪，被指定50000 50001 50002端口的时候，wchlink就会连接不上，就像v1版本的daplink那样的报错。可能是因为指定端口的时候它阻塞了多核的按顺序分配端口。只有单核的时候没这个问题。这个插件实属有点离谱。<br>另外不是所有的v2都支持，有的也会提示mutidrop core连不上，比如我随便找的一个cmsis-dap v2的固件刷到了我的stm32板子上，能识别就是不认多核。</p>
<p>[rp2040.cpu] Could not find MEM-AP to control the core</p>
<p><a href="https://github.com/Marus/cortex-debug/blob/master/debug_attributes.md">cortex-debug&#x2F;debug_attributes.md at master · Marus&#x2F;cortex-debug (github.com)</a></p>
<p>正常的时候多核和单核的连接：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:\Users\AlwaysTS&gt; openocd <span class="operator">-f</span> interface/cmsis<span class="literal">-dap</span>.cfg  <span class="operator">-f</span> target/rp2040.cfg  <span class="literal">-c</span> <span class="string">&#x27;adapter speed 4000&#x27;</span> <span class="literal">-c</span> <span class="string">&#x27;set CHIPNAME rp2040&#x27;</span></span><br><span class="line">Open On<span class="literal">-Chip</span> Debugger <span class="number">0.12</span>.<span class="number">0</span><span class="literal">-rc2</span>+dev<span class="literal">-00988-g04887d3b6</span> (<span class="number">2022</span><span class="literal">-12-03-09</span>:<span class="number">30</span>)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line"><span class="keyword">For</span> bug reports, read</span><br><span class="line">        http://openocd.org/doc/doxygen/bugs.html</span><br><span class="line">adapter speed: <span class="number">4000</span> kHz</span><br><span class="line"></span><br><span class="line">rp2040</span><br><span class="line">Info : Listening on port <span class="number">6666</span> <span class="keyword">for</span> tcl connections</span><br><span class="line">Info : Listening on port <span class="number">4444</span> <span class="keyword">for</span> telnet connections</span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: SWD supported</span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: <span class="built_in">FW</span> Version = <span class="number">2.0</span>.<span class="number">0</span></span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: Interface Initialised (SWD)</span><br><span class="line">Info : SWCLK/TCK = <span class="number">1</span> SWDIO/TMS = <span class="number">1</span> TDI = <span class="number">0</span> TDO = <span class="number">0</span> nTRST = <span class="number">0</span> nRESET = <span class="number">1</span></span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: Interface ready</span><br><span class="line">Info : clock speed <span class="number">4000</span> kHz</span><br><span class="line">Info : SWD DPIDR <span class="number">0</span>x0bc12477, DLPIDR <span class="number">0</span>x00000001</span><br><span class="line">Info : SWD DPIDR <span class="number">0</span>x0bc12477, DLPIDR <span class="number">0</span>x10000001</span><br><span class="line">Info : [<span class="type">rp2040.core0</span>] Cortex<span class="literal">-M0</span>+ r0p1 processor detected</span><br><span class="line">Info : [<span class="type">rp2040.core0</span>] target has <span class="number">4</span> breakpoints, <span class="number">2</span> watchpoints</span><br><span class="line">Info : [<span class="type">rp2040.core1</span>] Cortex<span class="literal">-M0</span>+ r0p1 processor detected</span><br><span class="line">Info : [<span class="type">rp2040.core1</span>] target has <span class="number">4</span> breakpoints, <span class="number">2</span> watchpoints</span><br><span class="line">Info : starting gdb server <span class="keyword">for</span> rp2040.core0 on <span class="number">3333</span></span><br><span class="line">Info : Listening on port <span class="number">3333</span> <span class="keyword">for</span> gdb connections</span><br><span class="line">Info : starting gdb server <span class="keyword">for</span> rp2040.core1 on <span class="number">3334</span></span><br><span class="line">Info : Listening on port <span class="number">3334</span> <span class="keyword">for</span> gdb connections</span><br><span class="line">shutdown command invoked</span><br><span class="line"><span class="built_in">PS</span> C:\Users\AlwaysTS&gt; openocd <span class="operator">-f</span> interface/cmsis<span class="literal">-dap</span>.cfg <span class="literal">-c</span>  <span class="string">&#x27;set USE_CORE 0&#x27;</span> <span class="operator">-f</span> target/rp2040.cfg  <span class="literal">-c</span> <span class="string">&#x27;adapter speed 4000&#x27;</span> <span class="literal">-c</span> <span class="string">&#x27;set CHIPNAME rp2040&#x27;</span></span><br><span class="line">Open On<span class="literal">-Chip</span> Debugger <span class="number">0.12</span>.<span class="number">0</span><span class="literal">-rc2</span>+dev<span class="literal">-00988-g04887d3b6</span> (<span class="number">2022</span><span class="literal">-12-03-09</span>:<span class="number">30</span>)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line"><span class="keyword">For</span> bug reports, read</span><br><span class="line">        http://openocd.org/doc/doxygen/bugs.html</span><br><span class="line"><span class="number">0</span></span><br><span class="line">adapter speed: <span class="number">4000</span> kHz</span><br><span class="line"></span><br><span class="line">rp2040</span><br><span class="line">Info : Listening on port <span class="number">6666</span> <span class="keyword">for</span> tcl connections</span><br><span class="line">Info : Listening on port <span class="number">4444</span> <span class="keyword">for</span> telnet connections</span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: SWD supported</span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: <span class="built_in">FW</span> Version = <span class="number">2.0</span>.<span class="number">0</span></span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: Interface Initialised (SWD)</span><br><span class="line">Info : SWCLK/TCK = <span class="number">1</span> SWDIO/TMS = <span class="number">1</span> TDI = <span class="number">0</span> TDO = <span class="number">0</span> nTRST = <span class="number">0</span> nRESET = <span class="number">1</span></span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: Interface ready</span><br><span class="line">Info : clock speed <span class="number">4000</span> kHz</span><br><span class="line">Info : SWD DPIDR <span class="number">0</span>x0bc12477, DLPIDR <span class="number">0</span>x00000001</span><br><span class="line">Info : [<span class="type">rp2040.core0</span>] Cortex<span class="literal">-M0</span>+ r0p1 processor detected</span><br><span class="line">Info : [<span class="type">rp2040.core0</span>] target has <span class="number">4</span> breakpoints, <span class="number">2</span> watchpoints</span><br><span class="line">Info : starting gdb server <span class="keyword">for</span> rp2040.core0 on <span class="number">3333</span></span><br><span class="line">Info : Listening on port <span class="number">3333</span> <span class="keyword">for</span> gdb connections</span><br></pre></td></tr></table></figure>

<p><a href="https://lonesometraveler.github.io/2020/03/27/debug.html">Cortex-Debug for Visual Studio Code | Alone on a Mountaintop (lonesometraveler.github.io)</a></p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>rp2040</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的MSP430单片机学习（二）</title>
    <url>/2021/04/20/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MSP430%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>在认识了一款单片机产品之后，了解了它的开发方式和特点，就可以考虑使用它的资源了进行开发了。</p>
<h1 id="1-单片机的资源简介"><a href="#1-单片机的资源简介" class="headerlink" title="1 单片机的资源简介"></a>1 单片机的资源简介</h1><p>这里并不会用太多的篇幅，因为不同的单片机外设不一样，资源不一样，所以重要的是如何去了解。</p>
<span id="more"></span>

<p>烂尾了。。。430没啥意思，TI都把430办公室搬到印度去了，现在开始推M0了，最终还是走进了ARM的怀抱。</p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>MSP430</tag>
        <tag>8051</tag>
      </tags>
  </entry>
  <entry>
    <title>使用aardio写一个基于pyocd的单片机下载器</title>
    <url>/2023/04/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E4%BD%BF%E7%94%A8aardio%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Epyocd%E7%9A%84%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8B%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="1-新建工程"><a href="#1-新建工程" class="headerlink" title="1 新建工程"></a>1 新建工程</h1><p>最开始本来是打算调用pyocd 的python api的，但是一个是内嵌包一直安装出问题，一个是考虑到本地pack不想重复安装和管理，于是就转做pyocd的前端了，也就是直接调用pyocd，根据返回数据解析，然后执行要做的命令。</p>
<p>所以新建一个普通工程就可以。</p>
<span id="more"></span>

<h1 id="2-基本功能"><a href="#2-基本功能" class="headerlink" title="2 基本功能"></a>2 基本功能</h1><p>下载 擦除 复位，主要是这几个常用的，<br>然后要能选择对应的仿真器和单片机型号，能支持的列表，就要用一下pyocd list和pyocd list -t命令查询，根据返回的结果解析。<br>p.s 其实直接用pyocd json 命令返回json会很容易，但是我一开始没看到这个命令，就算了，正好生成命令pyocd list的执行结果也可以给人看。<br>其中pyocd list会返回仿真器的列表，我是通过head也就是第一行的标题的位置来得到下面每行内容的分割位置，得到正确的结果。这里发现是每隔一行为一个仿真器信息。<br>而pyocd list -t 返回可用器件型号，分割方法类似，不过这里不是每隔一行而是连续的每行都是对应结果，一开始这里没看到导致少了一半。<br>另外这里在使用aardio遇到一个bug就是结构体的值发生了变换（aardio实际上没有结构体而是表），不知道为什么，类似的方法直接赋值给数组就不会出问题。</p>
<h1 id="3-基本实现"><a href="#3-基本实现" class="headerlink" title="3 基本实现"></a>3 基本实现</h1><p><img src="https://img-blog.csdnimg.cn/1426b60440534a8c8c8c296d82f0e7b4.png" alt="基本界面"></p>
<p>除了基本界面，调整了一下布局，让他能缩放合适，内嵌了字体（软件凭空大了1M多，本来只有几百kb），主要是好不容易调整好了不想改。<br>把一些生成命令的语句例如pyocd gdbserver收纳到了菜单栏。<br>基本就这样。</p>
<p>这里有我上传的：<br><a href="http://www.51hei.com/bbs/forum.php?mod=viewthread&tid=228512">分享一个基于pyocd的单片机GUI下载器 - Cortex M3 M0 M4开发 (51hei.com)</a></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>aardio确实挺好用的，很能缝合，布局上也是自动缩放，要求不高的话很容易调整到还不错的效果。写起来很快，高分屏的问题也自动处理了，第一次用观感不错。不过有部分问题横竖找不到根源，倒是能换个方法解决。</p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>DAP-Link</tag>
        <tag>pyocd</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机学习入门（一）</title>
    <url>/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="从零开始的MSP430单片机学习（一）"><a href="#从零开始的MSP430单片机学习（一）" class="headerlink" title="从零开始的MSP430单片机学习（一）"></a>从零开始的MSP430单片机学习（一）</h1><blockquote>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>单片机学习本身是一个了解学习一个技术的过程，学习的过程中不应该拘泥于某一款，而是要了解学习的方法。</p>
<p>同时学习技术较快的方法是完成一个完整的项目，同时记录学习中遇到的问题整个培训下来会提供一个或者多个具体的例子供学习，也可自由发挥。</p>
<p>教程首先会简述单片机的学习方法，然后讲解具体的细节，然后讲解具体的项目来完成学习过程。</p>
</blockquote>
<p>本教程会以 MSP430 单片机为主进行讲解，对于接触单片机的初学者，同时推荐阅读《Launchpad口袋实验平台 （指导书）》.</p>
<hr>
<span id="more"></span>

<h2 id="1-MSP430单片机开发介绍"><a href="#1-MSP430单片机开发介绍" class="headerlink" title="1.MSP430单片机开发介绍"></a>1.MSP430单片机开发介绍</h2><h3 id="1-1-前情提要"><a href="#1-1-前情提要" class="headerlink" title="1.1 前情提要"></a>1.1 前情提要</h3><p>MSP430单片机是德州仪器（ TI ）出品的以超低功耗为主要特点的16位单片机系列产品，采用精简指令集（ RISC ），其称为混合信号处理器，其单片集成了数字、模拟模块以及处理器。</p>
<p>TI 官方提供了一些板卡（ launchpad ），作为仿真器和核心板在一块板的方式提供用来学习开发。</p>
<p>例如我们即将用到的 MSP-EXP430G2(-ET) 。</p>
<p>对于其他类型的单片机，市面上常见的8051系列产品（如STC、WCH等），ARM产品（如ST、NXP等)，有的也有官方提供的核心板或者网上有卖家提供的产品。</p>
<h3 id="1-2-G2-launchpad-介绍"><a href="#1-2-G2-launchpad-介绍" class="headerlink" title="1.2 G2 launchpad 介绍"></a>1.2 G2 launchpad 介绍</h3><ul>
<li><p><em>对于已有的资源，首先进行了解方便后续的学习</em></p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/%E5%8D%95%E7%89%87%E6%9C%BA%E5%B0%81%E9%9D%A2.png" class title="单片机封面">

<h4 id="1-2-1-从官方下载板卡资料。"><a href="#1-2-1-从官方下载板卡资料。" class="headerlink" title="1.2.1 从官方下载板卡资料。"></a>1.2.1 从官方下载板卡资料。</h4><p>从官网可以找到 <a href="https://www.ti.com.cn/tool/cn/MSP-EXP430G2?keyMatch=EXP%20G2&tisearch=search-everything">MSP-EXP430G2</a> 的产品资料，对于 TI 的产品还有别的方法进行下载，将在后面开发环境章节进行介绍。</p>
<p>找到 <em><strong>MSP-EXP430G2 Hardware Design Files</strong></em> ，其中包含了设计原理图（有助于在硬件连接的时候进行参考），设计PCB文件。</p>
<p>在这个产品提供的硬件设计资源（原理图和PCB文件）为 <a href="http://eagle.autodesk.com/">Eagle</a> 所制造，其文件可以用Eagle或者 <a href="https://www.autodesk.com.cn/products/fusion-360/overview">Fusion 360</a> 打开查看：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405185841746.png" alt="image-20210405185841746" style="zoom:75%;">

<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405185950827.png" alt="image-20210405185950827" style="zoom:75%;">

<p>一般查看PDF文件即可。</p>
<hr>
<p>在PDF查看原理图的时候，可以看到电路分为三部分，其中包含了接口，仿真器和单片机最小系统（后面称之为核心板）。</p>
<p>简单介绍一下 Launchpad 的组成:</p>
<p>下载器通过单片机的SWD接口可以下载程序到单片机，同时可以访问单片机内部资源因此可以仿真，这个下载器是TI的专用下载器，在 MSP-EXP430G2 这块开发板上，使用的下载器限制较大，只能下载部分MSP430单片机，同时提供一个串口用来连接调试。在新版的 MSP430G2553 开发板 <a href="https://www.ti.com.cn/tool/cn/MSP-EXP430G2ET">MSP-EXP430G2ET</a> 上，以及其他430 launchpad 上，使用的下载器为硬件开源的 <a href="http://software-dl.ti.com/msp430/msp430_public_sw/mcu/msp430/MSP430_ezFETLite/latest/index_FDS.html">MSP430_ezFETLite</a> ，具有更好的性能，可以下载几乎所有的MSP430系列单片机，同时提供串口。</p>
</li>
</ul>
<h4 id="1-2-2-从官方下载芯片数据和用户指南手册以及例程。"><a href="#1-2-2-从官方下载芯片数据和用户指南手册以及例程。" class="headerlink" title="1.2.2 从官方下载芯片数据和用户指南手册以及例程。"></a>1.2.2 从官方下载芯片数据和用户指南手册以及例程。</h4><p>  不同的单片机厂商都会在其产品主页提供用户手册和产品数据表供使用。对于 TI 的产品，可以直接在其官网搜索对应的产品型号并点击进入，或者在CCS中下载其产品支持包，这个方法在开发环境章节中讲解。顺便一提，如果使用Bing或者Google作为搜索引擎，直接搜索找数据表和手册是一件很容易的事情。</p>
<p>  同时，对于单片机类产品，通常官方会提供例程供开发使用，因为单看手册就写有点麻烦。这里以MSP430G2553 为例，讲解一下如何在毫无了解的情况下进行入门：</p>
  <img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405192138665.png" class title="image-20210405192138665">

<p>  进入产品主页之后，首先可以看到数据表（datasheet）和用户指南。这些肯定是要查看的。</p>
<p>  同时，点击技术文档，可以看到 TI 提供的更多相关技术的文档 ，可以进行下载阅读。</p>
<p>  比较重要的是，<strong>设计与开发</strong>，点击后，可以看到 TI 提供了指示，提示应该用什么方法进行开发，使用什么软件，最后一项：</p>
  <img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405193131040.png" class title="image-20210405193131040">

<p>  提供了代码例程。</p>
<p>  对于其他厂商的单片机同理，不过这里可以先不下载，因为有更方便的方法。</p>
<p>  可以看到，设计与开发中，其指示了用于MSP的 集成开发环境。</p>
<p>  这就是下一章节所需要讲解的。</p>
<h4 id="1-2-3-硬件信息补充"><a href="#1-2-3-硬件信息补充" class="headerlink" title="1.2.3 硬件信息补充"></a>1.2.3 硬件信息补充</h4><p>  针对 TI 的开发板，其只是一个核心板，因此如果需要扩展功能，可以引线出来，也可以通过外接拓展板，这个拓展板子TI为其提供了一个通用的格式，称之为 <a href="https://github.com/adrianF-TI/BuildYourOwnBoosterPack">BoosterPack</a> 插件，可以通过这个模板进行自己的开发。</p>
<h3 id="1-3-集成开发环境介绍"><a href="#1-3-集成开发环境介绍" class="headerlink" title="1.3 集成开发环境介绍"></a>1.3 集成开发环境介绍</h3><p>要进行单片机开发，首先选择合适的集成开发环境（ IDE )，并基于这个IDE进行开发。</p>
<p>首先，可以认为，官方所提供开发的集成开发环境通常是最方便的，因为能得到较好的技术支持，而且官方提供的 IDE 通常是免费的。</p>
<p>在上一章节中，在<strong>设计与开发</strong>内，TI 介绍了<a href="https://www.ti.com.cn/tool/cn/CCSTUDIO-MSP"> Code Composer Studio (CCS)</a> ，也介绍了<a href="https://www.ti.com.cn/tool/cn/IAR-KICKSTART">IAR 嵌入式工作平台 Kickstart - 免费 8KB 版本</a>.</p>
<p>其中，可以看到：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405194214472.png" alt="image-20210405194214472" style="zoom:80%;">

<p>CCS 作为官方IDE,内容是更多的。可以从官网获得更多技术支持。</p>
<p>在区别上，CCS内建的编译器和IAR的编译器存在一些不同，同时还有开源产品<a href="https://www.ti.com.cn/tool/cn/MSP430-GCC-OPENSOURCE">MSP430-GCC</a> 也可以用来编译代码，所以在官方提供的例程中可以看到一些预编译的符号用来区分不同的编译器。</p>
<p>CCS 是基于 eclipse（开源的 IDE）开发，瑞萨的 E2studio ,意法半导体（ST）的 STM32CUBEIDE 都是基于 Eclipse 设计，所以基本用法类似，所以使用IDE的快捷键以及操作可以通过在搜索引擎上以 Eclipse 为关键词进行搜索。</p>
<p>同时 CCS 也是 TI 官方推荐使用的IDE , TI甚至提供了基于云端的CCS cloud 可以进行开发。加之CCS更具专业性，后面所讲的开发环境都会基于CCS讲解。</p>
<hr>
<p>说到专业性，TI 也提供了一个不那么专业的 IDE —- <a href="https://energia.nu/">Energia</a> , 其实就是一个红色版本的 Arduino ，只不过可以使用 TI 自家的板卡。其使用了与 Arduino  相同的语法和库，所以开发板卡在某些应用上更快更简单，但是如果想要使用开源社区的库以及社区提供的更多的板卡支持，推荐使用基于 <a href="https://code.visualstudio.com/">VS code</a>  的 <a href="https://platformio.org/">platform IO</a> 代替 Energia , 其具备更好的技术支持，同时VS code 的编辑功能也更加强大，由于非常简单且可以参考Arduino学习，这里只做简单介绍，后面不在赘述，可自行学习。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405195810787.png" alt="image-20210405195810787" style="zoom:40%;">

<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405200009851.png" alt="image-20210405200009851" style="zoom:54%;">

<hr>
<h1 id="2-使用CCS开发自己的第一个单片机程序–Blink"><a href="#2-使用CCS开发自己的第一个单片机程序–Blink" class="headerlink" title="2.使用CCS开发自己的第一个单片机程序–Blink"></a>2.使用CCS开发自己的第一个单片机程序–Blink</h1><p>单片机到手第一件事情–正如一门编程语言第一件事是输出hello word – 便是点亮一个LED ( 有的 MSP430 单片机可以通过调试台输出 Hello world，G2553 不行，因为资源不足 ) 。</p>
<p>这里如果更愿意查看视频，可以选择查看视频教程：<a href="https://b23.tv/PVyOq4">新建工程</a> <a href="https://b23.tv/hHMsnp">资源搜索器</a>  <a href="https://b23.tv/AVMvt3">调试功能使用</a></p>
<h2 id="2-1学习使用CCS"><a href="#2-1学习使用CCS" class="headerlink" title="2.1学习使用CCS"></a>2.1学习使用CCS</h2><h3 id="2-1-1-新建工程与导入导出工程"><a href="#2-1-1-新建工程与导入导出工程" class="headerlink" title="2.1.1 新建工程与导入导出工程"></a>2.1.1 新建工程与导入导出工程</h3><pre><code>首先是CCS 进行安装，这个需要注意安装包路径以及安装路径以及电脑用户名（因为使用了临时目录包含用户名）不要包含中文以及其他非ASCII码值的符号。
</code></pre>
<p>打开CCS后首先选择工作空间，即放置工程的文件夹。</p>
<p>然后新建一个CCS工程。</p>
<p>不同的版本可能有不同，但是整体上都是点击顶部菜单栏-File - new -project(CCS project),或者直接选择菜单栏上的Project - new CCS project.</p>
<hr>
<p><em>如果需要导入外部工程，点击File -import -CCS project ，跳出弹窗 ：</em></p>
<ol>
<li><em>select search directory 为选择工程所在的文件夹；</em></li>
<li><em>select archive file 为选择打包的工程文件压缩包。</em></li>
</ol>
<p><em>然后选择导入，最好选择Copy Projects into workspace.</em></p>
<p><em>同样，导出选择File export  选择archive file，实际上这个就是个压缩包功能。</em></p>
<hr>
<p>新建工程的界面可以看到：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405211710941.png" alt="image-20210405211710941" style="zoom:50%;">

<ol>
<li>其中 Target 可以直接搜索所使用的单片机，这里我们使用的单片机型号是MSP430G2553，所以进行选择。</li>
<li>Connection 是连接单片机的方式，这里保持默认也就是使用板载仿真器。</li>
<li>然后命名你的工程 Project name , 推荐工程使用文件名加日期方便管理加信息（例如 <em>demo_blink_20210401_ver1</em> )</li>
<li>其他Tool-chain选择保持默认，最下面提示的<strong>Resource Explorer</strong> 将在后面介绍。</li>
<li>在最下面的模板中，可选择空工程或者基本例程，这里点击基本例程 blink the LED， 对这个例程进行讲解。</li>
</ol>
<hr>
<blockquote>
<p>补充：集成开发环境（IDE）的作用在于简化流程，这样不必使用命令行进行编译，不用使用make等工具来编辑编译参数，而是使用图形化的方式来进行配置，因此，每一个工程都有配置，一个源文件只有在工程内部才能进行正确的编译。</p>
<p>而工程的概念对于使用C语言的的初学者可能不是很明确，因为在以往的学习中通常编译单个文件较多，建议复习C语言部分或者通过其他方式加深学习C语言问题。</p>
<p>简言之，这是一个C语言的编译的问题。</p>
</blockquote>
<p>例如，右键你的工程，最下面的properties,可以看到，</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405215210503.png" alt="image-20210405215210503" style="zoom: 67%;">

<p>这里可以进行配置编译选项，这里暂时不多说。</p>
<h3 id="2-1-2使用资源浏览器（Resource-Explorer"><a href="#2-1-2使用资源浏览器（Resource-Explorer" class="headerlink" title="2.1.2使用资源浏览器（Resource Explorer )"></a>2.1.2使用资源浏览器（<strong>Resource Explorer</strong> )</h3><p>在第一章节中提到，如何从官方获取资料，针对TI 的产品，可以点击CCS 顶部菜单栏 -View -<strong>Resource Explorer</strong>  点开之后，</p>
<p>例如现在学习的是G2553, 那么直接搜索，可以看到</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405212620621.png" alt="image-20210405212620621" style="zoom:67%;">

<ol>
<li><p>首先点击 install 进行安装 MSP430Ware ,</p>
</li>
<li><p>点击MSP-EXP430G2展开，它集成包含了我们现在所用的板卡的所有资源。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405212820390.png" alt="image-20210405212820390" style="zoom:50%;"></li>
</ol>
<p>Demo中包含了一些应用例程，而Peripheral Examples（外设例程）选择MSP430G2553，可以看到Assembly –也就是汇编 ，和Register Level ( 寄存器级例程 )，也就是这里只有寄存器编程没有库函数编程。</p>
<p>下面的 xx.c 文件指示了不同外设的例程，例如需要使用IO,</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405213926925.png" alt="image-20210405213926925" style="zoom:67%;">

<p>这些文件是下载后（也就是前面的install）存在本地的，路径与CCS安装路径相同，推荐安装软件 <a href="https://www.voidtools.com/zh-cn/">everything</a> 搜索对应的文件名，可以直接点击到文件夹查看。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405214238500.png" class title="image-20210405214238500">

<h3 id="2-1-3使用调试功能（debug）"><a href="#2-1-3使用调试功能（debug）" class="headerlink" title="2.1.3使用调试功能（debug）"></a>2.1.3使用调试功能（debug）</h3><p>回到刚刚新建的例程Blink the LED。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405214618665.png" class title="image-20210405214618665">

<ul>
<li>点击菜单栏上的锤子，也就是Build进行编译。</li>
</ul>
<hr>
<p><em>简单说一下，如果没有点击编译，点击Build会首先编译程序，但是如果程序编译后修改了再点击debug，会载入上一个程序，但是有一个技巧就是，再debug中如果修改了程序，点击编译，可以勾选自动载入新的程序，这样比停在再debug更快。</em></p>
<hr>
<p>编译完成之后点击绿的虫子图标进行debug，所谓debug，在PC上进行程序debug时候可以进行单步运行或者查看变量，这里同样。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405215857561.png" class title="image-20210405215857561">

<p>点击箭头即可开始运行，关于其他图标的作用，可以鼠标挪到图标上等待出现文字提示，其中有暂停，停止，单步运行，单步跳过，单步返回。</p>
<p>在程序中可以在代码前面行号上双击<strong>添加断点</strong>。其实这些是一些基本调试方法。</p>
<ul>
<li>在调试中可以查看变量的值或者寄存器的状态。</li>
</ul>
<p>首先点击顶部菜单栏 View ，可以分别打开Expressions 、Registers</p>
<p>在Expressions  中可以查看想要的变量，手动填写或者在程序中选择要添加的变量，右键，然后：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405220511081.png" alt="image-20210405220511081" style="zoom:67%;">

<p>对于MSP430单片机，在程序中添加断点，当程序暂停才可以查看添加的变量当前的值。</p>
<p>同理，Register窗口可以查看所有寄存器的值。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405220652715.png" alt="image-20210405220652715" style="zoom:67%;">

<p>对于上述操作，可以查看<a href="https://b23.tv/AVMvt3">调试功能使用</a> 视频演示。</p>
<h2 id="2-2-开始学习第一个程序"><a href="#2-2-开始学习第一个程序" class="headerlink" title="2.2 开始学习第一个程序"></a>2.2 开始学习第一个程序</h2><p>回到例程，在2.1章节中讲到，G2553官方只提供了寄存器级别的例程，因此这里开发也会基于寄存器。</p>
<p>往往通过例程会更简单，因此这里首先查看例程进行学习。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;msp430.h&gt;</span>                    <span class="comment">//首先包含头文件      </span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * blink.c</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       WDTCTL = WDTPW | WDTHOLD;        <span class="comment">// stop watchdog timer</span></span><br><span class="line">   P1DIR |= <span class="number">0x01</span>;                    <span class="comment">// configure P1.0 as output</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> i;        <span class="comment">// volatile to prevent optimization</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">       P1OUT ^= <span class="number">0x01</span>;                <span class="comment">// toggle P1.0</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">10000</span>; i&gt;<span class="number">0</span>; i--);     <span class="comment">// delay</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 这个程序是例程Blink the LED ,回到第一章节中的原理图，可以看到在G2 launchpad上，P1.0引脚通过跳线帽连接了一个LED.</p>
<p> 因此任务目标是使P1.0循环输出高低电平。</p>
<h3 id="2-2-1-GPIO"><a href="#2-2-1-GPIO" class="headerlink" title="2.2.1 GPIO"></a>2.2.1 GPIO</h3><p> 所谓GPIO,就是通用输入输出的缩写，其作为数字IO,只能输出高电平或者低电平，由于MSP430G2553 使用3.3V供电（也可以更低）</p>
<p> ，当前输出的高电平就是3.3V.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WDTCTL = WDTPW | WDTHOLD;        <span class="comment">// stop watchdog timer</span></span><br><span class="line">P1DIR |= <span class="number">0x01</span>;                    <span class="comment">// configure P1.0 as output</span></span><br></pre></td></tr></table></figure>

<p> 在程序的主函数的开始，首先第一句要关闭看门狗，看门狗是放置单片机程序跑飞的一个外设，具体会在后面讲解，由于这里不需要这种功能，所以关闭，这里先不讨论其具体含义。</p>
<p> 然后程序写了P1DIR  &#x3D; P1DIR | 0x01;</p>
<p> 表示读取P1DIR寄存器并和0x01做或运算并写入P1DIR;</p>
<p> 这里P1DIR就是一个寄存器，包含八个bit，控制着P1整个端口8个IO的输入输出方向的配置，其每一个bit控制着一个IO</p>
<p> 回到单片机的用户指南，《<a href="https://www.ti.com.cn/cn/lit/ug/slau144j/slau144j.pdf?ts=1617611245296&ref_url=https%253A%252F%252Fwww.ti.com.cn%252Fproduct%252Fcn%252FMSP430G2553">MSP430G2553用户指南</a>》，在数字IO部分（P327)：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405221926400.png" alt="image-20210405221926400" style="zoom:50%;">

<p> 可以看到，寄存器的功能在于配置引脚的方向。</p>
<p> 在《<a href="https://www.ti.com.cn/cn/lit/ds/symlink/msp430g2553.pdf?ts=1617617669592&ref_url=https%253A%252F%252Fwww.ti.com.cn%252Fproduct%252Fcn%252FMSP430G2553%253FkeyMatch%253DMSP430G2553%2526tisearch%253Dsearch-everything%2526usecase%253DGPN">MSP430G2553datasheet</a>》中可以看到引脚结构：</p>
 <img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405222304730.png" class title="image-20210405222304730">

<p> 初学者接触可能感觉比较混乱，可以先不管上面这张图。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    P1OUT ^= <span class="number">0x01</span>;                <span class="comment">// toggle P1.0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">10000</span>; i&gt;<span class="number">0</span>; i--);     <span class="comment">// delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后这里控制了P1OUT，并与0x01做异或运算。</p>
<p> 也就是说，从P1OUT第0位到第7位，分别于0 0 0 0 0 0 0 1 做异或运算（同为0，异为1），那么，对于从第1位到第7位，值不会改变，只有最后一位随着每次运算都会翻转，这样通过一句代码完成P1.0的点亮和熄灭。</p>
<p> 下一句的10000次的循环是一个简单的延时。</p>
<p> 如果对于二进制的数值没有那么敏感，可以使用头文件包含的宏定义 BIT0-BIT7;</p>
<p> 例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    P1OUT ^= BIT0;                <span class="comment">// toggle P1.0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">10000</span>; i&gt;<span class="number">0</span>; i--);     <span class="comment">// delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在CCS中，按住Ctrl键，同时点击变量即可查看变量的定义位置，按住Ctrl点击BIT0, 可以看到其宏定义的内容：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405223334092.png" alt="image-20210405223334092" style="zoom:50%;">

<p> 顺便一提，在CCS中代码自动补全的快捷键是Alt+&#x2F;。</p>
<p> 当然这些快捷键是可以自定义的。</p>
<h3 id="2-2-2-继续点灯"><a href="#2-2-2-继续点灯" class="headerlink" title="2.2.2 继续点灯"></a>2.2.2 继续点灯</h3><p> 对于launchpad板卡，可以观察到有2个LED灯，从原理图上可以看到，这两个LED分别连接于P1.0和P1.6 , 因此下一个任务是点亮两个LED。</p>
<p> 这里应该完成练习然后查看下面答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    P1OUT ^= (BIT0|BIT6);                <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">10000</span>; i&gt;<span class="number">0</span>; i--);     <span class="comment">// delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    P1OUT ^= <span class="number">0x41</span>;                <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">10000</span>; i&gt;<span class="number">0</span>; i--);     <span class="comment">// delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 或者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    P1OUT ^= <span class="number">0x41</span>;                <span class="comment">// </span></span><br><span class="line">    __delay_cycles(<span class="number">1000000</span>);     <span class="comment">// delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里的不同在于调用了一个__delay_cycles(1000000)；</p>
<p> 这个__delay_cycles();是调用一段汇编，进行N次空操作，也就是一个延时，但是由于使用汇编语句，所以相比for或者while循环更为准确。其参数只能是一个定值。</p>
<p> 同样，程序可以写成交替点亮两个LED.</p>
<p>至此，单片机入门的第一个Hello world完成了。</p>
<p> 有了前面的基础，后面的学习将有效率。</p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>MSP430</tag>
        <tag>8051</tag>
      </tags>
  </entry>
  <entry>
    <title>长白山行简记</title>
    <url>/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/</url>
    <content><![CDATA[<p>6月拿到驾照之后，突然想出去玩玩了，然后看了下时间，准备赶在高考结束之前。很久之前就想去的长白山看看，之前网上看的攻略都感觉很模糊，于是一直没有什么动力走这个计划，因为我比较喜欢一板一眼的东西，最好是都能提取决定好的，而网上的攻略大都说不清时间地点而且大部分比较片面。这一次决定直接梭哈，简单看了一下去的方式，就订了机票准备出发。</p>
<span id="more"></span>

<hr>
<h2 id="放在前面说的流水账总结"><a href="#放在前面说的流水账总结" class="headerlink" title="放在前面说的流水账总结"></a>放在前面说的流水账总结</h2><p>流水账总结放在前面，因为不是很重要但是可以单独拿出来理清楚前后时间，后面有什么想记录的再单独强调。</p>
<h2 id="我的路线总结"><a href="#我的路线总结" class="headerlink" title="我的路线总结"></a>我的路线总结</h2><p>武汉-天津一天-长白山机场-打车到池西区集散中心住宿-睡觉-八点起床-九点半上山-下午四点回来-睡觉-五点起床-八点半大巴-寄存行李上北坡-四点半下山-延吉-睡觉-动车到长春龙嘉火车站休息，龙嘉机场飞回家。</p>
<h3 id="1-去程"><a href="#1-去程" class="headerlink" title="1. 去程"></a>1. 去程</h3><p>武汉到长白山有好几种方式，但是都没有直达。我提前四天订好了机票。带了一个背包装了冲锋衣，还有其他衣服，充电宝什么的。</p>
<p>从武汉天河机场出发，到天津滨海机场，机票为16：05-18：10，实际吃完中饭十二点多就从家里出发了，这里大约可以再压缩一个小时出来，不过意义不大。原计划是在天津住一晚上后等第二天早上十点的飞机，不过出发前两天提示次日从天津飞往白山的航班取消，遂被推迟到了第二天，中间多出来的一天就临时计划在天津玩。</p>
<p>我到达天津的时候是周一，滨海机场附近的住宿很多，由于我是下了飞机之后临时去订的宾馆，所以没有接机服务，实际上提前订好的话可以等酒店接机车。第一晚上订的是希岸酒店，对象从长沙出发的航班由于延误到了晚上两点才到达，因此第一晚就在酒店睡到中午后起来换酒店，早上起来吃了个早饭，因为在锦江app买了双早。</p>
<pre><code>ps 附近有俩希岸酒店，相隔1.2km，名字很像，点了个外卖结果送错了。。。
</code></pre>
<p>睡醒之后起来换酒店，附近有一家康铂酒店，装修时间比较新，因此直接选择了入住这一家，房件带单早饭，有接送机服务。下午入住后，躺床上点外卖，不得不说天津这边机场附近非常热闹，外卖选择很多味道也不错。另外，烧烤非常多。因为太晒了，到了晚上六点多才准备出去，不过实际上这个时间非常好。直接打车到码头，在高德地图上搜海河游船，就会指向天津站码头，我过去之后大约七点十几分，看了码头上扫码购票的小程序发现七点半的场次还有一些余票，八点场次已经空了，因此直接买票上船。天津正如宣传所说，建设围绕着河道进行，所以坐船一趟基本上大部分景点都打卡了，我觉得不是很值得去细看了。船上大约四十分钟，下船之后可以到周边逛逛，基本上热闹的地方都在河边不太远，因此基本上不用太看路。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230606_195217-01.jpeg" width="600"></div>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">天津之眼，看看就行</center> 


<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230606_200018_edited.jpg" width="600"></div>
<div align="center">古文化街，路过就算成功</div>


<p>这基本上就算逛完天津了，这些建筑比RGB强一点，起码灯光基本统一色调。<br>回去大约十一点多，在酒店前台登记了第二天的送机车，八点半出发。</p>
<p>起来之后，先吃了早饭，比之前那个酒店的早饭好一些，然后到了八点半发现，在这个时间去坐飞机就我和对象两个人，这天高考，稍微有点堵车，不过我们十点出发的飞机，过去也就一二十分钟，完全不着急。</p>
<p>然后是坐十点钟的航班从滨海机场前往长白山机场。大约11：55到达，到达之后直接出一楼就可以打车了，到西坡集散中心附近也就十几块钱的路程。</p>
<h3 id="2-长白山周边"><a href="#2-长白山周边" class="headerlink" title="2. 长白山周边"></a>2. 长白山周边</h3><p>到达长白山之后在之前预定的民宿住下，然后在集散中心周边的街道（区域）里面找个店家吃了饭。这个时候去西坡集散中心，人非常少，但是旁边的小超市还是卖的很贵。。。。然后去旁边的欧亚超市买了东西，这里是平价。然后回民宿躺着了，晚上点了个烧烤，也点了个外卖送了雨衣。便宜不过味道不咋样。</p>
<p>晚上提前在长白山小程序上买了9：00-10：00的票，西景区全票214元&#x2F;人，由于不知道怎么去集散中心坐车，所以次日起早了一点。这天天气预报上看见的是连续两天都有雨。</p>
<p>到了第二天早上七点多起来的时候确实在下雨，打了微信公众号上的西区电话问了是天池暂时关闭。然后等了一会儿等到了八点多，发现雨停了，天气逐渐放晴，然后出发，换了小包背着，走到集散中心，集散中心前面有卖雨衣和卖橡胶鞋套的，他们说现在天池刚刚已经临时开启了。我和对象买了鞋套（10元x2）（实际上没啥用），然后我有冲锋衣，对象在第一天买了雨衣。</p>
<p>然后直接走到集散中心，进门就是检票，这里虽然小程序显示有二维码识别，但是实际上必须要身份证。。。进入坐大巴，等一会儿就出发了。坐车大约四十分钟到达西景区山门，然后接着坐车到换乘中心。换乘中巴上山。到了山上停车场之后旁边有游客服务中心，这里有桌子，有租大衣和卖雨衣的，我们进去换衣服穿鞋套，然后到旁边卫生间上厕所，因为前面都是爬山路了。准备好之后山上开始下雪了。。。。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230608_094014_edited.png" width="800"></div>
<div align="center">路线图</div>

<p>然后就是爬楼梯了，1400多阶楼梯，但是不陡，正常走很容易，走到一半听见有人说上面啥都看不清，不过还是决定接着上去。接近山顶的时候雪非常大，到处都是雾，整条裤子都打湿了—-是的，冲锋衣没事儿，融化的雪全流到裤子上了，手机冻关机了只好一直插着充电宝。</p>
<p>到了山顶有一个观景台，由于天气不好加上淡季，人不多，基本上可以随便拍照，但是大雪大雾只能看见一个坑，过一会儿什么也看不见了。上面有个工作人员的小屋，虽然他们不让进去但是太冷了进去一下也没事儿。。。。等了一会儿工作人员说你们在这里等着划不来不如下面去看大峡谷—-这里划重点，不能信，后面会说。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230608_122203.jpg" width="600"></div>
<div align="center">下雪的时候只能看见一个坑</div>

<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230608_122155.jpg" width="600"></div>
<div align="center">本来只想留念</div>

<p>雪大风大，在界碑旁边拍了照就准备下山了，但是下山的时候大约下到下面一个平台的时候我看到山谷里面雾逐渐被风吹散，可以比较清楚看到对面，然后我觉得爬回去，对象觉得太冷了就下山坐车回家了。然后我就背着包转身跑上山。这时候跑上山稍微有点累，不过主要是因为两年没锻炼了，实际上这时候人很少跑起来没有任何阻碍。</p>
<p>果然上山之后看到了天池的雾已经被吹散了，然后在这里拍照等到雾再起来就下去了。另外，山顶信号不好，我的miui相机全景组件没有下载。。。其实在下面一个平台就有信号了，但是我不想再跑一趟了。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230608_130155edit_edited.jpg" width="900"></div>
<div align="center">西坡天池</div>

<p>西坡是可以看到全部天池的，就是距离比较远。</p>
<p>然后下山，下山的时候雨不大，一路跑下去的（第一次下山的时候一步一步挪下去的），到了停车场可以坐中巴到换乘中心，换乘中心可以选择换大巴回集散中心或者去大峡谷。我去了大峡谷。</p>
<p>坐车到了大峡谷候车场，直接按照路牌进去，全程1.8km的栈道，进去之后发现栈道离大峡谷太远实际上拍不出来什么，需要长焦，看到的东西也不全都被树挡住了，所以这个1.8km我差不多一路跑出来的。。。大约花费三十分钟。如果听信了前面工作人员的话直接来看大峡谷怕是会吐血。这个景点基本上算是送的，用来散步锻炼身体。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230608_150011edit_edited.png" width="700"></div>
<div align="center">大峡谷其实看不到什么</div>


<p>然后从栈道出来回到起点也就是候车场，坐大巴回家。</p>
<p>回去之后休整一下，把衣服晾着，鞋吹干，然后点外卖睡觉。这时候还是没搞清楚第二天怎么去北坡，看到一个公众号的图片写着有直达景区车七点从随心酒店出发，第一站7：05到集散中心，然后就六点多起床，六点四十多到了集散中心，旁边的商户告诉说这里没有车，要到前面欧亚的地方坐车，到了之后发现这里的景区车是到长春的，没有到西坡的，遂打电话问，发现到西坡的景区车只能再随心酒店上车中间不停，随心酒店距离这里大约2km，再过去来不及了，不过停车场这里有大巴车，发车时间8：30，正好这班车的司机路过问到我们去哪里，我们说了之后招呼我们先把包放到车上我们出去逛逛，这时候是七点。</p>
<p>这时候这边街的商户都没开门，欧亚超市也是九点开门，，，，于是打车到附近的松江河镇去吃早饭。距离3.6km左右，预计8：00准备打车回来。在镇上买了车厘子西瓜桃子之后去吃了饺子，饺子煮熟要十几分钟，所以直接装袋子打车回来了。</p>
<p>上了大巴车，总共只有五个乘客，司机直接问了我们去哪里，中间就不用停车了，车费是17元&#x2F;人，我们坐在第一排，体验非常好，大巴是电车，非常平稳。总共是95km左右，不到100km的路程，地图上报的时间是1小时50分钟左右，实际上从出发到下车只花费了1小时28分钟。</p>
<p>到了北坡集散中心就下车了，稍微走一点进去，然后旁边有个租大衣的棚子可以寄存行李，一个箱子10元（实际上店主忙着租大衣压根没时间看我们。。。），进去直接放屋子旁边就好了，也没有专门的寄存处。。。店主说拍照，回来凭照片取。然后就去进门了。</p>
<p>到达的时候十点，正好赶上了一个旅行团，然后排队总共几十分钟。。。真的是恰好，因为后面就没有人排队了，直接现场买票10：00-11：00的票，选全票即可，会自动识别已经在西坡买了门票会自动扣减门票，检票入门等大巴。到了换乘点之后，上天池的小巴车要单独检票，也就是单独在小程序上买80元&#x2F;人的票。。。实际上北区总价比西区是更贵的。然后直接坐小巴上盘山公路直接到达山顶，路上景色也不错，车窗玻璃很干净：</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230609_120228_edited.png" width="500"></div>
<div align="center">换乘上天池主峰</div>

<p>不知道为啥北坡的雪特别白。</p>
<p>当天天气晴朗，可以绕着天池旁边的道多个角度拍照，不过人也比较多。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230609_123918edit_edited.png" width="900"></div>
<div align="center">北坡天池</div>

<p>拍照之后就准备下山了，下山之后，换乘的大巴是去往大瀑布的，到了大瀑布需要走一段楼梯才能看到，这一段路比较累，前面有个平台区，有不少卖吃的，有个温泉鸡蛋，10元&#x2F;三个，和山下的煮鸡蛋一个价格所以就买来尝尝了。进去之后这里有温泉有小溪，可以拍照。</p>
<p>走过去之后有个平台，大瀑布非常远。。。。。。非常需要一个长焦激情地摄影，手机广角拍照很难出图。。。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230609_142003edit_edited.jpg" width="800"></div>
<div align="center">米法公园（</div>

<p>然后就是回程了。回程的景点是直接乘坐大巴，依次是小天池、绿水渊潭、地下森林。虽然每个站都会停，但是都相隔非常近，坐车屁股还没坐热就要下车了，所以我没去小天池。</p>
<p>直接放照片。</p>
<p>【绿水潭图】</p>
<p>地下森林实际上就是在山脚的一条森林中的1.6km的栈道，来回3.2km，我没走完因为看看就差不多了，和地下没什么关系。</p>
<p>【地下森林图】</p>
<p>总结就是这几个景点也是送的锻炼身体的，尤其是大瀑布，栏杆距离瀑布非常远。</p>
<h3 id="3-回程"><a href="#3-回程" class="headerlink" title="3. 回程"></a>3. 回程</h3><p>最后换乘大巴回集散中心拿寄存，直接进去拿就好了。。。</p>
<p>然后听到路边有人喊延吉的车，就拼车去了延吉，80元&#x2F;人，四点多下山，等到了六点半出发，中间吃了个铁锅炖，是司机推荐的也不知道是不是他们认识，价格还行200一锅，分量很足根本不是两个人的量。。。吃不下，因为味道不咋样。。。，到延吉才发现延吉消费水平真高，大家似乎放假都往延吉跑，这里的丽枫酒店500元&#x2F;晚，这还是个普通周五。。。</p>
<p>离延边大学很近，直接走过去看了看。</p>
<p>第二天就去延吉西站坐高铁去了长春，在长春机场附近的七天酒店休息了一晚上早上四点半起来坐五点的送机车去机场做了七点的飞机准备回家。</p>
<h1 id="真正的总结"><a href="#真正的总结" class="headerlink" title="真正的总结"></a>真正的总结</h1><h2 id="地名问题："><a href="#地名问题：" class="headerlink" title="地名问题："></a>地名问题：</h2><p>这个问题真的纠结了我好久。好多攻略只去了池北，他们说的地名都模糊不清，实际上是因为后来地名有些更改。</p>
<p>池北区：也就是二道白河镇，实际上就是在一起。</p>
<p>白河客运站：也就是池北区客运站，现在就叫池北区客运站，搜地图上是搜不到的。池西区没有客运站只有直达车的停车场。</p>
<p>池西区：单独开发的地方，离附近的松江河镇3km多。（还有不少烂尾楼）</p>
<h2 id="行程注意事项"><a href="#行程注意事项" class="headerlink" title="行程注意事项"></a>行程注意事项</h2><p>这些都是淡季旅游（且是工作日）可行的，其他时候可能没有这么多临时选择。</p>
<p>1、去程方法，方法有很多，但是我选择飞机是因为机场离池西区集散中心非常近。实际上，西区的票最晚一场是12:00-12:30,所以理论上来说极限压缩时间是可以当天上西坡的，如果天气好，一下午就可以结束了，不过我没有注意西区集散中心寄存行李在哪里。</p>
<p>2、天气问题，提前看了很久，实际上根本看不准，我在当天晴天的情况下天气预报依然是山上有雨，实际上全程只下了一会儿小雨，包括当天上西坡，天气看起来非常不好，但是就晴了一会儿就开放了可以上山。</p>
<p>3、游玩顺序：如果从机场走，显然西坡更近，回去的时候则在北坡离客运站更近，也比较热闹。回程选择比较多。个人比较推荐这个路线，唯一的问题是，第一天上西坡比较累，要爬楼梯，最好提前锻炼身体。</p>
<p>4、坐车通勤：从西坡到北坡和从北坡到西坡都有大巴车，西坡早上发车时间是8：30和10：00，下午忘了。。。好像但是从西坡下坡后也不一定要坐大巴，下坡一般在集散中心附近有人喊拼车，50元&#x2F;人，可以考虑，不过个人觉得西坡由于人少住宿比较便宜，大巴车也更便宜，所以可能住一晚上更好也不耽误时间。西坡的停车场在欧亚超市旁边，地图上就能看到。</p>
<p>5、住宿，西坡集散中心附近有很多宾馆，我去的时候都是显示100元&#x2F;晚左右的价格，所以实际上没有必要提前订，尤其是不要相信美团，加价杀熟比较严重。北坡也就是池北区，开发比较好，因此酒店选择比较多，有不少连锁酒店，比如锦江华住会的酒店，不过也贵一些，自己选择了。至于很多人说的万达度假区，如果是冲着长白山去的，没必要去那里，离哪边都远。</p>
<p>有些攻略会推荐到山门下面住宿，会更近一些，回程的时候大巴会问有没有要途中下车的去中途住宿处的，过去不了解怎么上车。不过实际上没有必要，尤其是如果两个坡都去的话集散中心通勤更方便，反正坐车那会儿等着就行。</p>
<h2 id="有用总结"><a href="#有用总结" class="headerlink" title="有用总结"></a>有用总结</h2><p>1、网红城市酒店贵，不分节假日；再强调一次，不要相信美团，看看信息就好了。</p>
<p>2、工作日游玩看看景区票余量就可以知道人流量，基本上余票大把大把可以认为不用提前订票，对于行程安排有很大帮助，省钱的同时选择比较大。</p>
<p>3、路上不要听别人说，我对象下山的时候说山上什么也看不见，把别人去了三次长白山都没看到天池的人劝回去了。见天池多少要点缘分，但是头铁一样能看到。</p>
<p>4、想拍风景如果是广阔天地而且没啥人，广角还是不错，但是如果有人而且有遮挡，长焦才是真神，带上脚架自己合成吧。拍风景还是要带相机。</p>
<p>5、爬山要做好衣服打湿的准备，这次只带了一条裤子过去，结果没想到在北方洗衣机甩干之后晾一晚上裤子也干不了，最后穿了对象的裤子。鞋子是用吹风机吹干的。</p>
]]></content>
      <categories>
        <category>生活游玩</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>关于音响想到的一些杂谈</title>
    <url>/2023/06/20/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E5%85%B3%E4%BA%8E%E9%9F%B3%E5%93%8D%E4%B8%80%E4%BA%9B%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>我不是一个什么特别有主见的人，所以对于铺天盖地而来的观点往往会首先逼迫自己认同，然后慢慢考虑到底发生了什么。所以，对于音响的营销，我是完全没有抵抗力的，唯一阻碍我购物的就是我的钱包（以及我的购买习惯）。</p>
<p>小时候课文（《长城砖》.人教版.四年级.上，旧版）上都说宇航员在太空能看到长城，这是非常骄傲的，我就寻思这长城虽然长但是他不宽啊，我也没有去过长城，最直观的了解是一本思想品德书（人教版.七年级.上，旧版）的封面是可以看到长城的，但是我百思不得其解，图中似乎宽度也只能看到五六个人并排，然后我就更难受了，这是为什么呢。有一天做梦，梦见，原来长城的城墙特别厚，虽然在图上只能看见城墙之间只能容纳五六个人宽，实际上旁边城墙还有好几米咧，难怪太空能看见。</p>
<div align="center"><img src="/2023/06/20/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E5%85%B3%E4%BA%8E%E9%9F%B3%E5%93%8D%E4%B8%80%E4%BA%9B%E6%9D%82%E8%B0%88/coverbig.jpg" width="180"></div>
    我一直以为这本思想品德书是小学的，没想到是初一的教材，我没想到我会纠结这个问题纠结三年，我反复去确认了小学的思想品德的封面插画都是漫画而不是照片才能确定，同时也高估了我小学时期的认知能力，见识少能想到长城没有很宽也挺不错了（摆手。

<p>在梦中了悟得了这么个解释，似乎一切就合理起来了，犹如醍醐灌顶般，吃饭香了，睡觉也安稳了，从此不再纠结这个问题。</p>
<p>然后到了互联网时代，可能是2018年前后？（太惨了蒙在鼓里这么多年,虽然后面主要是没有心思去追究了），有人发文指出小学课文的错误，我一下子回想起来当时我考虑过的问题，淦！还是吃了没见识的亏。</p>
<pre><code>真正去回想时间线才发现，自己的认知水平到了大学才大幅提高。就像阳关灿烂的日子中的马小军，他的记忆是主观拼凑的，我的记忆也都是随便压缩时间的，一直以为自己以前见识也不少，现在才发现有时间获取信息了才有自己的想法。小时候可能时间最丰富的时期是初中三年，不过当时班主任不允许看闲书和新闻，只能偷偷带些儿童文学青年文摘一类书籍传阅。
</code></pre>
<p>瞎掰扯扯远了，这和音响有什么关系呢？我想说的是，我是不是那个会被最容易获取到的数据推着走的人。</p>
<p>最早接触听音设备应该是当时爸爸在我六年级的时候两千块钱配的AMD速龙CPU的台式机送的音响，这对音响我在高中还用过。其后接触专用听音设备应该是初中的时候借用同学的一个带有一个2inch电阻屏的纽曼mp3，连歌曲也是白嫖的，然后是后来有一个酷派手机，用着手机送的耳机，当时还是酷狗的时代，音乐也没有版权概念，都可以随便下载，再后来借由想要听歌线下买了一个纽曼的MP3，为什么还是纽曼呢，因为我只认识这一个牌子，觉得还不错。99元，记不起来型号了，不过我发现那个和飞利浦SA2208长得非常像。。。它声称是入门HiFi，这可能是我第一次见识到HiFi这个词。</p>
<p>在这个MP3上，我开始下载歌曲，我了解了有不同的格式，mp3，ape，flac，wav，由于在音乐软件上对于无损格式会专门标注出来，所以逐渐的我下载的歌曲从mp3变成了flac以及ape格式，为什么没有wav呢，这个后面解释。我相信，这个有着特殊标记的歌曲一定会听起来更能传达作曲者的意思，从此开始逐渐替换mp3格式的歌曲从各路音乐网站收集无损格式的歌曲。</p>
<p>但是我当时发现一个问题，这个标着HiFi的mp3，似乎听起来没有手机上放的好听。<br>“也许这是真正的声音？但是这么便宜也不至于真特别好吧，可是它说了它是HiFi诶”<br>到了高中，班级流行着买一个mp3听英语听力，也偷偷听听歌还有听听广播，但是校外的小卖店会进什么样的货呢，就是那种拼多多上十块钱包邮的类型，可能有贵一点有一个屏幕，总而言之，不会带有HiFi标志。这种通常杂音较大（信噪比不足），让我相信我的MP3是足够HiFi的。这时候当然就有人想要追求更好的设备了，但是不是我，因为我没有钱。一日一同学氪金500大洋买了一个看起来很牛比的学林xxx, 不记得型号–虽然我们当时感觉似乎索尼更好，但是五百大洋只能买到二手索尼– 我试听了一下，嗨，感觉和手机没有区别啊，我寻思，也许是下载的歌曲不够好。</p>
<blockquote>
<p>什么，你说耳机？十元包邮的耳机，我不知道耳机为啥贵啊，我自然买便宜的。</p>
</blockquote>
<p>又扯远了，本来是想说音响的，但是说着说着说到耳机上了。现在回到音响上。</p>
<p>初中的时候还有用过的就是妈妈的运动音响，骑车的时候放车上，声音特别大，我特别喜欢，说实在我记不起来到底感觉好不好听了，因为骑车确实很累。后来，电脑旁边添置了一组漫步者R101V，我的感受是，我去，原来的音响是什么垃圾，这个新音响这低音，这清晰度，简直了打开了新世界。原来音响也可以接近耳机的效果。<br>很长一段时间内，我看到低音足的标语我就觉得，这个耳机或者喇叭非常好。</p>
<p>而高音部分呢，实际上我不在乎，都是动次打次怎么会在乎，去看高音部分的资料是我在制作等离子扬声器的时候，大家都说他的特点是高音好，这时候我才去看看高音部分有什么音响。当时我认为我做的等离子扬声器非常好，可能是因为自己亲手制作的，有不少主观滤镜在里面，幸好保留了视频让我可以重新审视。</p>
<p>这里又扯到DIY上了，哦正是这些DIY让我瞎填志愿专业的时候把电子信息这个专业放到了第一位。</p>
<p>再后来，我觉得我可以自己做音响了，大概是高二的时候吧，看了贴吧别人用三合板加TDA2030的功放，我买了手锯，但是拿来的木板是实木，不知道是什么树，非常难锯，最后在开孔上放弃了，那时候我才意识到，我需要趁手的工具。但是看书的时候，我的认知是，做一个箱子装上喇叭就好了。不过，由于实施难度太高，我直接放弃了，一个多年的大坑至今没有填。</p>
<p>最后高考结束了，我寻思首先我要买个耳机，还要降噪耳机，无奈囊中羞涩，挑选来挑选去最后选中了亚马逊洋垃圾，90元送一盒小米彩虹电池。当时降噪耳机没有太多选择，基本上就是bose和sony之间选择，四位数的价格当时对于我来说想都不敢想。<br>买来之后，戴上这个头戴式耳机，我发现听觉的世界清晰多了，尤其是打开降噪开关，噪声降低的同时，耳机中的声音也清晰了不少，层次分明。</p>
<p>这个耳机随着我到了大学。当时还有一个一直想买的耳机，就是圈铁耳机，据说它分开处理高频和低频，感觉应该会更加HiFi。但是这类产品都很贵，当时没有低价的选择，最后我试了试同学的唐麦F3, 我发现这又是入耳式的全新体验，遂买了F1，发现听感不一样，然后还是买了同款F3，这个耳机陪伴我到了大二，是我当时最贵的一手耳机，我觉得这就是说明，提升几十块钱就有这么大提升了，不过可惜这个耳机再一次去硬件部之后不见了，这时候小米圈铁pro降价了，一百一十就可以买到，我就买了一条，这个耳机现在还在用，当时对这款耳机的批评很多，主要是说齿音，我很不理解，齿音究竟是什么，简直如同行业内的黑话，我听起来很好啊。</p>
<pre><code>后来才知道，小米的品控不怎么样，可能买三条，每条听起来都不一样。其中就有高音过重的类型的。
</code></pre>
<p>同期购买的还有一款号称HiFi性价比入门的耳机，造型很不错，听起来似乎也就高频比小米圈铁pro弱一点。</p>
<p>但是，似乎可以通过音效调节来解决这个问题，当时有一个插件叫做蝰蛇，基本能很好解决这个问题。我这时候开始考虑，那么，能软件调整的话，这些细微的区别影响大吗。</p>
<p>不能老说耳机了，还是回到音响。<br>尽管我已经买了好几条耳机了，总算认识到太便宜的耳机确实不想，但是我还是对音箱有好奇之心，大家都说音响的效果是耳机不能比拟的，在大一的生日，胁迫室友送了我一对我在淘宝上看中的迷宫音响，99元没有功放。然后自己买了一个功放，使用D类功放芯片。<br>买来之后的第一想法是，这个产品真的不错，这个价格就有这么好的效果，就是低音有点闷，怎么办呢，想到了之前高中准备做音响时候买的高音单元，直接按照淘宝评论区所说添加一个4.7uf电容串联扬声器后并联到原来的音响上，这时候再一次体验到世界清晰的感觉。<br>这时候我在想，这是真的HiFi吗，还是只是我自己听着舒服？</p>
<p>HiFi这个概念是不是并不是如其名，高保真，而是让人听起来更好？</p>
<p>一个小转折是到了大二的暑假，电赛培训做了一个麦克风放大器，测试的时候使用手机播放音频，测试不同的频率，当时播放到17khz的时候我已经听不见声音了，这时候我同学说，听得见，我愣住了，联想到初中物理中降噪的三个途径，我就明白了，我这是接收端出了问题。<br>每个人的体验都不一样，高保真真的能保证每个人的体验吗。</p>
<p>说到电赛，那就必须要说信号了，我的专业多少要和电信号打交道，我理解的高保真也就是更低的失真，但是如果说保证低失真，似乎是仪器就能测试的，为什么那么多厂家能说那么多结果出来还有不同的音频曲线呢，这个曲线如果不是平直的是不是说明这不是高保真的放送呢。我对声学一窍不通，对主观声学更是不理解，不理解人耳对声音的主观评估。</p>
<p>那么更换线材有用吗，有多大用处呢？</p>
<p>说来惭愧，虽然我自己是电子的学生，但是在早期我对这些玄学深信有疑，但是我有疑有很大一部分来源于我没有钱购买而不是因为我有什么知识储备。但是我又有些叛逆，我故意用着最普通的线材来连接，来证明我最叛逆的想法是正确的，但是我不确定。</p>
<p>不过，总而言之，大学时期室友赠送的音响陪过我过了整个大学期间，小米圈铁pro也没有换过，顶多是添置了蓝牙耳机，在蓝牙耳机使用SBC还是AAC抑或是AptX中间纠结对音质的影响，它们都让我感觉良好，我也逐渐能认识到这个玄学怪圈一部分来自于商家的营销，但是我还是止不住相信我总能通过微操获得更高的听音体验。</p>
<p>大学毕业之后，拿到工资的时候，我开始想我要买什么我之前想买的东西。首先我买了一个开放式头戴式耳机，飞利浦x1s，二手，常年的购物习惯还是让我不舍得花费太多钱购买一个不知道效果如何的东西。好在实际体验还不错，开放式耳机确实有其他耳机没有的优点。<br>然后我开始琢磨音响了，毕竟有了自己的房间和一个比较大的台面。挑选了好久，在各类营销文章里面反复选择，最后我选择了一个看起来比较好看的惠威x3，没错，我就是这么想的，同时也考虑了惠威也出了一些不错的产品，当时购买全新需要1800左右，最后我在闲鱼上购买了二手。</p>
<p>这时候又有新的概念了，监听，所谓监听就是要还原音乐的音色，我又想到了之前并非HiFi的HiFi这个词语。</p>
<p>到手之后，发现音响除了使用铸铁箱体，似乎没有什么特别的设计，连接好之后开始试听，哎，怎么回事儿，听起来和我大学区别不大啊，可是我价格加了个0啊。</p>
<pre><code>这时候会有人蹦出来说，你的驱动不够，你要独立解码。不好意思，解码和DAC我都写过文章了，这里总算不用再在这里继续添加废话了。
</code></pre>
<p>感觉两千有一大半用在这个铸铁箱体上。</p>
<pre><code>我一直习惯于按照BOM成本来衡量购买的商品，我知道要设计，但是积累了这么多年，也没听说国内谁有自己的comsol或者是ansys。
当然了，最开始我确实不知道设计音响是什么概念，以为就是加个箱子就好了。这也是后来累积了设计经验才反应过来这些东西是可以仿真的。
</code></pre>
<p>要是说以前做功放还免不了调试和不错的分立元件设计能力（也可能是抄袭日本的能力），现在大约都是面向FAE的设计了，我当时就觉得我是大冤种。</p>
<p>这时候我开始认真审视自己记忆中杂糅的概念了，正确的量化和理论应该认真考虑而不是凭着以前学来的二手知识和营销文章来感觉。</p>
<pre><code>前面说了为什么最开始我没下wav，因为没有人吹这个啊，这个概念很好理解，flac和ape都是无损算法，为什么要费更大的空间来储存同样无损的wav文件呢，但是有这么一段时间，我隐约相信，wav格式能获得更好的音质，因为虾米给了它金标。
</code></pre>
<p>不过，总体来说，也没有明显的缺点，也就这么用下去了。</p>
<p>下一个转折点正如第一次发现听力不同于人一样，是我自己制作设备的时候发现的问题。在使用4.5V电源给TL072供电的时候，用于混音器提供给耳机，当我接上示波器测试动态范围的时候，我发现，当波形出现明显上下截止失真的时候，我听不出来区别。</p>
<blockquote>
<p>实际上人耳能分辨的THD大约在2%左右，对于动辄0.1%甚至更低的现代芯片来说，这个值已经非常高了。</p>
</blockquote>
<p>另外说一句，测试这些，首先你得有个示波器。<br>这时候，我开始删除电脑上的wav格式的文件了。</p>
<p>买了没有多久，漫步者出了一款设备，也叫做监听音响，我一直考虑我已经有设备了，不要再想有的没的了，一直拖到现在（两年后），我考虑卖掉惠威x3似乎还能回收几百块钱，于是领券下单一气呵成，350元，基本四分之一于惠威的价格。</p>
<p>买来后第一反应是，真大，做工真廉价，果然是用最普通的物料来做到能发挥的最佳效果。测试后的反应是，薄纱惠威x3. </p>
<pre><code>一开始是能听出来有那些地方不足的，不过习惯了之后就不明显了，这大概就是煲耳朵吧。
人脑确实是适应能力很强的，我记得我配这副眼镜的时候，我能明显发现透过眼镜存在边缘畸变，物体看起来不是直的，看起来非常晕，但是一段时间后就适应了。
</code></pre>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>这篇文章通篇没有分段，因为想到的太多了害怕搞忘记了。<br>本来我只是想写一下新买的MR4薄纱惠威x3，但是一写开头就离题万里，就想到了《禅与摩托车维修艺术》这本书通篇在疯狂insert自己的想法。</p>
]]></content>
      <categories>
        <category>生活游玩</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
