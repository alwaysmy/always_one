<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人博客文章的管理</title>
    <url>/2023/02/01/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/0%E3%80%81%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>这篇是一篇随记，其实很简单：</p>
<p><strong>用OBSIDIAN来管理博客的文章就好了</strong>。</p>
<span id="more"></span>
<p>起因是用了obsidian之后就懒得写博客了，加上Typeroa收费，新的markdown编辑器不太好用，至少没有之前那么好用，因此就转移笔记到了obsidian。本来是打算ob编辑结束之后转移回来，但是发现同步这个太痛苦了，突然想到直接在博客源文件这里建立一个ob的库就好了，这样实际上还可以分开管理一些想要发布的东西。</p>
<p>另外，文件夹不影响文章的识别，因此可以在<code>_post</code>文件夹下面用文件夹分类，这个逻辑和obsidian是一样的。</p>
<p>缺点是，另外一个ob库同步到了手机，可以很方便随处编辑，这个库再同步过去感觉多少有点别扭，当然也不是不行，只是感觉手机上的文件很乱不想继续往里面塞东西。</p>
<h1 id="多个公开平台同步"><a href="#多个公开平台同步" class="headerlink" title="多个公开平台同步"></a>多个公开平台同步</h1><p>还没想好除了复制粘贴还有啥方法。<br>知乎可以直接上传mardown文档，但是图片要重新上传，而且那个图片上传对于批量很不友好。<br>CSDN真的不行。<br>b站更是啥都没有。。markdown都不能识别。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>静态博客的搭建</title>
    <url>/2023/03/13/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/1%E3%80%81%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>出于方便的目的，加上可以维护自己的MD文档，这里当然是首先选择一个框架来构建自己的博客。</p>
<span id="more"></span>
<h2 id="博客框架的选择"><a href="#博客框架的选择" class="headerlink" title="博客框架的选择"></a>博客框架的选择</h2><p>框架有<strong>Hexo、WordPress、VuePress、Hugo、Solo、Halo 、Jekyll</strong>,<br>但是Gitee pages 支持的服务有Jekyll、Hugo、Hexo。（或者github的）<br>其中Hexo使用比较多，教程也比较多，据说基于Go的Hugo的构建速度比较快，不过目前教程不多，因此这里还是选择了基于node.js的hexo。</p>
<h2 id="Hexo框架的初始化"><a href="#Hexo框架的初始化" class="headerlink" title="Hexo框架的初始化"></a>Hexo框架的初始化</h2><h3 id="1、安装node-js"><a href="#1、安装node-js" class="headerlink" title="1、安装node.js"></a>1、安装node.js</h3><p>Windows 直接用安装包安装就行，选LTS版本,里面的npm工具要安装上。<br>linux下 就比较简单，直接install nodejs和install npm.</p>
<h3 id="2、安装hexo"><a href="#2、安装hexo" class="headerlink" title="2、安装hexo"></a>2、安装hexo</h3><p>在需要存放自己博客文件的文件夹下面打开命令行(not powershell,可以安装但是不能执行)，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>然后试试执行命令<code>hexo -v</code>看看安装成功没有（Windows需要在cmd下执行，powershell不行）。</p>
<p>然后初始化hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>也可以新建一个文件夹的方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br><span class="line"><span class="built_in">cd</span> myblog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>这时候这个文件夹下面有：</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
<li><strong>_config.yml: 博客的配置文件</strong></li>
</ul>
<p>测试一下功能正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>然后点开生成的本地服务 localhost:4000可以看到一个自带的页面。</p>
<h3 id="3-连接Github仓库"><a href="#3-连接Github仓库" class="headerlink" title="3 连接Github仓库"></a>3 连接Github仓库</h3><p>新建一个仓库名为   用户名.github.io  ，这样pages的根目录就是这个仓库名，否则是 用户名.github.io&#x2F;仓库名，也不是不能用但是一来不好看，而来后面还要加配置。<br>如果使用Gitee,这里需要新建一个名为用户名的仓库，达到和Github 一样的效果。</p>
<p>然后就是配置Git的那一套，用户名，SSH,这都是全局配置，配过了就不用再配置了。见[[GIT的初始使用方法]]。</p>
<p>在博客文件夹下有配置文件，里面包含了deploy这个项目<br>在文件内文本配置自己的仓库链接：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># repo: https://gitee.com/always_one/always_one.git</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:alwaysmy/alwaysmy.github.io.git</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 注意了，这里GitHub不要使用https链接了，现在不支持，gitee倒是没注意过，要用git链接。<br> 同时<br> 还有配置博客对应的根目录</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="string">url:</span> <span class="string">https://alwaysmy.github.io</span></span><br><span class="line"></span><br><span class="line"><span class="string">root:</span> <span class="string">/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 安装deploy-git，通过hexo命令来部署到Github.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后再hexo所在的文件夹下面执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean&amp;&amp; hexo g&amp;&amp;hexo d</span><br></pre></td></tr></table></figure>

<p>分别是清空，生成和部署。有时候直接生成部署就行，如果修改了Hexo主题相关的东西需要清空。</p>
<p>这时候你直接在生成的.deploy_git文件夹内使用git push当然也可以，但是那样搞复杂了。</p>
<h2 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h2><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>主题的配置需要在主题下对应主题内的_config.yml下修改<br>更换hexo NEXT的主题配置之后必须要先hexo clean才能生成对应的主题</p>
<h3 id="图片的URL问题"><a href="#图片的URL问题" class="headerlink" title="图片的URL问题"></a>图片的URL问题</h3><p>前面已经配置好了,所以我不记得了,下面说点小问题.<br>如果图片在本地预览正确,但是hexo生成的带了绝对路径,那么大概是图片的路径前面多了个&#x2F;,虽然在(Windows)本地&#x2F;不影响这个图片的路径的查找,但是hexo为图片不会生成一个带日期的路径,</p>
<ol>
<li><p>安装插件 asset-image 但是这个插件好像需要一点修改</p>
</li>
<li><p>npm install <a href="https://github.com/CodeFalling/hexo-asset-image">https://github.com/CodeFalling/hexo-asset-image</a></p>
</li>
<li><p>设置图片为相对路径</p>
</li>
<li><p>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s 运行查看<br>hexo配置需要启用post_asset_folder: true<br>关闭动画<br><strong>motion</strong> 修改为false</p>
<h1 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h1><h2 id="评论区如何解决"><a href="#评论区如何解决" class="headerlink" title="评论区如何解决"></a>评论区如何解决</h2><p>博客有评论的功能是最好不过的,不能老让人家发邮件,也不方便整理.</p>
<h2 id="迁移博客到别的平台"><a href="#迁移博客到别的平台" class="headerlink" title="迁移博客到别的平台"></a>迁移博客到别的平台</h2><p>这里需要从gitee迁移到github.<br>首先可以在github中<a href="https://github.com/new/import">Import a Repository (github.com)</a>  复制原来仓库链接进行迁移.<br>修改.deploy_git 下.git中的config文件内包含的远程仓库的地址.或者用命令修改.</p>
</li>
</ol>
<p>本地重新安装node后安装npm,然后这里是hexo博客,就</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后这里不需要hexo init了,直接在原来的博客文件夹下,我这里是myweb,hexo s测试一下结果.<br>使用hexo n “博客标题”来创建博客文章</p>
<p>github相比gitee的pages,仓库名需要alwaysmy.github.io加上后面的github.io才行</p>
<p>修改hexo中_config.yml下的url为github page给出的url,仓库改成git协议的仓库</p>
<p>文章中开头的描述后面需要有空格</p>
<h1 id="添加附加信息"><a href="#添加附加信息" class="headerlink" title="添加附加信息"></a>添加附加信息</h1><h2 id="添加github和邮箱"><a href="#添加github和邮箱" class="headerlink" title="添加github和邮箱"></a>添加github和邮箱</h2><p>打开 <code>~\themes\next\_config.yml</code> 文件，找到 <code>social</code> 相关的设置，取消掉需要的菜单项的注释。</p>
<p>打赏<br>reward:</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>博客写文提纲</title>
    <url>/2023/06/20/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/%E5%8D%9A%E5%AE%A2%E5%86%99%E6%96%87%E6%8F%90%E7%BA%B2/</url>
    <content><![CDATA[<p>1、这里是第一段。不要写标题，因为要留着当作前言，并放在主页预览，写了标题就不好看了。。。</p>
<span id="more"></span>

<p>2、上面添加一个阅读更多的折叠。</p>
<p>3、参考链接可以放在最前面，如果很可能是为了提示自己。</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>一级标题不要和文章标题重合。</p>
<p>5、正文内容</p>
<p>后面的就根据正文随意发挥了</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客发布插入图片的几种方法</title>
    <url>/2023/02/11/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E5%8F%91%E5%B8%83%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>这里说的情况都是markdown的文件。</p>
<span id="more"></span>
<p><strong>1、图床外链</strong><br>这需要上传图片，多少有些不方便，还取决于图床稳定。<br><strong>2、上传图片到仓库</strong><br>能解决自建博客的问题，但是复制到别的平台发布的时候有些不方便，不能自动上传图片。不过可以通过<br>复制博客可以obsidian的复制自动转成markdown功能，再发布到别的平台上。<br><strong>3、图片转base64直接嵌入md文档</strong><br>这个图片会跟着文件走，基本上是最稳妥的方式，但是在本地端不太好保存回去成图片。（快捷方法？）而且由于里面字符太多，搜索英文的时候会有很多误判断的结果。<br>可以使用小米笔记编辑博客文档，图片会自动转成base64。<br><strong>4、<a href="../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/OneNote%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/OneNote%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87.md">OneNote复制图片</a></strong><br>OneNote用Ctrl+C复制图片粘贴到Obsidian里面的时候会附带图片的Base64和图片的OCR文字内容</p>
<h1 id="具体语法"><a href="#具体语法" class="headerlink" title="具体语法"></a>具体语法</h1><p>1 最常见的markdown语法<br>2 HTML</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;双路混音器制作记录/image-20211113034220481.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image-20211113034220481&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom: 67%;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./长白山行简记/IMG_20230606_195217-01.jpeg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;600&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="部署之后的显示"><a href="#部署之后的显示" class="headerlink" title="部署之后的显示"></a>部署之后的显示</h1><p>Hexo默认的图片显示方法和md语法不兼容。。。<br>1、如果使用默认md语法：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">{% asset_img "span>" "<span class="string">name</span>" %}</span><br></pre></td></tr></table></figure>
<p>这时候渲染就会出问题。</p>
<p>网上说法很多，我分不太清，实测有效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-image-link --save</span><br><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p>然后打开hexo config中的：<br><code>post_asset_folder: true #是否启用资源文件夹（用来存放相对路径图片或文件）</code></p>
<p>这两个似乎不是一个效果，但是考虑到有效我就不折腾了。。。</p>
<p>2、使用HTML插入图片</p>
<p>这个方法和typero一样，也就是上面的方法，这种方法能直接显示的。一般不会遇到问题。缺点是在obsidian里面显示不出来。。。不过TypeDown也可以显示。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>已有博客仓库的重建和配置</title>
    <url>/2023/03/13/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/%E5%B7%B2%E6%9C%89%E5%8D%9A%E5%AE%A2%E4%BB%93%E5%BA%93%E7%9A%84%E9%87%8D%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>每次重装系统什么的，虽然仓库我做了备份，但是还是要重新配置一下环境，为了以后都能无脑配置，这里集中记录一下过程。</p>
<span id="more"></span>

<p>···</p>
<h2 id="博客源文件重新加入备份"><a href="#博客源文件重新加入备份" class="headerlink" title="博客源文件重新加入备份"></a>博客源文件重新加入备份</h2><p>1、从NAS上打开MyWeb的Syncthing同步项目，勾选共享到这台电脑，设置一下路径就行，还有启用排除列表。</p>
<p>不过上面这一项不是必须的，因为如果之前做好了备份，只需要复制AppData下的文件，Syncthing的配置文件就在里面不用自己去修改了，下次重装的时候设置会保持不变。</p>
<p>2、重新安装nodejs, 不用勾选安装其他模块，尤其是自己已经安装了python。<br>如果之前备份了appdata，模块应该还在。<br>尝试在博客存放文件夹下面cmd里面执行hexo -v看看能不能用，如果不能就重新安装hexo. (我没试)<br>npm install -g hexo-cli</p>
<p>然后后面的步骤就不用操作了，可以直接使用hexo命令了。</p>
<p>3、由于之前已经修改过git配置了，这里直接使用hexo d，可能会提示git仓库用户不一致，按照提示把git仓库加入安全目录即可发布。</p>
<p>4、能用就不要尝试更新组件了。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>博客的Tags和分类</title>
    <url>/2021/11/01/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%BA%8B%E9%A1%B9/%E5%8D%9A%E5%AE%A2%E7%9A%84Tags%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<span id="more"></span>

<p>上面是个示例，一篇文章的categories不能多个，写两个代表嵌套。</p>
<p>在next主题配置内：<br>打开 <code>~\themes\next\_config.yml</code> 文件，找到 <code>menu</code> 相关的设置，取消掉需要的菜单项的注释。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> [学习,html] </span><br><span class="line"><span class="bullet">-</span> [学习,http] </span><br></pre></td></tr></table></figure>
<p>这样也可以代表嵌套.</p>
<h2 id="本地分类管理"><a href="#本地分类管理" class="headerlink" title="本地分类管理"></a>本地分类管理</h2><p>通过该命令 <code>hexo new post -p /后端/test.md</code> 执行后，会在post文件夹下创建子文件夹 “后端”，并创建一篇test.md博文。<br>可以直接在<code>D:\MyWeb\source\_posts</code>下新建需要的文件夹进行分类，hexo可以识别文件夹下的内容。<br>这样就可以直接对接在obsidian里面写的文章。</p>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/50787870#:~:text=Hexo%2BGithub%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%9A03%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%201%201%E3%80%81%E5%88%9B%E5%BB%BA%E2%80%9C%E5%88%86%E7%B1%BB%E2%80%9D%E9%80%89%E9%A1%B9%202%201.1%20%E7%94%9F%E6%88%90%E2%80%9C%E5%88%86%E7%B1%BB%E2%80%9D%E9%A1%B5%E5%B9%B6%E6%B7%BB%E5%8A%A0tpye%E5%B1%9E%E6%80%A7%20%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%8D%9A%E5%AE%A2%E6%89%80%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E3%80%82%20%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4,-%20jQuery%20-%20%E8%A1%A8%E6%A0%BC%20-%20%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%20%E5%B0%B1%E6%98%AF%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E6%A0%87%E7%AD%BE%E4%BA%86%20">Hexo+Github博客教程：03添加分类 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>慧荣SM2246EN主控山寨固态硬盘修复</title>
    <url>/2022/11/23/Fix%20&amp;%20Crack/SSD%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<p><em>在某鱼收了一个120G的所谓金士顿v300固态硬盘，也是受到了一些颗粒玩家的影响想要收来做个U盘，便有了下文…</em></p>
<span id="more"></span>

<hr>
<h4 id="初印象"><a href="#初印象" class="headerlink" title="初印象"></a>初印象</h4><p>当时到手后拆开发现内部主控为慧荣SM2246EN，这可不好。。。</p>
<p>实际上在网上查询得知这款金士顿应该为SF2281的主控。<br>固态上的颗粒印字为Toshiba的TH58TEG7DDLTA00。如下图。</p>
<img src="/2022/11/23/Fix%20&%20Crack/SSD%E4%BF%AE%E5%A4%8D/%E5%A4%96%E8%A7%82.png" class title="整体外观">

<p>基本上认定这是一个山寨产品。</p>
<p>首先还是试一试读写，买了斐讯的Sata转USB3.0转接板，上机发现问题是偶尔能读取，但是无法删除原有文件，也无法新建（重新拔插后全部恢复原样），顺序写入大概70M&#x2F;s，很快掉盘。</p>
<h4 id="尝试修复"><a href="#尝试修复" class="headerlink" title="尝试修复"></a>尝试修复</h4><p>直接考虑进行量产操作。</p>
<p>图片上可以看到左边丝印有标注ROM，用镊子短接然后插USB就可以进入ROM模式，被慧荣SM2246EN的量产工具识别就可以开卡。</p>
<p>但是在慧荣的各个版本量产工具中都找不到这个颗粒型号。<br>关于颗粒类型与命名规则，这里可以参考一些别的文献。<br>这个颗粒按照丝印，应该是15nm制程的MLC，但是在SSD-z中读取为Toshiba 19nm MLC，主控读取为SF2281，但主控固件读取为P0614，这个型号可以看出来很明显是慧荣的一款固件版本。所以说具体颗粒究竟是什么从颗粒丝印不一定是正确的，也可能是重新打字。之前一直尝试使用东芝其他型号颗粒开卡不能开出。</p>
<p>然后用慧荣开卡工具进行Dram Test（下图）</p>
<img src="/2022/11/23/Fix%20&%20Crack/SSD%E4%BF%AE%E5%A4%8D/%E9%87%8F%E4%BA%A7%E5%B7%A5%E5%85%B7.png" class title="测试">
<p>发现Dram Test过不了，最开始的思路是找能不用缓存的固件开卡，但是实在找不到这样的。顺便提一嘴，这个慧荣的量产工具界面要拖动边框有些内容才会显示出来。<br>这时候去翻了翻论坛，了解到：</p>
<blockquote>
<ul>
<li>首先内存型号要选对</li>
<li>过不了可能是虚焊</li>
<li>maybe选别的颗粒就好了</li>
</ul>
</blockquote>
<p>这些不同的观点对我修复这个硬盘的过程造成一些困扰。</p>
<p>图中是南亚的颗粒，Nanya的内存丝印可以看到64M16，<br>意思是64M Bytes16位，这里这个大小按照8Bit算，就是128M，有些颗粒如三星（SEC，Samsung）海力士（SKhynix）会标1G16那种就是1G bits，就是128M Bytes。<br>SM2246主控只支持16位内存。进入参数设置页面设置正确（下图）</p>
<img src="/2022/11/23/Fix%20&%20Crack/SSD%E4%BF%AE%E5%A4%8D/%E9%87%8F%E4%BA%A7%E5%B7%A5%E5%85%B72.png" class title="量产">

<p>但是依然不能开卡。</p>
<hr>
<h4 id="切换思路"><a href="#切换思路" class="headerlink" title="切换思路"></a>切换思路</h4><p>这时候我已经想放弃了，但是考虑到还是有可能是内存颗粒虚焊，当时手头没有热风枪，先用力按住内存和PCB,发现DRAM Test 可以通过，果然是虚焊。用热风枪重新加焊之后，SSD可以直接使用了，不需要量产。<br>但是在跑随机读写的时候还是容易掉盘，而且顺序读写速度很低。本来不想接着折腾了，就装到壳子里面了。然后发现更容易掉盘了，需要重新加焊，这里为什么后面解释。<br>继续可以使用了之后，尝试在固态里面装一个<a href="https://markdown.com.cn/">Deepin</a>，但是每次都会最后掉盘，第三次的时候直接拔掉电源，发现再不能识别硬盘，当时心里一凉，完了。</p>
<h4 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h4><p>这时候已经不可避免要进行量产了，最开始提示Flash没有sync，后来再参数设置里面关掉了sync mode，至于选择颗粒选择了自动匹配ID的Sandisk的128Gb颗粒进行开卡，发现这样子可以通过开卡。<br>速度也有所提升。然是发现装进外壳之后又不能识别，这时候用手轻轻扳动缓存颗粒旁边的PCB边缘，发现不能通过DRAM test,就明白了外壳上螺丝的时候会压到这个pcb使其虚焊。重新加焊之后不再上这个螺丝。<br>另外，这只是这个固态的一部分毛病，之前再固态信息里面看到这个固态的数据量是<strong>120T</strong>…也就说，颗粒很可能已经接近报废，所以这就导致后面的的问题，写入到一部分的时候会掉盘。也就说坏块过多也不能映射备用块。这里说一下，固态和机械有很大的不同，所以diskgenius的扫描坏块是不合适的，比如需要读写，对于固态寿命是有影响的，读出来的结果也并不是真的物理块，但是我这里死马当做活马医，本身只想看个参考，所以跑了测试发现确实有读写错误的部分。</p>
<p>为了解决这个问题，可以通过跑RDT来解决这个问题，量产的时候勾选RDT,这个PCBA在跑的时候会闪灯，所以可以看到跑完结束。跑完RDT之后量产需要直接插上电脑，<strong>不要短接ROM，不要短接不要短接</strong>，那样就失去了RDT信息(如下）<img src="/2022/11/23/Fix%20&%20Crack/SSD%E4%BF%AE%E5%A4%8D/RDT.png" class title="RDT"></p>
<p>而是直接插上硬盘就应该能在量产工具里面检测到。  最开始我的斐讯的JMS576我发现不行，还准备去买别的转接卡，后来发现只要插在USB2.0端口上就可以识别了，然后换了0819A的固件，发现速度也有提升，测试两天后发现没有掉盘，结束。</p>
<hr>
<p>补充：NAND的ID可以复制读出来的第一行数据在这个上面找试试<a href="http://www.flashinfo.top/">www.flashinfo.top</a></p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>折腾有风险，修理费时间，目前稳定使用一年多，不过权当一段经历吧。</p>
]]></content>
      <categories>
        <category>Fix &amp; Crack</category>
      </categories>
      <tags>
        <tag>修理</tag>
        <tag>SSD</tag>
        <tag>Flash</tag>
      </tags>
  </entry>
  <entry>
    <title>Design an Arbitrary Waveform Generator Using the RP2040 MCU and a Digital-to-Analog Converter</title>
    <url>/2023/06/18/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/Design-an-Arbitrary-Waveform-Generator-Using-the-RP2040-MCU-and-a-Digital-to-Analog-Converter-DAC/</url>
    <content><![CDATA[<p>    标题是AI写的，本来我想写的是<code>用RP2040实现AWG</code> ，AI说我这个标题不够专业，给我改了一大串，我感觉确实挺🐂🍺，就直接贴上来了。</p>
<span id="more"></span>

<h1 id="为什么要写这个"><a href="#为什么要写这个" class="headerlink" title="为什么要写这个"></a>为什么要写这个</h1><p>网上有一堆RP2040实现的AWG的设计，其中有一个传播比较广泛的是一个用python写的<a href="https://www.instructables.com/Poor-Mans-Waveform-Generator-Based-on-RP2040-Raspb/">配合一个10bit R2R DAC实现的AWG设计</a>。然而，我认为它有错误:基本上所有的帖子认为连续的DMA传输直接使用例程中给出的控制传输的方法就可以了，然而这种传输方法会损失一个时钟周期用来搬运DMA配置。这意味着信号周期没有被严格控制。对于主频轻轻松松就可以达到270MHz的RP2040来说这个Bug很难看出来，但是如果生成信号波形周期较短就可以看到。B站有一个对于原开源项目的<a href="https://www.bilibili.com/video/BV1Xq4y1Y7eF">复刻</a>，在输出高频的时候就能看出来了。</p>
<pre><code>这个复刻的视频不够详细，后面我会给出具体测试结果。

不知道为什么RP2040作为树莓派一个很不错的产品，有相当多的讨论和开源环境，但是有些教程却始终是抄来抄去，甚至英文环境也是，可能确实是没啥人用这个做产品就是这样吧。。。包括下载配置，有更好的方法，但是容易找到的教程都是最开始手册上给出的方法。
</code></pre>
<p>一个原因是手册上没有直接给出DMA乒乓传输的例子和说明，而是通过一个称作“控制传输（2.5.6.2. DMA Control Blocks .RP2040-Datasheet）” 来说明如何连续传输数据到外设或者指定地址。我在反复怀疑自己了几天之后，决定直接写代码验证一下。</p>
<blockquote>
<p>Talk is cheap. Show me the code</p>
</blockquote>
<p>    我最开始不甚了解乒乓传输这个概念，说来惭愧，写了几年单片机，就用过一次DMA, 最后还因为操作逻辑不好处理舍弃了，其他时候要么是用垃圾单片机压根没有DMA，要么是没这需求。这里还是第一次正儿八经看看DMA怎么做。</p>
<p>代码验证想法是正确的，分别验证了原来的控制传输确实会出错，测试了信号波形，以及验证了使用PingPong传输能得到想要的结果。</p>
<pre><code>手册中给出的例子确实实现了连续传输不需要CPU介入，但是它从来没说过时序是严格的，单独为DMA循环传输做了功能的有STM32,配置循环就会自动从地址段环回取数据。RP2040的DMA IP核似乎是买的公版IP，不过用下来还是比较好用的。
</code></pre>
<p>下面正文里面详细说设计和测试。</p>
<h1 id="RP2040-DMA"><a href="#RP2040-DMA" class="headerlink" title="RP2040 DMA"></a>RP2040 DMA</h1><p>DMA，顾名思义，直接内存访问，无需使用CPU搬运数据。</p>
<p>有一个触发其他通道的概念比较有意思，可以配置为每个通道传输结束后会自动触发另外一个DMA通道启动，很明显，这样就可以实现一个PingPong传输了，甚至可以多个通道接力最后转回来。遗憾的是它并不能自己触发自己，所以实现连续传输至少需要两个DMA通道.</p>
<p>由于没有自动的循环模式，想要严格控制传输时序，就需要DMA通道在下一次传输前准备好，  </p>
<p>由于DMA通道配置的传输地址并不会自己回到最初的地址，因此每次传输结束后至少要重新配置传输起始地址才能在下一次传输中传输正确的数据。因此，这种方法保证了时间间隔的严格，但是作为牺牲是CPU必然要耗费一定时间参与传输任务。这可能对于其他任务是有影响的。</p>
<pre><code>然而RP2040是双核的，实在优化不出来完全可以扔到另一个核心跑（
</code></pre>
<h1 id="R2R-DAC"><a href="#R2R-DAC" class="headerlink" title="R2R DAC"></a>R2R DAC</h1><p>为什么使用这个DAC? 由于是电阻结构所以很容易做而且能达到不错的输出速度。当然了很多成品并行DAC也是使用的R2R结构，而且拆机件也不贵，这里首选选用手工使用电阻搭建这个DAC，为了好玩，其后再测试成品集成芯片。</p>
<p>关于DAC，可以看我这篇博客：<a href="https://blog.csdn.net/always_one/article/details/104560604?spm=1001.2014.3001.5501">(36条消息) 关于DAC的原理_dac工作原理_你要写卓的博客-CSDN博客</a>（TODO:改天找到原文迁移到自己的博客上）</p>
<h1 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h1><p>其实最开始的测试版本充其量只能叫做硬件连接不能叫做硬件设计，因为测试过程中只是用到了一个开发板连接了一堆电阻而已。</p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>rp2040</tag>
        <tag>ARM</tag>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title>SD知识树</title>
    <url>/2022/11/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/SD%E7%9F%A5%E8%AF%86%E6%A0%91/</url>
    <content><![CDATA[<p>还没想好怎么写因为一直都没用上要写sd卡的东西了。。。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
  </entry>
  <entry>
    <title>ADS1263性能测试</title>
    <url>/2022/09/25/Work%20with%20the%20world/ADS1263%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>严格来说，应该是功能测试，因为我手上只有6.5位DMM, 我甚至买不起好的基准芯片（心痛价格），对于一个32bit ADC来说可能我测试的条件有点太丐了。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最初想测试这个完全是因为在TB上看见这个正儿八经的ADC片子只需要18块钱（拆机），而ADS1262只少一个24bit 辅助ADC , 价格是8元。 我直接心动。</p>
<p>买来之后，我首先找有没有现成的资料，在电脑上用everything搜索，发现有我写的工程。。。。我发现这玩意儿竟然是我大一的时候参加比赛调过的ADC ,当时做的是组合秤，现在想起来当时好像是说超过200yuan&#x2F;pcs……</p>
<pre><code>拆机片真是个好东西。
</code></pre>
<p>于是大致理了一下之前出现的问题。</p>
<p>当时硬件不是我做的，不过我倒是比较清楚问题，因为最后的输出转换结果实在是太拉了，记得好像是有效位数大概只有12bit，按照手册上最高25bit的无噪分辨率来看这实在是差到没边了。</p>
<p>另外，当时项目所使用的供电是AMS1117-5.0 ,虽然比直接用开关电源强一点，但是这个1117承担了从外部开关电源转换的重任。。。也就是说很可能对于纹波抑制基本上没啥效果。<br>另外当时还遇到了ADC转换发热较严重的情况，不知道是设计原因还是实际存在。</p>
<p>最后重新看了一下手册和代码，发现当时的代码寄存器配置能让这个ADC跑起来就是个奇迹。。。。当时使用的祖传代码，还有不知道谁说的这个adc只有俩通道，但是代码里面实际开了三个通道，真的难绷。</p>
<p>所以基本上需要解决的问题是：<br>1、基准源<br>2、供电<br>3、修（重写）代码</p>
<pre><code>顺便吐槽一下TI的ADC的寄存器配置，真的难顶，一大堆寄存器，例程也不给，用起来极为麻烦。
</code></pre>
<p>写这篇文之前我已经开始画板了，当时考虑的是能完整测试功能，包括不同供电的影响，时钟的影响和基准的影响。</p>
<p>其实在手册上我感觉内部基准的参数是很不错的，但是大家表示存在水分，所以仍然需要测试外部基准（实际上不用测试，直接氪金就行了），实际上我挂了一个LT1009, 很可能是远不能达标的。</p>
<p>供电设计则选择了可选的LP2985 LP2951 LT3042的组合选择，其中LT3042作为地表最强LDO,没有组合，直接输出5V供电给ADS1263 , 而其他的设计存在级联或者单独出电压的选择，使用跳线帽切换。外部供电则选择之前做的线性电源，虽然可能不咋好但是比开关电源强多了，后期测试则使用18650串联。</p>
<p>时钟则预留了外部有源晶振和无源晶振以及SMA输入口，在设计这个板子的时候还没有意识到内部RC振荡器有多么不稳定，以及没有了解到时钟对Σ-Δ ADC转化的影响（TODO:这里写上参考文章号），幸好多个心眼都给预留了。</p>
<p>当时预留的单片机是CH549, 预留了ADC的SPI接口排针，现在看来，幸好留了排针。。。CH549对于我来说还是太难用了，毕竟51没有仿真功能。所以使用手上有的GD32F350G8单片机。</p>
]]></content>
      <categories>
        <category>Work with the world</category>
      </categories>
      <tags>
        <tag>ADC</tag>
      </tags>
  </entry>
  <entry>
    <title>KiCad联合LTspice仿真 - KiCad Simulation:Export to LTspice</title>
    <url>/2023/07/11/Work%20with%20the%20world/KiCad%E8%81%94%E5%90%88LTspice%E4%BB%BF%E7%9C%9F/</url>
    <content><![CDATA[<p>在介绍完KiCad仿真工具后，前文还介绍了如何使用KiCad内置的ngspice进行原理图仿真的案例，但是内置仿真的功能还不够多，而ngspice的界面过于简陋基本等于没有，那么有没有更好的仿真工具可以用呢，答案是，有的。</p>
<h1 id="LTspice简介"><a href="#LTspice简介" class="headerlink" title="LTspice简介"></a>LTspice简介</h1><p>这是一款免费的仿真工具，而且由ADI鼎力支持。 有这两点介绍就足够了。</p>
<h1 id="联合LTspice仿真的流程"><a href="#联合LTspice仿真的流程" class="headerlink" title="联合LTspice仿真的流程"></a>联合LTspice仿真的流程</h1><p>下面简单介绍一下整个流程和方法。</p>
<h2 id="打开KiCad工程"><a href="#打开KiCad工程" class="headerlink" title="打开KiCad工程"></a>打开KiCad工程</h2><p>这个没啥好介绍的吧，首先你得有个原理图。</p>
<h2 id="绘制原理图"><a href="#绘制原理图" class="headerlink" title="绘制原理图"></a>绘制原理图</h2><p>绘制原理图和前文相同，只需要给器件添加正确的仿真模型（或者直接已经写好绝对路径的器件），并且有正确的源设置。</p>
<p>相比于直接在KiCad中仿真，还需要继续设置一些东西。</p>
<h2 id="填写仿真语句"><a href="#填写仿真语句" class="headerlink" title="填写仿真语句"></a>填写仿真语句</h2><p>当然，在KiCad中直接仿真的时候，先写好仿真语句也是完全可以的而且我是比较推荐的。</p>
<p>如果导出的时候没有事先在原理图中写好仿真语句，那么使用LTspice打开的时候会提示没有可用的仿真类型，你也可以这时候再在LTspice中编辑，但是，提示的弹窗很烦，不是吗？</p>
<p>需要注意的是，网表导出器只能识别它支持的语句，不支持的也不会被导出。</p>
<h2 id="设置导出功能"><a href="#设置导出功能" class="headerlink" title="设置导出功能"></a>设置导出功能</h2><p>打开原理图后，点击：</p>
<p>文件-&gt;导出-&gt;网表-&gt;选择spice这一栏，更换里面的默认命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LTspice.exe -big &quot;%I&quot;</span><br></pre></td></tr></table></figure>

<p>这里要注意，如果LTspice.exe并没有加入环境变量，那么需要填写为绝对路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\[用户名]\AppData\Local\Programs\ADI\LTspice\LTspice.exe  -big &quot;%I&quot;</span><br></pre></td></tr></table></figure>

<p>旧版的LTspice的可执行文件不叫这个名字,可以替换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Program Files\LTC\LTspiceXVII\XVIIx64.exe -big &quot;%I&quot;</span><br></pre></td></tr></table></figure>

<p><code>-big</code> 参数表示打开的时候最大化窗口，<code>%I</code>则是当前导出网表的路径。</p>
<p>还可以选择更多的参数，参考LTspice安装目录下的LTspiceHelp文档，<code>Command Line Switches</code>章节。</p>
<p>然后点击导出网表并运行就可以直接打开LTspice啦。</p>
<blockquote>
<p>当然，直接点击导出网表后点击cir文件也可以直接用LTspice打开，但是那麻烦一些，不是吗</p>
</blockquote>
<h2 id="额外的功能"><a href="#额外的功能" class="headerlink" title="额外的功能"></a>额外的功能</h2><h3 id="使用LTspice的专用模型"><a href="#使用LTspice的专用模型" class="headerlink" title="使用LTspice的专用模型"></a>使用LTspice的专用模型</h3><p>LTspice的模型大多是专用的，但是除了加密模型，他们也是使用ASCII文本文件储存的，因此，虽然在KiCad的ngspice中虽然可能用不了，但是依然可以设置为器件的spice模型并且导出到LTspice使用。</p>
<p>这种方法的好处是对于ADI没有直接提供Spice模型的器件, 可以直接借用LTspice的模型。</p>
<blockquote>
<p>是借用！读书人的事怎么能叫偷呢？</p>
</blockquote>
<p>方法如下：</p>
<p>使用Everything找到需要器件的asy文件，这是LTspice所使用的原理图符号的文件。</p>
<blockquote>
<p>什么？你还没有用上Everything? 赶快下载吧！极速体验就在眼前~</p>
</blockquote>
<p>例如LT1009.asy ,使用文本编辑器例如VSCode打开这个文件，找到带有 <code>SpiceModel</code> 字样这一行，这个说明了这个模型在哪个库里面，这里找到的是LTC3.lib 。同时，可以关注一下下面的SpiceOrder,这个表示了spice中引脚排列顺序。这里是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PINATTR PinName VCC</span><br><span class="line">PINATTR SpiceOrder 1</span><br><span class="line">PIN 0 32 NONE 8</span><br><span class="line">PINATTR PinName VEE</span><br><span class="line">PINATTR SpiceOrder 2</span><br><span class="line">PIN 32 0 NONE 8</span><br><span class="line">PINATTR PinName ADJ</span><br><span class="line">PINATTR SpiceOrder 3</span><br></pre></td></tr></table></figure>

<p>那么在KiCad原理图元器件的仿真设置中就需要设置正确的顺序。</p>
<p>在KiCad6中是勾选替代节点顺序，用KiCad原理图符号引脚号表示引脚，排成上面需要的顺序。</p>
<p>在KiCad7中是在引脚分配上手动勾选就好了。（吐槽：似乎还没上面那个好用，引脚多的器件需要一个一个点好累）</p>
<blockquote>
<p>TIPS【1】: 可以看到LTC3.lib就包含了很多LTSpice的模型，实际上安装目录下LTspice\lib\sub的.lib文件就是Ltspice所用的spice器件模型，不过大多数模型都用了LTspice所兼容的语法，因此在ngspice可能并不能直接使用。</p>
<p>TIPS【2】: ngspice可以调整兼容模式，在KiCad中是 检查-&gt;仿真&gt;仿真-&gt;设置 ，不过这不影响导出的网表，而且似乎没啥用。</p>
</blockquote>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>1、LTspice在许多电路中更容易收敛，还能用LTspice的模型仿真。</p>
<p>2、LTspice功能更多。</p>
<p>3、对于LTspice本来就没有的模型还是手动导入，这里直接从KiCAD导入则干脆省掉了这一步。</p>
<blockquote>
<p>其实ngspice本身收敛能力不错，但是还是远不如LTspice，很多使用复杂模型的电路都会无法收敛。</p>
</blockquote>
<h1 id="相比直接使用LTspice的缺点"><a href="#相比直接使用LTspice的缺点" class="headerlink" title="相比直接使用LTspice的缺点"></a>相比直接使用LTspice的缺点</h1><p>1、这个方法的缺点是由于只有网表可用，因此LTspice中的部分增强使用体验的功能不能直接使用。</p>
<p>虽然ltspice所支持的原理图文件（.asc）也是纯文本储存，而且格式非常简单，但是KiCad并没有基于原理图的插件功能，因此我认为目前不值得为其开发一个转换生成Ltspice原理图的功能。</p>
<blockquote>
<p>KiCad组织从KiCad5开始说下一代要加入原理图插件功能，python插件示例中也预留了库名称，但是直到KiCad7,他们依然在说下次一定！</p>
</blockquote>
<p>2、LTspice部分加密的二进制模型也无法使用。</p>
<h1 id="语法注意点"><a href="#语法注意点" class="headerlink" title="语法注意点"></a>语法注意点</h1><p>有些名称需要按照LTspice的来，例如噪声仿真中，输出噪声的频谱是onoise_spectrum，而LTspice是onoise，例如需要使用.save命令的时候，当然是需要复合当前使用的仿真器。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我尝试过使用别的仿真工具导入网表，但是似乎不太好用。</p>
<p><del>好了，现在KiCad仿真的系列教程结束了，现在转入LTspice的仿真教程吧！</del></p>
<p>我忘记我还要说什么了。。。。<br>下面放个视频教程：</p>
]]></content>
      <categories>
        <category>Work with the world</category>
      </categories>
      <tags>
        <tag>模电</tag>
        <tag>Spice</tag>
      </tags>
  </entry>
  <entry>
    <title>Multisim仿真画板一气呵成</title>
    <url>/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>在multisim仿真中，往往会仿真一些模块，这些模块不是特别复杂，但是需要做出来的时候如果选择脑补焊接或者用别的软件重新辅助设计又略麻烦，于是有了下文。</p>
<span id="more"></span>
<h2 id="首先需要了解的"><a href="#首先需要了解的" class="headerlink" title="首先需要了解的"></a>首先需要了解的</h2><ul>
<li>multisim和ultiboard是一套产品，在安装multisim的时候基本都会安装。其中multisim用于原理图和仿真，ultiboard用于PCB.</li>
</ul>
<h2 id="步骤1：仿真原理图与添加封装"><a href="#步骤1：仿真原理图与添加封装" class="headerlink" title="步骤1：仿真原理图与添加封装"></a>步骤1：仿真原理图与添加封装</h2><p>首先当然是绘制原理图。</p>
<p>在绘制原理图的时候，除了必要的元件之外，还可以添加连接件例如排针。在器件库中选择Connectors，选择All families后搜索HDR</p>
<p>,看到HDR1x10,这个就是10pin的2.54mm排针，这里可以找到HDR1x2进行添加。</p>
<p>如下图:</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210313213000992.png" alt="image-20210313213000992" style="zoom:67%;">

<p>然后可以看到上图中的R3为黑色，其余元件有别的颜色，如电阻电容的蓝色。</p>
<p>因为有颜色的是添加了封装。对于具体的器件，有的器件包含默认封装，但是这种基本器件需要自己选择。</p>
<p>双击元件：</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210313213413695.png" alt="image-20210313213413695" style="zoom:67%;">

<p>可以edit package ,进入之后可以挑选一个封装，排序是字母（没找到怎么快点找到，下版改进）。</p>
<p>由于主要用于快速参考或者洞洞板焊接，阻容封装通常可以随意一点。</p>
<p>只需要把自己需要焊接的器件添加封装，不添加封装的不会出现在板子中。</p>
<h2 id="步骤2：元件布局"><a href="#步骤2：元件布局" class="headerlink" title="步骤2：元件布局"></a>步骤2：元件布局</h2><p>添加封装之后，点击transfer，当然这里也可以导出网表用别的软件来画，这里本来就是为了省事，就直接点击transfer to Ultiboard 14.0.</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210313213816011.png" alt="image-20210313213816011" style="zoom:67%;">

<p>你会得到一个ewprj后缀的文件，这时候器件都在底下了，但是还没有连线，首先用鼠标移动器件进行摆放，Ctrl+R可以旋转。</p>
<p>或者使用自动摆放 ：顶部Autoplace parts.</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210319223305830.png" alt="image-20210319223305830" style="zoom:67%;">

<h2 id="3D-预览"><a href="#3D-预览" class="headerlink" title="3D 预览"></a>3D 预览</h2><p>下面这个选项可以查看3D,鼠标左键拖动</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210319223543410.png" class title="image-20210319223543410">

<p>3D 是个新窗口，直接右上角关掉就回到了二维</p>
<p>摆放完成之后，点击Place，点击Line（或者快捷键Ctrl+Shift+L），对元件引脚连接用于自己连线参考。</p>
<p>由于是作为洞洞板参考，最好单层。如下，比较随意：</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210313214659220.png" alt="image-20210313214659220" style="zoom:67%;">

<p>也可以使用自动布线然后手动修改：在一个自动布线的教程中，在开始还做了这个，不知道具体含义：</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210319223412654.png" alt="image-20210319223412654" style="zoom:67%;">

<p>去掉了这个钩（在options-pcb properties里面）。</p>
<p>然后可以进行autoRoute。</p>
<p>洞洞板是2.54mm间距的洞洞，即100mil，为了方便，可以在菜单Edit-Properties，点击第二个Grid &amp;units，修改栅格为100mil或者50mil。</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210313214839186.png" alt="image-20210313214839186" style="zoom:67%;">

<p>到这里就可以参考这个布局进行洞洞板的焊接，当然有兴趣也可以用这个出PCB。</p>
<p>左侧选择Board Outline 可以绘制边框。</p>
<p>这个还提供了一个功能就是全选pcb内的内容可以直接复制到word里面为图片：</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210420001109403.png" alt="image-20210420001109403" style="zoom:67%;">

<p>选到铜皮层，然后place graphics 选择类型可以添加覆铜。</p>
<img src="/2021/04/20/Work%20with%20the%20world/Multisim%E4%BB%BF%E7%9C%9F%E5%90%8E%E5%BF%AB%E9%80%9F%E5%B8%83%E5%B1%80/image-20210420001054814.png" alt="image-20210420001054814" style="zoom:67%;">

<h2 id="步骤3：导出gerber（额外）"><a href="#步骤3：导出gerber（额外）" class="headerlink" title="步骤3：导出gerber（额外）"></a>步骤3：导出gerber（额外）</h2><p>导出gerber比较坑，按照默认选项导出有钻孔也有光绘，用gerber预览看见也应该是正确的，但是在嘉立创下单助手里面不能识别。。。。</p>
<p>这里用用kicad的gerbview导入ultiboard导出的gerber文件，导出到pcb_new,选择正确的层，有些没有就不选，然后可能需要到到kicad里面整理一下边框重新导出是可以使用的，没有琢磨出来能直接导出可以识别的Gerber的方法.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于直接使用原理图的网络，这里焊接只要不连接错网络，在洞洞板焊接中不容易出错，同时对于元件引脚分配好封装之后不需要再查找对应关系，比较方便快速。对于一些小板子，直接用multisim出图也快一点。</p>
<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><p><a href="https://wenku.baidu.com/view/6ee157d028ea81c758f5786e.html">PCB版图设计(Ultiboard) - 百度文库 (baidu.com)</a></p>
<p><a href="https://www.ece.ubc.ca/~robertor/Links_files/Files/Ultiboard-tut-Exporting-Gerber-Files.pdf">https://www.ece.ubc.ca/~robertor/Links_files/Files/Ultiboard-tut-Exporting-Gerber-Files.pdf</a></p>
<p><a href="https://knowledge.ni.com/KnowledgeArticleDetails?id=kA03q000000YG0FCAW&l=zh-CN">https://knowledge.ni.com/KnowledgeArticleDetails?id=kA03q000000YG0FCAW&amp;l=zh-CN</a></p>
<pre><code>更新：由于KiCad也能进行仿真，因此更推荐使用KiCad进行设计。
</code></pre>
]]></content>
      <categories>
        <category>Work with the world</category>
      </categories>
      <tags>
        <tag>Spice</tag>
        <tag>Mulstisim</tag>
        <tag>PCB</tag>
      </tags>
  </entry>
  <entry>
    <title>使用KiCad内置的ngSpice进行电路仿真（0）</title>
    <url>/2022/09/22/Work%20with%20the%20world/%E4%BD%BF%E7%94%A8KiCad%E5%86%85%E7%BD%AE%E7%9A%84NgSpice%E8%BF%9B%E8%A1%8C%E7%94%B5%E8%B7%AF%E4%BB%BF%E7%9C%9F%EF%BC%880%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实几乎所有的EDA工具（这里只是指板级设计工具），都提供了仿真的功能，功能的完善程度取决于这个公司来头多大，例如cadence中的原理图工具，它收购了pspice之后进行了改进并集成到其中，可以进行仿真，同时有巨量的仿真库。</p>
<p>而国内常用的仿真软件multisim和proteus，虽然在课堂上都是用来仿真，但是他们都有配套的PCB工具，还有Tina软件同样包含各种工具，从数字逻辑仿真到模拟仿真到PCB.</p>
<span id="more"></span>

<blockquote>
<p>免费的Tina-TI使用比较多，仿真模型比官方有些缺少，也没有其他更多的功能。<br>另外，ltspice是真就只能仿真。</p>
</blockquote>
<p>仿真的实现方法根据仿真目的和实际需求有很多方法，但是最早诞生于伯克利大学的spice程序则是应用非常广泛的一个（TODO:找资料来），spice对于电路使用网表描述，并根据网表和器件的模型进行方程的解算得到仿真结果，spice是开源的，因此市面上有很多产品都基于类似的设计。<br>下面要使用的ngspice就是基于spice3f5和其他spice仿真工具改进的开源spice仿真工具。</p>
<pre><code>刚刚提到了网表，但是在这个计算机普及的时代，网表概念被弱化了，实际上网表就是用字符串来描述器件如何连接，毕竟一个文本文件在计算机早期时代是更容易输入到电脑上进行计算的（输入图形甚至可能做不到），当然在如今，网表依然是一个不错的描述工具，对于spice程序来说不算过时，大部分spice软件依然可以兼容老旧的器件仿真模型，可以实现导入等操作。
</code></pre>
<p>为什么不用其他工具呢？</p>
<ol>
<li><p>开源 NO.1</p>
</li>
<li><p>不想学了其他的了，为了方便直接画原理图。</p>
<p> 实际上了解到KiCad的时候最开始我并不知道它可以仿真，直到听到一个国外上学的老哥说他们作业要求用这个来做我才知道这东西可以仿真，当时KiCad6还刚出，中文网都没有相关的教程。后来了解到实际上官方的教程还是比较多的（见下面参考链接）。包括ngspice的官网教程也是推荐使用KiCad.</p>
</li>
</ol>
<p>下面给出几个相关度最高的链接。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="https://www.kicad.org/discover/spice/">SPICE Simulation | KiCad EDA</a>    –这个是KiCad官网介绍，很简单的介绍。</li>
<li><a href="https://forum.kicad.info/t/simulation-examples-for-kicad-eeschema-ngspice/34443">Simulation examples for KiCad&#x2F;Eeschema&#x2F;ngspice - Schematic &#x2F; Simulation (Ngspice) - KiCad.info Forums</a>   –这个是KiCad论坛中给出的仿真案例，包含了三十多个电路，覆盖非常全。</li>
<li><a href="https://ngspice.sourceforge.io/ngspice-eeschema.html">KiCad Eeschema as GUI for ngspice, tutorial for setting up the simulation (sourceforge.io)</a> – 这是nspice网站用KiCad做的入门教程，非常详细。</li>
<li><a href="https://ngspice.sourceforge.io/ngspice-tutorial.html">ngspice tutorial for beginners (sourceforge.io)</a> – 这是ngspice入门的第一个教程，值得看一下了解一下</li>
</ol>
<h2 id="Kicad中的仿真可以做什么"><a href="#Kicad中的仿真可以做什么" class="headerlink" title="Kicad中的仿真可以做什么"></a>Kicad中的仿真可以做什么</h2><p>在KiCad中，当前的版本（6.0x）,主要是模拟电路的仿真。</p>
<pre><code>kicad已经更新了，在KiCad得到Net的捐赠后（KiCad Project Awarded NLnet Grant），kicad 在接受捐赠之后承诺要提高仿真的易用性，实际上计划表推到8.0之后了，而个人觉得7.0的仿真bug似乎更多，因此这里还是用6.0版本
</code></pre>
<p>同时，当前的内置功能比较简单，只能进行瞬态仿真、交流仿真、直流转换的图形显示，其他的仿真结果则需要自己导出。</p>
<h2 id="ngspice简述"><a href="#ngspice简述" class="headerlink" title="ngspice简述"></a>ngspice简述</h2><!--more-->






]]></content>
      <categories>
        <category>Work with the world</category>
      </categories>
      <tags>
        <tag>模电</tag>
        <tag>Spice</tag>
      </tags>
  </entry>
  <entry>
    <title>标准I2S接收器的分立逻辑器件实现</title>
    <url>/2023/06/22/Work%20with%20the%20world/%E6%A0%87%E5%87%86I2S%E6%8E%A5%E6%94%B6%E5%99%A8%E7%9A%84%E5%88%86%E7%AB%8B%E9%80%BB%E8%BE%91%E5%99%A8%E4%BB%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>这个从想做到做出来拖了两年。其实单纯讲做出来的话没有任何技术难度，就是一直拖。<br>早些年看到一些神奇贩子吹嘘着什么分立R2R DAC,使用解码多么多么动听，然而只要稍微了解一下相关器件，就知道，人家R2R做的好是因为人家做了几十年芯片，而你只是没有任何测试。不过，想到这个东西从数字到模拟还是挺好玩的，就想自己实现一下，讲究一个超低成本，看看听起来感觉怎么样。</p>
<span id="more"></span>

<p>其实文章名字叫做接收器的实现，既然接受了最后肯定要出效果的，所以后端就是最简单的R2R DAC来得到模拟信号。这个文章也会是整板设计说完整。</p>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><p>其实虽然说着简单，但是基本上几年毫无数字逻辑实战设计经验的我一上来是比较懵圈。总体上设计分成两部分。</p>
<ul>
<li>I2S信号转并行信号</li>
<li>R2R DAC本身</li>
</ul>
<p>其中，I2S信号飞利浦指定的信号标准，但是实际上有好几种格式都被称之为I2S信号。其中飞利浦标准可以从其标准文档获得。</p>
<p>实际上文档中已经给了两种可行的设计逻辑图，但是当时我对着这个图不知道怎么选型器件。。。</p>
<p>TODO:</p>
<p>参考资料：<br>I2S bus specification.pdf Philips<br>I2S bus specification -UM11732 NXP<br>实际上NXP就是Philip出来的，新文档主要是把Master&#x2F;slave修改成了Controllter&#x2F;Target.<br>(虽然有点政治正确，但是早该改了，以前这种表达是挺离谱的)</p>
<p>测试之后发现74HC74的CLR和PR没有拉高。。。</p>
<p>然后发现输出的是补码，，最高位需要取反。<br>然后就发现了这个设计存在问题。</p>
<h1 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h1><p>在假货宝上义胜买的AMS1117-5V用了没多久就被击穿了，本来一开始3.3V还是正常工作，奈何我没发现。。。切换到5V之后，实际输入12V把逻辑片全部带走了。</p>
<pre><code>... 太难过了，下次设计这种电源一定要做好保护，也不要抱着侥幸买假货。。
</code></pre>
<p>因此就开始改板，加入之前没有考虑进去的部分。</p>
]]></content>
      <categories>
        <category>Work with the world</category>
      </categories>
      <tags>
        <tag>数字逻辑</tag>
        <tag>DAC</tag>
      </tags>
  </entry>
  <entry>
    <title>reMarkable 1 漫游指南</title>
    <url>/2023/07/19/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/reMarkable%201%20%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>aka 2023 reMarkable 1代配置完全指南：从配置字体到救砖刷机</p>
<span id="more"></span>
<p>reMarkable 1 是于2017年11月21日上市的第一代手写电纸书平板，众筹价379刀，至今官网仍在更新系统，在今年（2023）七月的时候刷淘宝的洋垃圾店看到了这个，简单对比了一下功能和某黄鱼上的价格后下单，到手价738。</p>
<pre><code>据说之前更便宜，不过不知道是多少了。
</code></pre>
<p>其实很早就想买个电纸书了，不过上次买的时候由于疫情管控一个多月没发货消磨了我的冲动最后退掉了。这次看到这个有10inch的屏幕，重量只有350g，而且还配有低延迟的电磁笔，实在让我心动，这次忍不住手欠了。</p>
<p>到货之后，这个是没有保护套的，淘宝上也买不到，因为这个型号实在是太老了，算起来都有6年了。而且当时这个也不便宜，对国内的支持也不是很好，普及度必然不高。</p>
<pre><code>时间过得真快，2017年的时候我还在渴望着有一个索尼的DPT-RP1，没想到现在捡的洋垃圾就是当时同台竞争的产品。
到去年国内的厂商都已经出了墨水屏平板了。然而，reMarkable的系统仍然默认不支持中文。
但是它在国外的热度确实相当高的，看网上的开源项目就知道了。
</code></pre>
<p>首先说说使用体验。</p>
<h1 id="手感和交互"><a href="#手感和交互" class="headerlink" title="手感和交互"></a>手感和交互</h1><p>整个平板非常轻薄，厚度控制非常好，拿在手上完全不会出现习武之人的情况。背面是金属加上防滑条，屏幕是类似于磨砂的表面，大概能减少一些直接的反光，不过在近光源下仍然需要避开点角度。226ppi的像素密度放在现在仍然不过时。</p>
<div align="center"><img src="/2023/07/19/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/reMarkable%201%20%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/P1010319.jpg" width="600"></div>

<pre><code>用自己搓的微距镜头拍了一下，可以看到磨砂处理，字体边缘不是没对焦，是就是这样的。
</code></pre>
<p>附带的手写笔的笔头是软的，写字手感非常好，不过也据说比较费笔头，官方送了10个笔头在套装里面，不过考虑到这个东西的笔头仍然很贵，我打算找找替代品。</p>
<p>由于是使用的wacom的电磁屏技术，我猜测只要是同类的无源笔都可以支持，于是找到了我之前的数位板上的笔，分别是高漫M6，Wacom CTL 472，还有之前捡垃圾的时候顺手买的两块钱一支的祖国版三星note配笔，分别测试了一下，结果如下。</p>
<ul>
<li><p>高漫M6 可写，但是灵敏度不匹配，没接触到板面就会写上笔迹。</p>
</li>
<li><p>wacom CTL 472，不可用。</p>
</li>
<li><p>祖国版<font color="#d83931">三星note配笔，完美支持</font>，就是太小了。</p>
<p>  反过来说，这个笔和三星笔也可以在数位板上用，就是感应距离比较短。</p>
</li>
</ul>
<div align="center"><img src="/2023/07/19/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/reMarkable%201%20%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/P1010304.jpg" width="750"></div>

<blockquote>
<p>我当时买这俩垃圾笔只是看到了一个<u>把note的笔塞进笔杆里当正常尺寸笔用的操作</u>，用在三星Tab上，我寻思也许我会买Tab呢，没想到最后能在这里用上了。</p>
</blockquote>
<div align="center"><img src="/2023/07/19/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/reMarkable%201%20%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97/P1010323.jpg" width="750"></div>
翻书支持使用按键和在屏幕上左右滑动，虽然模式不是很多但是够用。

<p>可能是考虑到是墨水屏，交互点击的时候没有视觉反馈，有时候感觉不到是不是点错了。但是在KOReader里面这个可以设置支持的。</p>
<h1 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h1><p>配置软件的时候可能会需要用到工具，下面会说明。</p>
<h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><p>连接的时候首先需要连接WIFI或者连接USB后打开USB Web Interface. 前者的IP在设置中Help-Copyright and licenses下可以找到，同时这里能找到SSH密码。</p>
<pre><code>记住这个密码，防止出现问题仍然可以用这个密码登录SSH.
</code></pre>
<p>后者IP则保持为 10.11.99.1 ，如果不想连接WIFI或者为了避免IP变化，可以就用USB界面。配置的时候最好把睡眠关掉，否则会断开连接，无论是WIFI还是USB网络界面。</p>
<p>需要的电脑上的工具一个是WinSCP，使用WinSCP可以方便地管理文件，而且可以保存密码免输入密码登录，也可以使用命令行窗口来管理，因为命令行工具不是很好用所以需要使用SSH来管理更方便。</p>
<p>这个工具直接用默认配置就可以，协议选SFTP就可以了，不过需要显示隐藏文件，点击右下角的已隐藏字样点一下，可以显示隐藏文件了。</p>
<p>另一个是SSH，很多人推荐Putty但是我觉得这个并不方便，可以直接用WindowsTerminal下powershell支持的ssh，使用命令ssh <a href="mailto:&#114;&#111;&#111;&#x74;&#64;&#x31;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#x2e;&#x33;&#49;&#46;&#x33;&#x39;">&#114;&#111;&#111;&#x74;&#64;&#x31;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#x2e;&#x33;&#49;&#46;&#x33;&#x39;</a> 即可，注意这个ip需要在机器内查看。</p>
<p>由于配置一些其他软件的时候经常使用SSH，可以通过生成密钥来免密码登录。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>如果已经生成过了（比如之前用过git必然配置过），就不要生成了。<br>会提示生成文件到 .ssh 目录下了。<br>然后把公钥id_rsa.pub放到reMarkable上的~&#x2F;.ssh下，然后这里注意这里除了用户目录不能对组有权限，.ssh以及以下的文件都不能对组有权限，否则不能登录，会报错<code>Permission denied (publickey,password)</code> 。<br>然后在.ssh目录下执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> id_rsa.pub &gt;&gt;authorized_keys</span><br></pre></td></tr></table></figure>

<p>就可以把公钥写进去了，然后id_rsa.pub可以删掉了（因为这是主机的公钥）。</p>
<h2 id="字体中文支持"><a href="#字体中文支持" class="headerlink" title="字体中文支持"></a>字体中文支持</h2><p>没有。</p>
<p>需要自己安装中文到字体目录下。<br>只需要在目录 <code>/home/root/.local/share/</code> 下新建一个fonts文件夹，然后把自己的字体放进去就可以了。可以通过fc-list命令来检查字体安装情况。</p>
<p>下面稍微解释一下。</p>
<p>由于remarkable预装的字体目录位于<code>/usr/share/fonts/ttf</code> 下，网上找到的方法大多直接使用WinSCP把字体拖到<code>/usr/share/fonts/</code> 。但是由于系统更新后，根目录并没有调整分区大小，但是内容变多了，于是，如果想使用大一点的字体包，很有可能装不下。对于这一点，<br>网上大多数方法都是复制字体到用户目录下建立软链接，但是实测不好使，而且同样会被系统更新推掉。</p>
<pre><code>在ssh中输入df -h即可查看磁盘使用情况。-h 是指用人方便看的方式显示。
</code></pre>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@reMarkable:~<span class="comment"># df -h</span></span><br><span class="line">Filesystem                Size      Used Available Use% Mounted on</span><br><span class="line">/dev/root               230.2M    221.8M         0 100% /</span><br><span class="line">devtmpfs                104.7M         0    104.7M   0% /dev</span><br><span class="line">tmpfs                   233.2M         0    233.2M   0% /dev/shm</span><br><span class="line">tmpfs                   233.2M    612.0K    232.6M   0% /run</span><br><span class="line">tmpfs                   233.2M         0    233.2M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs                   233.2M     12.0K    233.1M   0% /tmp</span><br><span class="line">tmpfs                   233.2M         0    233.2M   0% /var/volatile</span><br><span class="line">/dev/mmcblk1p1           19.0M     11.0M      8.0M  58% /var/lib/uboot</span><br><span class="line">/dev/mmcblk1p7            6.5G    696.5M      5.5G  11% /home</span><br></pre></td></tr></table></figure>

<p>可以看到这里系统空间只剩几个M了，只有超小的字体才能塞进去。</p>
<p>而且，把字体放到<code>/usr/share/fonts/</code> 下不是一个好办法，因为每次系统更新都会把字体更新掉，需要再次复制，只有放到用户目录下，系统更新才不会乱删。</p>
<p>为什么这样做就可以了？可以找到&#x2F;etc&#x2F;fonts&#x2F;fonts.conf，其中，有一段为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Font directory list --&gt;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&lt;dir&gt;/usr/share/fonts&lt;/dir&gt;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	&lt;dir prefix=&quot;xdg&quot;&gt;fonts&lt;/dir&gt;</span><br><span class="line">	&lt;!-- the following element will be removed in the future --&gt;</span><br><span class="line">	&lt;dir&gt;~/.fonts&lt;/dir&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里可以看到，官方系统中一开始就包含了&#x2F;usr&#x2F;share&#x2F;fonts 这个目录，现在这个目录已经塞不下了，而下面<code>&lt;dir prefix=&quot;xdg&quot;&gt;fonts&lt;/dir&gt;</code>中的前缀xdg表示这个目录遵循 XDG 标准命名规范。XDG(X Desktop Group)是一组开源标准,用于定义 Linux 桌面环境的基础目录和配置。<br>也就是这个的路径为 <code>~/.local/share/fonts</code> , 因此只需要在用户目录下的<code>.local/share/fonts</code>里面放字体就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@reMarkable:~# pwd</span><br><span class="line">/home/root</span><br><span class="line">root@reMarkable:~# cd .local/share/fonts</span><br></pre></td></tr></table></figure>
<p>然后用WinSCP复制即可，或者全部用WinSCP操作。然后输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart xochitl</span><br></pre></td></tr></table></figure>
<p>即可重启官方阅读器，这时候就可以看到中文已经可以正常显示了。</p>
<pre><code>xochitl就是官方阅读器的名称
</code></pre>
<p>同样，在&#x2F;root&#x2F;home&#x2F;下建立文件夹 .fonts , 然后复制字体到里面也可以。虽然提示了要废弃不过这是linux给出的提示，也许下次系统更新依然可用。当然你也可以自己编辑这个配置文件写入一个路径来存放字体，但是显然下次系统更新这个文件大概率被推掉，你写的内容就会没有了。</p>
<p>使用的字体可以是TrueType（ttf）, 也可以是OpenType（otf）, WOFF2应该也是可以的。直接放到设置的字体文件夹下就可以，也可以使用继续创建文件夹，不影响使用。</p>
<p>实际上还有更多的字体配置可以自己定义，在&#x2F;etc&#x2F;fonts&#x2F;下还有其他的对应的配置文件，有兴趣折腾可以看一下。<br>不过在官方原来的阅读器中并不是很好配置，这里直接推进去的中文字体只会有一个被这个阅读器选用，因为官方的app只启用了五种字体而且似乎是和官方字体一一对应的，我不知道直接替换字体能不能起到作用，但是不知道这个app是按照系统字体目录来的还是写死了只能用usr目录，如所以就懒得折腾了。</p>
<p>如果坚持要在 <code>/usr/share/fonts/</code>  下塞入字体，但是空间依然不够，可以尝试使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">journalctl --vacuum-size=1M</span><br></pre></td></tr></table></figure>
<p>–vacuum-size选项可以设置日志文件的最大限制大小,当日志 grows 到这个大小时,会自动删除旧的日志。<br>然后大概可以塞进去一个小一点的字体。</p>
<p><font color="#9bbb59">还要了解更多可以搜索linux下字体配置或者fontconfig，缩写也就是fc  。</font></p>
<p>更多提示：<br>&#x2F;usr&#x2F;share&#x2F;fontconfig&#x2F;conf.avail&#x2F;这个路径下有更详细的字体配置<br>&#x2F;etc&#x2F;fonts&#x2F;conf.d</p>
<h2 id="传输和同步"><a href="#传输和同步" class="headerlink" title="传输和同步"></a>传输和同步</h2><p>官方力推的方案是下载电脑的APP和手机APP, 可以实现“快速”的多端同步，甚至能在平板上画同时APP能显示投屏作为演示工具。<br>然而，然而，然而！它用的是谷歌的服务。这意味着，你必须会一门轻功才能让这个平板跟着你一起越过Block，简单的方法至少有两种，也可以尝试直接给这个平板安装应用程序来完成这个目标，不过似乎网上没有直接适配的，你带自己看一下如何在linux里面使用代理，例如CLASH。毕竟，国外哥们基本都用不着。</p>
<pre><code>如果你需要使用官方同步服务，只需要在官网[reMarkable • Home](https://my.remarkable.com/)生成pin，填写到reMarkable里面就好了，保持网络畅通。
</code></pre>
<p>好在除了这一种方法，官方另外提供了一种方法，通过USB来建立一个局域网来传输。</p>
<p>也可以在本地电脑使用命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl --form file=@file.pdf http://10.11.99.1/upload</span><br></pre></td></tr></table></figure>
<p>代替使用WEB网页传书。 不过这仍然需要开启USB的网络界面服务。<br>但是这个方法有个缺陷，超过70M的PDF文件传输不上去，只能使用官方的同步软件来同步。</p>
<pre><code>在国内首先要调整系统时间对应才能用，不过我买的时候店家已经弄好了。
</code></pre>
<p>之前有个哥们在知乎上发布了一个他自用的工具harecoffee，然而这哥们没开源而且他的网页也失效了，现在就找不到了。。。</p>
<p>目前找到一个现成的开源软件<a href="http://www.davisr.me/projects/rcu/">reMarkable Connection Utility (RCU) (davisr.me)</a>，可以直接用WIFI或者USB上传转换，支持新系统，走SSH，但是要12刀，买了之后还会给你源码你可以自由分发，似乎这是符合AGPLV3的。。。</p>
<pre><code>这是一个PyQT写的应用，用PyInstaller打包的。他的导出是直接使用自己取出目录下的文件然后渲染成PDF的，据说相比官方的导出更好。
</code></pre>
<p>有个项目参考了它：<br><a href="https://github.com/rschroll/rmrl">rschroll&#x2F;rmrl: Render reMarkable documents to PDF (github.com)</a><br>因此渲染这部分可以参考参考。</p>
<p>12刀对于我还是太贵了，如果你有兴趣可以发邮件给作者付费。既然是开源软件那么可能有人买了之后发出来，可惜菩萨太少了，只找到一个网站上分发了一份2021年的源代码：<br><a href="https://directory.fsf.org/wiki/ReMarkable_Connection_Utility_(RCU)">ReMarkable Connection Utility (RCU) - Free Software Directory (fsf.org)</a> 实际上还是挂在作者的服务器上的下载来的。由于强迫症我安装了python3.11,而pyside2目前似乎不支持python 3.11，因此没有打包成功，我懒得折腾了。</p>
<p>还有一些别的项目也做了类似的功能，然而随着系统更新可能已经挂了：<br><a href="https://github.com/bordaigorl/remy">bordaigorl&#x2F;remy: Remy, an online&amp;offline manager for the reMarkable tablet (github.com)</a><br>这个需要作为python模块安装。</p>
<p>另外还有一些需要在reMarkable上安装软件的方法，我们后面介绍。</p>
<p>这个工具实测可用：<br><a href="https://github.com/furesoft/Slithin">furesoft&#x2F;Slithin: A management application for the remarkable tablet (github.com)</a><br>可以管理模板，恢复自定义模板和图片设置。可以导入模板，可以导出PDF，可惜不能导入书籍。可以在微软store安装</p>
<p>不可用：<br><a href="https://github.com/bruot/pyrmexplorer">bruot&#x2F;pyrmexplorer: GUI explorer for Remarkable tablets (github.com)</a><br>太久没更新了必然挂了。</p>
<h2 id="笔记模板"><a href="#笔记模板" class="headerlink" title="笔记模板"></a>笔记模板</h2><p>由于官方app自带一个笔记功能，所以实际上可以导入笔记模板，它自带了不少网格，个人觉得够用，这里不折腾了，网上教程也很多。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="更改睡眠图片"><a href="#更改睡眠图片" class="headerlink" title="更改睡眠图片"></a>更改睡眠图片</h2><p>官方app的睡眠功能是显示一张图片同时停止大部分功能，顺便还能显示你填写的信息。<br>新建dpi为226分辨率为1404x1872的图保存为png就可以替换。<br>这个图片在 <code>/usr/share/remarkable</code>路径下的suspended.png，直接替换即可，保持名称一致。</p>
<h3 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h3><p>实际上这个睡眠只是应用停止运行，而不是linux睡眠，因此依然不耽误其他软件运行，同样，其他软件运行的时候，官方app在20分钟之后仍然会进入睡眠。</p>
<h2 id="阅读问题解决"><a href="#阅读问题解决" class="headerlink" title="阅读问题解决"></a>阅读问题解决</h2><p>由于官方APP的传书方法实际上是在 &#x2F;home&#x2F;root&#x2F;.local&#x2F;share&#x2F;remarkable&#x2F;xochitl 下生成对应的书籍文件，如果生成失败导致打不开，可以手动删除里面的文件，具体对应是哪个需要找一找。</p>
<h1 id="这就完了吗"><a href="#这就完了吗" class="headerlink" title="这就完了吗"></a>这就完了吗</h1><p>比较有意思的是，点开设置中的Help下的Copyrights and licenses，官方也贴出了自己的Github链接<a href="https://github.com/remarkable">reMarkable AS (github.com)</a>  他们给出了Linux内核，uboot等开源代码，同时<br>可以直接使用SSH登录，默认账户就是root. 密码则写在了Copyright and licenses页面的最下面。可以说官方是支持用户自己折腾的。</p>
<pre><code>低情商：官方系统不完善
</code></pre>
<p>实际上可以安装第三方阅读器获得更好的支持。甚至是安装更多APP,以及自己开发。</p>
<h2 id="KOReader"><a href="#KOReader" class="headerlink" title="KOReader"></a>KOReader</h2><blockquote>
<p>由于KOReader传书方便得多，我建议不需要做笔记的可以直接放到用户空间下用KOReader来读，要做笔记的上传到rM自带阅读器里面读。</p>
</blockquote>
<p>除了安装Toltec后使用包管理器，可以通过别的方法安装koreader，如官方方法直接安装：<br><a href="https://github.com/koreader/koreader/wiki/Installation-on-Remarkable">Installation on ReMarkable · koreader&#x2F;koreader Wiki (github.com)</a></p>
<p>要就是两个服务文件，一个是主进程再一个监听按键事件的进程，装好后直接长按中键几秒就可以启动了，很方便。</p>
<p>不过它没教怎么返回原来的阅读器，这个应该需要第三方启动器了。</p>
<p>按下中键三秒唤处koreader</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /home/root/koreader/button-listen.service /etc/systemd/system/</span><br><span class="line">systemctl <span class="built_in">enable</span> --now button-listen</span><br></pre></td></tr></table></figure>

<p>但是，这里不使用这个按键唤起koreader，因为按了就切不回去，这里安装一个启动器来切换</p>
<p>如果你希望启动开机启动koreader而不是xochitl，那么使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl disable --now xochitl &amp;&amp; systemctl enable --now koreader</span><br></pre></td></tr></table></figure>
<p>我觉得这个是不是要修改服务文件里面的after xochitl，因为实测这个不能阻止xochitl启动，但是remux反而不能启动了。修改remux启动文件中的After&#x3D;xochitl可以用来防止remux不能启动，但是似乎并不稳定，所以就不这样做了。</p>
<p>koreader也可以直接阅读在rMapp中导入的书籍，但是由于位于隐藏文件夹，所以需要打开显示隐藏文件夹，目标文件夹到文件夹快捷目录中</p>
<p>其实KOReader本身支持Linux（废话），所以你完全可以用作自己的Linux的阅读器。<br>这个开源软件发展了很久，功能十分强大，这里调几个reMarkable官方阅读器里面的痛点来说。</p>
<p>0、文件支持<br>支持<br>而且不会生成一堆奇怪的文件来支持显示文件。<br>具有文件管理器可以直接翻阅文件系统。</p>
<h3 id="1、字体"><a href="#1、字体" class="headerlink" title="1、字体"></a>1、字体</h3><p>更换字体是十分方便的，在路径 koreader&#x2F;fonts下放入下载的字体，点选字体设置的时候翻到第一页就会显示新导入的字体并且显示new的字样。可以迅速调整。而xochitl则需要很久重新生成一个PDF。</p>
<p>2、对比度可调<br>KOReader本身会自动设置一个，但是如果有的扫描文件不合适，那么可以手动调整</p>
<h2 id="REMUX"><a href="#REMUX" class="headerlink" title="REMUX"></a>REMUX</h2><p>这是一个极简GUI启动器,可以用来管理切换到其他的APP。<br>按照官网提示<a href="https://rmkit.dev/apps/remux">remux launcher (rmkit.dev)</a><br>下载remux和remux.service两个文件，然后把remux放到&#x2F;opt&#x2F;bin&#x2F;下，也就是路径是&#x2F;opt&#x2F;bin&#x2F;remux ， 这里只有两层目录。<br>然后<font color="#ff0000">chmod</font> &#x2F;opt&#x2F;bin&#x2F;remux 777, 这个是官网没说的。（其实700就行）<br>然后把remux.service放到&#x2F;etc&#x2F;systemd&#x2F;system下，<br>最后</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now remux</span><br></pre></td></tr></table></figure>

<p>最后，可以用按住中键呼出启动器或者侧边向上滑动（幅度大点）。<br>点击应用名称可以切换，点击后面显示的使用内存大小可以关闭应用。</p>
<p>然而，&#x2F;opt&#x2F;这个目录是在根目录下的，很可能由于系统更新或者救砖操作被推掉，因此稍微做一点修改。<br>移动remux这个可执行文件到~&#x2F;下，也就是&#x2F;home&#x2F;root，然后修改remux.service中的原来的路径 &#x2F;opt&#x2F;bin&#x2F;remux 到&#x2F;home&#x2F;root&#x2F;remux，其中的After修改为：<br>After&#x3D;xochitl.service home.mount</p>
<p>如果前面已经安装过一次remux了，那么首先使用：<br>systemctl disable remux来移除服务，然后重新启用。<br>systemctl enable –now remux</p>
<p>最后，~&#x2F;.config&#x2F;remux&#x2F;remux.conf可以编辑启用方式，例如可以使用在屏幕下方三点点击来启动remux</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launch_gesture=gesture=tap;fingers=3</span><br></pre></td></tr></table></figure>
<p>不过这样有时候会卡住，只需要四指滑动就可以重启remux了。不过我还是习惯直接用<br>或者点一下屏幕然后手指扫屏幕<br>有三种方式来添加应用，这里最简单的就是把应用放在&#x2F;home&#x2F;root&#x2F;apps下面<br>然后重启remux即可</p>
<p>或者重新编译手工加入<br>或者- compatible with draft-remarkable config files</p>
<p>预先写好在源码里面的有<br>koreader<br>fingerterm<br>keywriter<br>edit</p>
<p>官网的readme补全，需要看源码里面的readme</p>
<p>如何编译：<br>run <code>make remux</code> from the root dir of rmkit to build it. then run <code>make install_remux</code> to copy remux to the remarkable. Run <code>make run_remux</code> to run remux.</p>
<p>Finally, if you want to make the installation permanent, change into the<br><code>src/remux</code> directory and run <code>make install_service</code> followed by <code>make start_service</code></p>
<p>add <code>dialog_height</code> and <code>dialog_width</code> option to remux.conf for specifying<br>the dialog width and heigght. Default is 600x800. The rM width is 1404,<br>height is 1872.</p>
<ul>
<li>add <code>filter_palm_events</code> option to remux.conf to prevent spurious palm<br>touches. Enable this is you have a custom gesture (like 3 or 4 finger) and<br>keep accidentally launching remux.</li>
</ul>
<p>added <code>start_app=</code> option to specify the app to launch. it can be blank or an<br>app name as seen in the list of apps. if the app isn’t found or its blank, no app<br>will launch at startup and remux will require a gesture to be invoked.</p>
<p>added <code>manage_power=</code> boolean option to configuration. setting to <code>false</code> or <code>no</code> tells remux to not enter suspend mode automatically - this lets you use xochitl solely for power management. useful if remux is messing up drawing your suspend screen</p>
<p>As of remux 0.1.7, remux supports configuration kept in <code>/home/root/.config/remux/remux.conf</code>. The configuration is kept as key&#x3D;value lines. As of right now, the two main config options are <code>launch_gesture</code> and <code>back_gesture</code>. They can be used to configure the gestures in remux. The format is the same as genie, except semi-colons (<code>;</code>) are used to separate directives instead of newlines.</p>
<p>For example, the below will show remux when three fingers are tapped and switch<br>to last app on a four finger tap.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">launch_gesture=gesture=tap;fingers=3</span><br><span class="line">back_gesture=gesture=tap;fingers=4</span><br></pre></td></tr></table></figure>

<p>You can repeat a key in order to setup multiple gestures for the same action, like so:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">launch_gesture=gesture=tap;fingers=3</span><br><span class="line">launch_gesture=gesture=tap;fingers=4</span><br></pre></td></tr></table></figure>
<p>如果找不到应用，一定记得chmod</p>
<h2 id="rmkit"><a href="#rmkit" class="headerlink" title="rmkit"></a>rmkit</h2><p>下面的软件都是rmkit中的，编译或者自己编写都可以参考他的源码中附带的文档。<br>下载已经编译好的也可以直接从这里下载：<br><a href="https://build.rmkit.dev/master/latest/rm/">Index of &#x2F;master&#x2F;latest&#x2F;rm&#x2F; (rmkit.dev)</a><br>里面的<a href="https://build.rmkit.dev/master/latest/rm/release.tar.gz">release.tar.gz</a>包含了所有编译好的可执行文件。<br>注意每个可执行文件放到~&#x2F;apps下的时候都要使用chmod +x来给予执行权限。<br>可以全部放进入之后再apps目录下使用chmod +x * 来全部基于权限，使用ls -l来检查是否到伪。<br>安装之后如果重新唤出remux没有显示安装的软件，那么使用systemctl restart remux来刷新启动器列表</p>
<h3 id="harmony"><a href="#harmony" class="headerlink" title="harmony"></a>harmony</h3><p>这是一个绘画软件 他是说是低延迟<br>直接在ssh中启动会存在问题，会触发下层当前正在使用的app，所以需要加入到remux的apps中来防止下层应用被触发。<br>编译参考rmkit&#x2F;doc下的指南</p>
<p>如果你乐意你可以为他写一个harmony.service:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Harmony</span><br><span class="line">After=xochitl.service home.mount</span><br><span class="line">Conflicts=xochitl.service</span><br><span class="line">OnFailure=xochitl.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/root/home/apps/harmony</span><br><span class="line">Restart=no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>iago</p>
<ul>
<li>then configure ddvk’s touch injector or genie to launch iago when a gesture is performed.</li>
</ul>
<p>这个软件可以插入图形，例如笔记中，可以使用贝塞尔曲线，但是不能使用remux来启动，因为remux会禁用其他应用。所以这里只是记录一下，懒得折腾手势。</p>
<h3 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h3><h3 id="小游戏"><a href="#小游戏" class="headerlink" title="小游戏"></a>小游戏</h3><p>有三个。<br>扫雷<br>：都懂<br>填词<br>：Wordle游戏的规则非常简单，它要求玩家在6次之内猜出一个由5个字母组成的单词。每次输入单词时，如果输入的字母在目标单词中，但是位置不对，那么格子会显示成黄色（浅灰色）；如果输入的字母在目标单词中，且位置正确，那么格子会显示成绿色（深灰色）；如果都不对，则会显示成灰色（打叉）。</p>
<p>实测LLM AI可以玩。</p>
<p>地牢爬行纸牌游戏？<br>：Dumbskull is a dungeon crawl themed solitaire based on <a href="https://100r.co/site/donsol.html">Donsol</a> and <a href="http://stfj.net/index2.php?project=art/2011/Scoundrel.pdf">Scoundrel</a>.</p>
<p>经典DOOM<br><a href="https://github.com/LinusCDE/doomarkable">LinusCDE&#x2F;doomarkable: DOOM on the reMarkable (github.com)</a></p>
<p>需要下载DOOM游戏文件放在&#x2F;home&#x2F;root里面<br>doom.wad、doom2.wad、tnt.wad、plutonia.wad</p>
<p>俄罗斯方块：<br><a href="https://github.com/LinusCDE/retris">LinusCDE&#x2F;retris: Implementation of rust tetris_core on the reMarkable using libremarkable (github.com)</a></p>
<h3 id="其他没什么鸟用的程序"><a href="#其他没什么鸟用的程序" class="headerlink" title="其他没什么鸟用的程序"></a>其他没什么鸟用的程序</h3><p>这些大概是例程顺带编译出来的。</p>
<p>eclear 清屏，但是并不能重绘，而且也清不干净。<br>sharenote 没看明白</p>
<h2 id="开启其他同步方法"><a href="#开启其他同步方法" class="headerlink" title="开启其他同步方法"></a>开启其他同步方法</h2><p>✔由于原来的USB界面仍然是开启了一个以太网用来上传书籍但是每次都要插上USB线很不方便，这里有个项目不需要插USB,只需要同一个网络环境下；<br><a href="https://github.com/rM-self-serve/webinterface-wifi">rM-self-serve&#x2F;webinterface-wifi: View the web interface over wifi. For the ReMarkable Tablet. (github.com)</a></p>
<p>如果没有toltec, 用这个安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/rM-self-serve/webinterface-wifi/master/install-webint-wf.sh &amp;&amp; bash install-webint-wf.sh</span><br></pre></td></tr></table></figure>
<p>用这个卸载：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ wget https://raw.githubusercontent.com/rM-self-serve/webinterface-wifi/master/remove-webint-wf.sh &amp;&amp; bash remove-webint-wf.sh</span><br></pre></td></tr></table></figure>

<p>启动用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now webinterface-wifi</span><br></pre></td></tr></table></figure>
<p>停用用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> --now webinterface-wifi</span><br></pre></td></tr></table></figure>

<p>可以用但是似乎配置了Koreader之后或者用了别的管理工具之后没啥太大必要了。</p>
<h3 id="Syncthing的方法："><a href="#Syncthing的方法：" class="headerlink" title="Syncthing的方法："></a>Syncthing的方法：</h3><p><a href="https://github.com/evidlo/remarkable_syncthing">Evidlo&#x2F;remarkable_syncthing: Self-hosting syncing solution for reMarkable (github.com)</a><br>这个方法确实可以但是还是要自己解析pdf上传过去。</p>
<p>还有串流，当作写字板等功能可以通过安装应用来</p>
<p>你甚至可以安装 .NET ：<br><a href="https://www.hanselman.com/blog/how-to-install-net-core-on-your-remarkable-2-eink-tablet-with-remarkablenet">How to install .NET Core on your Remarkable 2 e-Ink tablet with Remarkable.NET - Scott Hanselman’s Blog</a></p>
<p>更多参考：<br><a href="https://www.libhunt.com/r/awesome-reMarkable">awesome-reMarkable Alternatives and Reviews (Jun 2023) (libhunt.com)</a></p>
<p>低层管理工具：</p>
<p>如何自己写一个可以在reMarkable上用的应用：<br><a href="https://eeems.website/writing-a-simple-oxide-application/">Writing a Simple reMarkable application (eeems.website)</a></p>
<p>实际上密码被记录在<br>&#x2F;home&#x2F;root&#x2F;.config&#x2F;remarkable&#x2F;xochitl.conf</p>
<p>我不知道修改这个看起来是配置文件的东西能不能修改密码，所以我就不折腾了避免变砖。。</p>
<p>如果不想使用官方的同步服务, 因为每次启动没网都会跳出来，而且费电，可以通过命令关掉：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> rm-sync</span><br></pre></td></tr></table></figure>
<p>同样，可以使用enable来打开。<br>同时，去掉&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;xochitl.service 中的Wants<br>Wants&#x3D;rm-sync.service 避免开机启动</p>
<p>去掉了xochitl.service中的watchdog 防止使用别的应用的时候意外自启动。。</p>
<h1 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h1><p>模拟键盘：<a href="https://github.com/Evidlo/remarkable_keyboard">Evidlo&#x2F;remarkable_keyboard: Use a reMarkable tablet as a wireless mouse and keyboard (github.com)</a></p>
<h2 id="模拟鼠标："><a href="#模拟鼠标：" class="headerlink" title="模拟鼠标："></a>模拟鼠标：</h2><p><a href="https://github.com/Evidlo/remarkable_keyboard">Evidlo&#x2F;remarkable_keyboard: Use a reMarkable tablet as a wireless mouse and keyboard (github.com)</a><br>模拟鼠标我认为更实用，因为键盘还要先有个键盘打开程序。。模拟鼠标主要是可以当作数位板。<br>在linux上延迟远低于windows。<br>在Manjaro上使用 pipx install remarkable-mouse来安装<br>测试opensuse和fedora安装有点问题，有点折腾<br>在fedora上首先需要安装python开发环境。yum install python3.11-devel<br>opensuse一样要先安装环境: zypper install python311-devel<br>由于这俩的权限管理有点不一样，所以不要使用sudo，用普通用户级别即可，否则会提示找不到，因为没有为root用户安装。<br>最新的ubuntu也需要使用虚拟环境安装了，需要自己配置一下虚拟环境（用pipx按照提示来就行），使用正常</p>
<h2 id="好用但是不可用的应用"><a href="#好用但是不可用的应用" class="headerlink" title="好用但是不可用的应用"></a>好用但是不可用的应用</h2><p>上位机<br><a href="https://github.com/bruot/pyrmexplorer">Releases · bruot&#x2F;pyrmexplorer (github.com)</a><br>这个现在压根打不开。</p>
<h3 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h3><p><a href="https://github.com/dixonary/draft-reMarkable">dixonary&#x2F;draft-reMarkable: A launcher for the reMarkable tablet, which wraps around the standard interface. (github.com)</a><br>三年没更新了我不知道它能不能用了。<br>不过remux兼容它的配置文件加入应用到启动列表因此可以参考以下配置文件写法。</p>
<h4 id="Oxide"><a href="#Oxide" class="headerlink" title="Oxide"></a>Oxide</h4><p><a href="https://github.com/Eeems-Org/oxide">Eeems-Org&#x2F;oxide: A desktop environment for the reMarkable tablet (github.com)</a><br>更高级的启动器，但是会修改启动文件，变砖概率变高，最重要的是，需要使用<a href="https://toltec-dev.org/#install-toltec">toltec</a>来完成安装，目前系统上toltec会让系统变砖，就算了。有人反馈会变砖。</p>
<h4 id="draft"><a href="#draft" class="headerlink" title="draft"></a>draft</h4><p><a href="https://github.com/dixonary/draft-reMarkable">dixonary&#x2F;draft-reMarkable: A launcher for the reMarkable tablet, which wraps around the standard interface. (github.com)</a></p>
<h2 id="Toltec"><a href="#Toltec" class="headerlink" title="Toltec"></a>Toltec</h2><p><a href="https://toltec-dev.org/">Toltec (toltec-dev.org)</a> 。<br>官网说Toltec不支持2.15以后的系统，不过网友说这是rM2才有的问题，rM1依然可以在3.XX上用，而且更稳定，但是toltec只支持最高3.2.2.1581和 3.2.3.1595.。同时，官网的Q&amp;A指出：</p>
<pre><code>Will this brick my reMarkable?
Probably not, but standard disclaimers apply
</code></pre>
<p>然而在3.5版本系统上实测会变砖。。。。安装之后会报错，不会立马变砖，仍然可以通过删除安装的文件来撤销操作，然而我好奇重启会不会变砖，只能说求仁得仁了，果然启动不了了，WiFi USB界面自然也不能用。救砖操作见本文 救砖和刷机 章节。</p>
<p>这是一个用于reMarkable的包管理器，<br>安装很简单：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://toltec-dev.org/bootstrap</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;04a28483286f88c5c7f39e352afb62adc57f6162a29fd7e124d832205bb0980e  bootstrap&quot;</span> | <span class="built_in">sha256sum</span> -c &amp;&amp; bash bootstrap</span><br></pre></td></tr></table></figure>
<p>然后可以使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">opkg update</span><br><span class="line">opkg upgrade</span><br><span class="line">opkg install &lt;package&gt;</span><br><span class="line">opkg remove &lt;package&gt;</span><br><span class="line">opkg info &lt;package&gt;</span><br></pre></td></tr></table></figure>
<p>来管理软件包。<br>安装 <strong>nao</strong> 这个软件可以图形化管理。</p>
<p>对应的包列表：<br><a href="https://bin.entware.net/armv7sf-k3.2/Packages.html">Packages list (entware.net)</a><br><a href="https://toltec-dev.org/stable/#section-launchers">Toltec Package Listing (toltec-dev.org)</a></p>
<p>这里面有些软件是可以手动安装的。不过有些软件也是过时的。</p>
<p>yeft<br>一个通用的终端模拟器，但是需要toltec安装，否则你就得自己编译了<br><a href="https://github.com/uobikiemukot/yaft">uobikiemukot&#x2F;yaft: yet another framebuffer terminal (github.com)</a></p>
<p><a href="https://github.com/ddvk/remarkable-hacks">ddvk&#x2F;remarkable-hacks: additional functionality via binary patching (github.com)</a><br>这个支持的版本太老了，不过那些手势也可以用别的软件想办法支持了。</p>
<p>浏览器<br><a href="https://github.com/alex0809/netsurf-reMarkable/tree/main">alex0809&#x2F;netsurf-reMarkable: NetSurf is a lightweight and portable open-source web browser. This projects adapts NetSurf for the reMarkable E Ink tablet. (github.com)</a></p>
<p>手动安装太麻烦了，还是等Toltec吧</p>
<p><a href="https://github.com/irth/rmgem">irth&#x2F;rmgem: simple gemini browser for reMarkable (github.com)</a><br>这个只是在rmkit中指出，没有现成可执行文件，在Toltec中也没有。需要下载go后自己编译。<br>由于make在Windows下不方便用，俺就拿出了我的manjaro的笔记本编译了一下。</p>
<p>这个工具实际上是<a href="https://gemini.circumlunar.space/">Project Gemini (circumlunar.space)</a>的rM版 没什么用，而且，命令行下有回显，但是没有GUI?</p>
<h3 id="支持markdown的文本编辑器"><a href="#支持markdown的文本编辑器" class="headerlink" title="支持markdown的文本编辑器"></a>支持markdown的文本编辑器</h3><p>使用键盘编辑：<a href="https://github.com/dps/remarkable-keywriter/tree/master">dps&#x2F;remarkable-keywriter (github.com)</a><br>然而实测不能用，太老了。</p>
<h2 id="不好用或者太老没测试"><a href="#不好用或者太老没测试" class="headerlink" title="不好用或者太老没测试"></a>不好用或者太老没测试</h2><p>另一个阅读器：<br><a href="https://github.com/LinusCDE/plato">LinusCDE&#x2F;plato: Document reader (github.com)</a><br>看起来没有必要使用，支持的格式不多，文档远不如KOReader</p>
<p>whiteboard<br>除了能显示笔迹啥都没有？？而且还有bug. 作者只是用了他的git保存了一堆链接。不要用.<br>这个软件还有10.6M,大概是做了功能但是现在有bug启动不了？<br><a href="https://github.com/reHackable/Calculator">reHackable&#x2F;Calculator: A primitive calculator for the reMarkable (early alpha) (github.com)</a><br>计算器，只有简单功能，而且上次更新六年前。</p>
<h1 id="救砖和刷机"><a href="#救砖和刷机" class="headerlink" title="救砖和刷机"></a>救砖和刷机</h1><p>救砖适用于：启动不了，密码重置以及其他一切可以通过进系统改配置来解决的问题。<br>直接刷机：上面解决不了的问题或者你就是觉得重刷更好就刷机到旧系统。</p>
<p>下载<a href="https://github.com/ddvk/remarkable-uuuflash">ddvk&#x2F;remarkable-uuuflash: uuu scripts for recovery console and flashing (github.com)</a><br>用来救砖和刷机。<br>uuuflash是一个nxp的刷机工具。<br>关机状态下连接到USB，Win10会提示安装了新的硬件（好像是SE Blank 6ULL），不过由于是HID设备所以在设备管理器里面不容易找到，但是这个不重要。然后长按3秒进入上传模式，如果是开机下进入上传模式，这时候reMarkable会停止反复重启，如果本来就是关机的，那就没啥提示，但是总之你是可以接下来继续刷机或者救砖了。</p>
<h2 id="救砖"><a href="#救砖" class="headerlink" title="救砖"></a>救砖</h2><p>救砖就是尝试解决问题而不是直接刷机一了百了。</p>
<p>进入下载uuuflash的目录，执行下面的命令，由于使用HID传输，所以很慢，等着就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS ...\remarkable-uuuflash&gt; ./uuu recover.uuu</span><br><span class="line">uuu (Universal Update Utility) for nxp imx chips -- libuuu_1.3.154-0-g47ddef5</span><br><span class="line"></span><br><span class="line">Success 1    Failure 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2:11     5/ 5 [Done                                  ] SDP: done</span><br></pre></td></tr></table></figure>

<p>传输完成之后Windows会提示安装了一个新硬件：CDC Composite Gadget，这个一看就知道是串口，但是Windows对于这种设备需要一个inf文件来安装驱动，不过没关系，也可以手动指定这个设备为串口设备。<br>在设备管理器中右键这个设备，由于有个感叹号很好找到：</p>
<ul>
<li>点更新驱动</li>
<li>浏览我的电脑以更新驱动</li>
<li>选择“端口(COM &amp; LPT)”</li>
<li>然后在左侧的厂商列表中选Microsoft，右侧列表中选”USB串行设备“</li>
<li>下一步就安装成串口设备了</li>
</ul>
<p>然后理论上说可以用Putty连接，波特率随便，因为这是一个虚拟串口。但是不知道为什么Putty连接不上，我这里就用了串口调试助手，这个不是交互式的，但是能用。</p>
<p>首先注意调整发送接收都是ASCII模式。</p>
<p>然后发送root即可登录，不需要密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rmrestore login: root</span><br><span class="line">root@rmrestore:/<span class="comment"># ls</span></span><br><span class="line">bin             lib             proc            uboot-postinst</span><br><span class="line">boot            lost+found      run             uboot-version</span><br><span class="line">dev             media           sbin            usr</span><br><span class="line">etc             mnt             sys             var</span><br><span class="line">home            postinst        tmp</span><br></pre></td></tr></table></figure>

<p>然后首先什么都看不见因为需要挂载存储设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/mmcblk1p2 /mnt/</span><br><span class="line">mount /dev/mmcblk1p7 /mnt/home</span><br><span class="line">mount /dev/mmcblk1p1 /mnt/var/lib/uboot</span><br></pre></td></tr></table></figure>
<p>然后可以通过chroot进入原来的系统，因为你现在的操作是删掉让系统变砖的配置文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /mnt</span><br></pre></td></tr></table></figure>
<p>现在就和在系统里面的文件环境一样了。</p>
<p>由于我这里变砖是因为安装了Toltec，所以按照它的提示，只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> /etc/systemd/system/xochitl.service.d/toltec-wrapper.conf</span><br></pre></td></tr></table></figure>
<p>对于重置密码同样可以在chroot环境里面操作。</p>
<p>然后就可以退出chroot了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span> <span class="comment">#if you used the chroot</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>执行的时候会显示：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@rmrestore:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">root@rmrestore:/<span class="comment"># </span></span><br><span class="line">root@rmrestore:/<span class="comment"># reboot</span></span><br><span class="line">↓</span><br><span class="line">Broadcast message from root@rmrestore (ttyGS0) (Thu Jul 20 13:09:15 2023):</span><br><span class="line"></span><br><span class="line">The system is going down <span class="keyword">for</span> reboot NOW!</span><br><span class="line">root@rmrestore:/<span class="comment"># </span></span><br><span class="line">root@rmrestore:/<span class="comment"># logout</span></span><br></pre></td></tr></table></figure>
<p>现在系统就重启了，你会发现你的配置基本都没有丢，也就是不用重置系统。但是位于自己新建的&#x2F;opt目录下的应用丢了，因为&#x2F;opt这个目录没了。同样系统更新也可能导致这个目录被删掉。</p>
<p>这也是为什么我不太推荐用Toltec来安装，因为手动安装更容易修改安装位置。<br>然后可以根据Toltec安装日志可以删掉它建立的几个符号链接，虽然不删也行但是看着有点不爽。但是如果你十分不爽，可以使用下面的刷机的方式。</p>
<h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>如果你压根不知道修改了什么导致起不来，也找不到原因和日志，或者你就想刷个干净的系统，可以尝试直接刷机：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./uuu upgrade.uuu</span><br></pre></td></tr></table></figure>
<p>这个会把系统root恢复到2.1.1.3. 理论上来说这时候已经可以开机了。</p>
<p>如果问题还是存在或者还还是上述理由，那么继续：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./uuu reflash.uuu</span><br></pre></td></tr></table></figure>
<p>这个命令会把什么都删掉。这下问题彻底解决了。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="https://github.com/torwag/remarkableflash">torwag&#x2F;remarkableflash (github.com)</a><br>上面这个工具依然可用，不过还是使用uuu更好。</p>
<h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><p><a href="http://www.davisr.me/projects/parabola-rm/#:~:text=Parabola-rM%20Parabola-rM%20%28PRM%29%20turns%20a%20reMarkable%20e-paper%20tablet,may%20do%20with%20an%20ordinary%20graphical%20operating%20system.">Parabola-rM (davisr.me)</a><br>这个还是开发RCU那个老哥的操作，直接写了个系统可以用在rM1上。可以处理文档、电子表格等等操作，因为就是一个正常的系统。就是用不了WiFi</p>
<h1 id="自己开发"><a href="#自己开发" class="headerlink" title="自己开发"></a>自己开发</h1><p><a href="https://remarkablewiki.com/devel/toolchain">remarkabletoolchain</a><br>本来是挂在remakeablewiki上的，可惜这个网站挂了。。<br>rmkit还是可以用它的例程来开发的。<br><a href="https://rmkit.dev/eink-dev-notes/">howto: e-ink dev notes (rmkit.dev)</a></p>
<h2 id="硬件参考"><a href="#硬件参考" class="headerlink" title="硬件参考"></a>硬件参考</h2><p>使用的是i.MX6SL (SoloLite) 800 MHz ARMv7处理器，可以参考别人给的说明：<br><a href="http://www.davisr.me/projects/parabola-rm/install-guide-latest.pdf">Parabola on reMarkable: A Guide (davisr.me)</a></p>
<h2 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h2><p><a href="https://stackoverflow.com/questions/57811916/emulating-the-remarkable-tablet-i-mx6-armv7-with-qemu">arm - emulating the reMarkable tablet (i.MX6 ARMv7) with Qemu - Stack Overflow</a><br>实际上rmkit里面提供了模拟器的说明。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://szclsya.me/zh-cn/posts/fonts/linux-config-guide/">https://szclsya.me/zh-cn/posts/fonts/linux-config-guide/</a><br><a href="https://wiki.archlinux.org/title/Font_configuration">Font configuration - ArchWiki (archlinux.org)</a><br><a href="https://www.bilibili.com/video/BV1Gv4y1f7ou/?vd_source=2c02778bfce8b5de28136fd3deba43ef">https://www.bilibili.com/video/BV1Gv4y1f7ou/?vd_source=2c02778bfce8b5de28136fd3deba43ef</a><br><a href="https://qzxx.com/82977.html">折腾前必看–Remarkable Paper Tablet 1代10.3寸电子书墨水屏 素描本 常见问题收集-青州小熊 (qzxx.com)</a><br>实际上以前还有一个remarkablewiki.com的网站，现在似乎已经挂了。<br>reddit频道：<a href="https://www.reddit.com/r/RemarkableTablet/">(1) reMarkable (reddit.com)</a></p>
<p><a href="http://www.davisr.me/">Davis Remmel’s Home Page</a><br>这个人做了很多工作<br>github合集：<a href="https://github.com/topics/remarkable-tablet">remarkable-tablet · GitHub Topics</a></p>
]]></content>
      <categories>
        <category>生活游玩</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>捡垃圾</tag>
      </tags>
  </entry>
  <entry>
    <title>WinUSB上位机的开发</title>
    <url>/2023/06/25/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/WinUSB%E4%B8%8A%E4%BD%8D%E6%9C%BA%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>这篇文章是对WinUSB上位机开发的一个具体总结日志。详细的其他知识笔记分开来写。</p>
<span id="more"></span>

<p>起因是当时脑子一热准备给抽奖中的HPI1000重新编程开发，经过一两个月的磨蹭把下位机部分软件写差不多了，需要上位机联调了，同时也准备一同开发HPI1000对应的上位机。</p>
<p>TivaWare中附带了一个C语言写的命令行的Windows上位机，改一改也能用，但是用起来不是很方便。而且由于QT忘记差不多了，一开始我是不打算使用QT的。所以下面会先说说我挑选开发工具的过程。</p>
<h1 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h1><p>HPI1000主要是具有一个虚拟示波器，由于之前用QT写虚拟示波器的时候感觉痛苦万分，这次想要舍弃这个框架，而且QT整了不少活儿，开源闭源的问题让人很不爽，所以开始寻找其他的图形框架。</p>
<p>然后就找到了Godot。这是一个小型游戏引擎，Godot 3.5总共也才三十多M，QT打包之后还真不一定比这个小，因此完全可以考虑。但是编程的时候遇到了问题。<br>作为一个开源软件，Godot发展并不是特别好，所以很多组件是没有的。例如Windows下串口的访问，USB的访问，如果使用它自己的GDscript，这些组件都需要自己使用C&#x2F;C++来实现。</p>
<p>起初我是不想去用C&#x2F;C++的，因为需要包含WindowsDDK才能继续开发这个驱动，我以为WinUSB有更优雅的访问方式（而且我以为很难）。<br>好在Godot同时也支持使用C#来编程，这样可以任意引入其他.net的包，然而我太天真了。<br>因为虽然.net原生支持串口访问，但是我没想到.NET作为微软的儿子，WinUSB在.NET中的使用仍然不简单（一开始我以为根本就没有.NET的支持）<br>不死心的我决定找找有没有第三方包，结果是有，但是不好用。。。比如LIBUSB，然而需要额外安装libusb的驱动。。这就违背了我的初衷：希望设备是免驱的。</p>
<p>在.net应用中使用C&#x2F;C++方法也不是没有，那就是引入DLL. DLL这不是有现成的嘛，TivaWare中的那个DLL就可以使用。然而这是个大坑，不仅有指针的问题，还有DLL编译的时候和原编译器位数有关的问题，也就是说有可能这个DLL本身我还要重新编译一次。</p>
<p>那我还不如直接重新写。</p>
<p>上面的问题我另外写了具体的USB框架的选择，这里不再细说，总之就是当我决心使用C#的时候，发现事情最后都指向了使用C&#x2F;C++老老实实调用WinUSB API来写。</p>
<pre><code>一开始我以为WinUSB API的调用会很麻烦，资料找起来也费劲，微软的资料看不大明白。。。后来才发现非常简单。
</code></pre>
<p>当我打开TivaWare的 lmusbdll 的source code，我发现这似乎就是简单封装了一下WinUSB API….参考别人的QT的winUSB demo,我发现两者好像没有什么区别。。。</p>
<p>所以最终决定直接使用QT来写。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>添加依赖库。<br>在.pro中添加SetupAPI 和winusb，用来给后面调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 手动添加库</span><br><span class="line">win32: LIBS += -lSetupAPI </span><br><span class="line">win32: LIBS += -lwinusb</span><br></pre></td></tr></table></figure>

<p>复制粘贴lmusb<br>去掉用不上的部分，把函数全部复制过来，去掉原来的导出的声明，直接改成普通函数。<br>添加一个速度查询的函数。</p>
<p>添加WinUSBdevice设备类<br>方便承载原来的全局变量。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>添加一个线程用来循环读取USB设备，防止主界面卡死。</p>
<p>TODO</p>
<p>目前的结果是写的还是有些问题，数据量稍微大一点界面就会卡住，虽然如果不刷新界面只是保留数据没有问题。</p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
  </entry>
  <entry>
    <title>长白山行简记</title>
    <url>/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/</url>
    <content><![CDATA[<p>6月初拿到驾照之后，突然想出去玩玩了，然后看了下时间，准备赶在高考结束之前完成这个计划。<br>很久之前就想去的长白山看看，不过看的攻略都感觉很模糊，早些年也感觉没有什么时间，我比较喜欢一板一眼的东西，最好是都能提取决定好的，而网上的攻略大都说不清时间地点而且大部分比较片面，于是一直没有什么动力走这个计划。<br>这一次决定直接梭哈，简单看了一下去的方式，就订了机票准备出发。</p>
<span id="more"></span>

<hr>
<h2 id="放在前面说的流水账总结"><a href="#放在前面说的流水账总结" class="headerlink" title="放在前面说的流水账总结"></a>放在前面说的流水账总结</h2><p>流水账总结放在前面，因为不是很重要但是可以单独拿出来理清楚前后时间，后面有什么想记录的再单独强调。</p>
<h2 id="我的路线总结"><a href="#我的路线总结" class="headerlink" title="我的路线总结"></a>我的路线总结</h2><p>武汉-天津 1day-长白山机场-打车到池西区集散中心住宿-睡觉-八点起床-九点半上山-下午四点回来-睡觉-五点起床-八点半大巴-寄存行李上北坡-四点半下山-延吉-睡觉-动车到长春龙嘉火车站休息，龙嘉机场飞回家。</p>
<h3 id="1-去程"><a href="#1-去程" class="headerlink" title="1. 去程"></a>1. 去程</h3><p>武汉到长白山有好几种方式，但是都没有直达。我提前四天订好了机票。带了一个背包装了冲锋衣，还有其他衣服，充电宝什么的。</p>
<p>从武汉天河机场出发，到天津滨海机场，机票为16：05-18：10，实际吃完中饭十二点多就从家里出发了，这里大约可以再压缩一个小时出来，不过意义不大。原计划是在天津住一晚上后等第二天早上十点的飞机，不过出发前两天提示次日从天津飞往白山的航班取消，遂被推迟到了第二天，中间多出来的一天就临时计划在天津玩。</p>
<p>我到达天津的时候是周一，滨海机场附近的住宿很多，由于我是下了飞机之后临时去订的宾馆，所以没有接机服务，实际上提前订好的话可以等酒店接机车。第一晚上订的是希岸酒店，对象从长沙出发的航班由于延误到了晚上两点才到达，因此第一晚就在酒店睡到中午后起来换酒店，早上起来吃了个早饭，因为在锦江app买了双早。</p>
<pre><code>ps 附近有俩希岸酒店，相隔1.2km，名字很像，点了个外卖结果送错了。。。
</code></pre>
<p>睡醒之后起来换酒店，附近有一家康铂酒店，装修时间比较新，因此直接选择了入住这一家，房件带单早饭，有接送机服务。下午入住后，躺床上点外卖，不得不说天津这边机场附近非常热闹，外卖选择很多味道也不错。另外，烧烤非常多。因为太晒了，到了晚上六点多才准备出去，不过实际上这个时间非常好。直接打车到码头，在高德地图上搜海河游船，就会指向天津站码头，我过去之后大约七点十几分，看了码头上扫码购票的小程序发现七点半的场次还有一些余票，八点场次已经空了，因此直接买票上船。天津正如宣传所说，建设围绕着河道进行，所以坐船一趟基本上大部分景点都打卡了，我觉得不是很值得去细看了。船上大约四十分钟，下船之后可以到周边逛逛，基本上热闹的地方都在河边不太远，因此基本上不用太看路。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230606_195217-01.jpeg" width="600"></div>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">天津之眼，看看就行</center> 


<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230606_200018_edited.jpg" width="600"></div>
<div align="center">古文化街，路过就算成功</div>


<p>这基本上就算逛完天津了，这些建筑比RGB强一点，起码灯光基本统一色调。<br>回去大约十一点多，在酒店前台登记了第二天的送机车，八点半出发。</p>
<p>起来之后，先吃了早饭，比之前那个酒店的早饭好一些，然后到了八点半发现，在这个时间去坐飞机就我和对象两个人，这天高考，稍微有点堵车，不过我们十点出发的飞机，过去也就一二十分钟，完全不着急。</p>
<p>然后是坐十点钟的航班从滨海机场前往长白山机场。大约11：55到达，到达之后直接出一楼就可以打车了，到西坡集散中心附近也就十几块钱的路程。</p>
<h3 id="2-长白山周边"><a href="#2-长白山周边" class="headerlink" title="2. 长白山周边"></a>2. 长白山周边</h3><p>到达长白山之后在之前预定的民宿住下，然后在集散中心周边的街道（区域）里面找个店家吃了饭。这个时候去西坡集散中心，人非常少，但是旁边的小超市还是卖的很贵。。。。然后去旁边的欧亚超市买了东西，这里是平价。然后回民宿躺着了，晚上点了个烧烤，也点了个外卖送了雨衣。便宜不过味道不咋样。</p>
<p>晚上提前在长白山小程序上买了9：00-10：00的票，西景区全票214元&#x2F;人，由于不知道怎么去集散中心坐车，所以次日起早了一点。这天天气预报上看见的是连续两天都有雨。</p>
<p>到了第二天早上七点多起来的时候确实在下雨，打了微信公众号上的西区电话问了是天池暂时关闭。然后等了一会儿等到了八点多，发现雨停了，天气逐渐放晴，然后出发，换了小包背着，走到集散中心，集散中心前面有卖雨衣和卖橡胶鞋套的，他们说现在天池刚刚已经临时开启了。我和对象买了鞋套（10元x2）（实际上没啥用），然后我有冲锋衣，对象在第一天买了雨衣。</p>
<p>然后直接走到集散中心，进门就是检票，这里虽然小程序显示有二维码识别，但是实际上必须要身份证。。。进入坐大巴，等一会儿就出发了。坐车大约四十分钟到达西景区山门，然后接着坐车到换乘中心。换乘中巴上山。到了山上停车场之后旁边有游客服务中心，这里有桌子，有租大衣和卖雨衣的，我们进去换衣服穿鞋套，然后到旁边卫生间上厕所，因为前面都是爬山路了。准备好之后山上开始下雪了。。。。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230608_094014_edited.png" width="800"></div>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">路线图</center> 

<p>然后就是爬楼梯了，1400多阶楼梯，但是不陡，正常走很容易，走到一半听见有人说上面啥都看不清，不过还是决定接着上去。接近山顶的时候雪非常大，到处都是雾，整条裤子都打湿了—-是的，冲锋衣没事儿，融化的雪全流到裤子上了，手机冻关机了只好一直插着充电宝。</p>
<p>到了山顶有一个观景台，由于天气不好加上淡季，人不多，基本上可以随便拍照，但是大雪大雾只能看见一个坑，过一会儿什么也看不见了。上面有个工作人员的小屋，虽然他们不让进去但是太冷了进去一下也没事儿。。。。等了一会儿工作人员说你们在这里等着划不来不如下面去看大峡谷—-这里划重点，不能信，后面会说。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230608_122203.jpg" width="600"></div>
<div align="center">下雪的时候只能看见一个坑</div>

<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230608_122155.jpg" width="600"></div>
<div align="center">本来只想留念</div>

<p>雪大风大，在界碑旁边拍了照就准备下山了，但是下山的时候大约下到下面一个平台的时候我看到山谷里面雾逐渐被风吹散，可以比较清楚看到对面，然后我觉得爬回去，对象觉得太冷了就下山坐车回家了。然后我就背着包转身跑上山。这时候跑上山稍微有点累，不过主要是因为两年没锻炼了，实际上这时候人很少跑起来没有任何阻碍。</p>
<p>果然上山之后看到了天池的雾已经被吹散了，然后在这里拍照等到雾再起来就下去了。另外，山顶信号不好，我的miui相机全景组件没有下载。。。其实在下面一个平台就有信号了，但是我不想再跑一趟了。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230608_130155edit_edited.jpg" width="900"></div>
<div align="center">西坡天池</div>

<p>西坡是可以看到全部天池的，就是距离比较远。</p>
<p>然后下山，下山的时候雨不大，一路跑下去的（第一次下山的时候一步一步挪下去的），到了停车场可以坐中巴到换乘中心，换乘中心可以选择换大巴回集散中心或者去大峡谷。我去了大峡谷。</p>
<p>坐车到了大峡谷候车场，直接按照路牌进去，全程1.8km的栈道，进去之后发现栈道离大峡谷太远实际上拍不出来什么，需要长焦，看到的东西也不全都被树挡住了，所以这个1.8km我差不多一路跑出来的。。。大约花费三十分钟。如果听信了前面工作人员的话直接来看大峡谷怕是会吐血。这个景点基本上算是送的，用来散步锻炼身体。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230608_150011edit_edited.png" width="700"></div>
<div align="center">大峡谷其实看不到什么</div>


<p>然后从栈道出来回到起点也就是候车场，坐大巴回家。</p>
<p>回去之后休整一下，把衣服晾着，鞋吹干，然后点外卖睡觉。这时候还是没搞清楚第二天怎么去北坡，看到一个公众号的图片写着有直达景区车七点从随心酒店出发，第一站7：05到集散中心，然后就六点多起床，六点四十多到了集散中心，旁边的商户告诉说这里没有车，要到前面欧亚的地方坐车，到了之后发现这里的景区车是到长春的，没有到西坡的，遂打电话问，发现到西坡的景区车只能再随心酒店上车中间不停，随心酒店距离这里大约2km，再过去来不及了，不过停车场这里有大巴车，发车时间8：30，正好这班车的司机路过问到我们去哪里，我们说了之后招呼我们先把包放到车上我们出去逛逛，这时候是七点。</p>
<p>这时候这边街的商户都没开门，欧亚超市也是九点开门，，，，于是打车到附近的松江河镇去吃早饭。距离3.6km左右，预计8：00准备打车回来。在镇上买了车厘子西瓜桃子之后去吃了饺子，饺子煮熟要十几分钟，所以直接装袋子打车回来了。</p>
<p>上了大巴车，总共只有五个乘客，司机直接问了我们去哪里，中间就不用停车了，车费是17元&#x2F;人，我们坐在第一排，体验非常好，大巴是电车，非常平稳。总共是95km左右，不到100km的路程，地图上报的时间是1小时50分钟左右，实际上从出发到下车只花费了1小时28分钟。</p>
<p>到了北坡集散中心就下车了，稍微走一点进去，然后旁边有个租大衣的棚子可以寄存行李，一个箱子10元（实际上店主忙着租大衣压根没时间看我们。。。），进去直接放屋子旁边就好了，也没有专门的寄存处。。。店主说拍照，回来凭照片取。然后就去进门了。</p>
<p>到达的时候十点，正好赶上了一个旅行团，然后排队总共几十分钟。。。真的是恰好，因为后面就没有人排队了，直接现场买票10：00-11：00的票，选全票即可，会自动识别已经在西坡买了门票会自动扣减门票，检票入门等大巴。到了换乘点之后，上天池的小巴车要单独检票，也就是单独在小程序上买80元&#x2F;人的票。。。实际上北区总价比西区是更贵的。然后直接坐小巴上盘山公路直接到达山顶，路上景色也不错，车窗玻璃很干净：</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230609_120228_edited.png" width="500"></div>
<div align="center">换乘上天池主峰</div>

<p>不知道为啥北坡的雪特别白。</p>
<p>当天天气晴朗，可以绕着天池旁边的道多个角度拍照，不过人也比较多。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230609_123918edit_edited.png" width="900"></div>
<div align="center">北坡天池</div>

<p>拍照之后就准备下山了，下山之后，换乘的大巴是去往大瀑布的，到了大瀑布需要走一段楼梯才能看到，这一段路比较累，前面有个平台区，有不少卖吃的，有个温泉鸡蛋，10元&#x2F;三个，和山下的煮鸡蛋一个价格所以就买来尝尝了。进去之后这里有温泉有小溪，可以拍照。</p>
<p>走过去之后有个平台，大瀑布非常远。。。。。。非常需要一个长焦激情地摄影，手机广角拍照很难出图。。。</p>
<div align="center"><img src="/2023/06/13/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E9%95%BF%E7%99%BD%E5%B1%B1%E8%A1%8C%E7%AE%80%E8%AE%B0/IMG_20230609_142003edit_edited.jpg" width="800"></div>
<div align="center">米法公园（</div>

<p>然后就是回程了。回程的景点是直接乘坐大巴，依次是小天池、绿水渊潭、地下森林。虽然每个站都会停，但是都相隔非常近，坐车屁股还没坐热就要下车了，所以我没去小天池。</p>
<p>直接放照片。</p>
<p>【绿水潭图】</p>
<p>地下森林实际上就是在山脚的一条森林中的1.6km的栈道，来回3.2km，我没走完因为看看就差不多了，和地下没什么关系。</p>
<p>【地下森林图】</p>
<p>总结就是这几个景点也是送的锻炼身体的，尤其是大瀑布，栏杆距离瀑布非常远。</p>
<h3 id="3-回程"><a href="#3-回程" class="headerlink" title="3. 回程"></a>3. 回程</h3><p>最后换乘大巴回集散中心拿寄存，直接进去拿就好了。。。</p>
<p>然后听到路边有人喊延吉的车，就拼车去了延吉，80元&#x2F;人，四点多下山，等到了六点半出发，中间吃了个铁锅炖，是司机推荐的也不知道是不是他们认识，价格还行200一锅，分量很足根本不是两个人的量。。。吃不下，因为味道不咋样。。。，到延吉才发现延吉消费水平真高，大家似乎放假都往延吉跑，这里的丽枫酒店500元&#x2F;晚，这还是个普通周五。。。</p>
<p>离延边大学很近，直接走过去看了看。</p>
<p>第二天就去延吉西站坐高铁去了长春，在长春机场附近的七天酒店休息了一晚上早上四点半起来坐五点的送机车去机场做了七点的飞机准备回家。</p>
<h1 id="真正的总结"><a href="#真正的总结" class="headerlink" title="真正的总结"></a>真正的总结</h1><h2 id="地名问题："><a href="#地名问题：" class="headerlink" title="地名问题："></a>地名问题：</h2><p>这个问题真的纠结了我好久。好多攻略只去了池北，他们说的地名都模糊不清，实际上是因为后来地名有些更改。</p>
<p>池北区：也就是二道白河镇，实际上就是在一起。</p>
<p>白河客运站：也就是池北区客运站，现在就叫池北区客运站，搜地图上是搜不到的。池西区没有客运站只有直达车的停车场。</p>
<p>池西区：单独开发的地方，离附近的松江河镇3km多。（还有不少烂尾楼）</p>
<h2 id="行程注意事项"><a href="#行程注意事项" class="headerlink" title="行程注意事项"></a>行程注意事项</h2><p>这些都是淡季旅游（且是工作日）可行的，其他时候可能没有这么多临时选择。</p>
<p>1、去程方法，方法有很多，但是我选择飞机是因为机场离池西区集散中心非常近。实际上，西区的票最晚一场是12:00-12:30,所以理论上来说极限压缩时间是可以当天上西坡的，如果天气好，一下午就可以结束了，不过我没有注意西区集散中心寄存行李在哪里。</p>
<p>2、天气问题，提前看了很久，实际上根本看不准，我在当天晴天的情况下天气预报依然是山上有雨，实际上全程只下了一会儿小雨，包括当天上西坡，天气看起来非常不好，但是就晴了一会儿就开放了可以上山。</p>
<p>3、游玩顺序：如果从机场走，显然西坡更近，回去的时候则在北坡离客运站更近，也比较热闹。回程选择比较多。个人比较推荐这个路线，唯一的问题是，第一天上西坡比较累，要爬楼梯，最好提前锻炼身体。</p>
<p>4、坐车通勤：从西坡到北坡和从北坡到西坡都有大巴车，西坡早上发车时间是8：30和10：00，下午忘了。。。好像但是从西坡下坡后也不一定要坐大巴，下坡一般在集散中心附近有人喊拼车，50元&#x2F;人，可以考虑，不过个人觉得西坡由于人少住宿比较便宜，大巴车也更便宜，所以可能住一晚上更好也不耽误时间。西坡的停车场在欧亚超市旁边，地图上就能看到。</p>
<p>5、住宿，西坡集散中心附近有很多宾馆，我去的时候都是显示100元&#x2F;晚左右的价格，所以实际上没有必要提前订，尤其是不要相信美团，加价杀熟比较严重。北坡也就是池北区，开发比较好，因此酒店选择比较多，有不少连锁酒店，比如锦江华住会的酒店，不过也贵一些，自己选择了。至于很多人说的万达度假区，如果是冲着长白山去的，没必要去那里，离哪边都远。</p>
<p>有些攻略会推荐到山门下面住宿，会更近一些，回程的时候大巴会问有没有要途中下车的去中途住宿处的，过去不了解怎么上车。不过实际上没有必要，尤其是如果两个坡都去的话集散中心通勤更方便，反正坐车那会儿等着就行。</p>
<h2 id="有用总结"><a href="#有用总结" class="headerlink" title="有用总结"></a>有用总结</h2><p>1、网红城市酒店贵，不分节假日；再强调一次，不要相信美团，看看信息就好了。</p>
<p>2、工作日游玩看看景区票余量就可以知道人流量，基本上余票大把大把可以认为不用提前订票，对于行程安排有很大帮助，省钱的同时选择比较大。</p>
<p>3、路上不要听别人说，我对象下山的时候说山上什么也看不见，把别人去了三次长白山都没看到天池的人劝回去了。见天池多少要点缘分，但是头铁一样能看到。</p>
<p>4、想拍风景如果是广阔天地而且没啥人，广角还是不错，但是如果有人而且有遮挡，长焦才是真神，带上脚架自己合成吧。拍风景还是要带相机。</p>
<p>5、爬山要做好衣服打湿的准备，这次只带了一条裤子过去，结果没想到在北方洗衣机甩干之后晾一晚上裤子也干不了，最后穿了对象的裤子。鞋子是用吹风机吹干的。</p>
]]></content>
      <categories>
        <category>生活游玩</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title>使用aardio写一个基于pyocd的单片机下载器</title>
    <url>/2023/04/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8aardio%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Epyocd%E7%9A%84%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8B%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<p>为了方便使用pyocd进行下载操作，于是写了一个下载器GUI，开发工具选择了aardio，因此只支持Windows平台。</p>
<span id="more"></span>
<h1 id="1-新建工程"><a href="#1-新建工程" class="headerlink" title="1 新建工程"></a>1 新建工程</h1><p>最开始本来是打算调用pyocd 的python api的，但是一方面是内嵌包一直安装出问题，另一方面是考虑到本地pack不想重复安装和管理，于是就转做pyocd的前端了，也就是直接调用pyocd，根据返回数据解析，然后执行要做的命令。</p>
<p>所以新建一个普通工程就可以。</p>
<h1 id="2-基本功能"><a href="#2-基本功能" class="headerlink" title="2 基本功能"></a>2 基本功能</h1><p>主要功能：</p>
<ul>
<li><p>下载 </p>
</li>
<li><p>擦除 </p>
</li>
<li><p>复位<br>然后要能选择对应的仿真器和单片机型号，从支持的列表从选择，就要用一下pyocd list和pyocd list -t命令查询，根据返回的结果解析已经可以支持的单片机。</p>
<p>  p.s 其实直接用pyocd json 命令返回json会很容易解析，但是我一开始没看到这个命令，就算了，正好生成命令pyocd list的执行结果也可以给人看。</p>
</li>
</ul>
<p>其中pyocd list会返回仿真器的列表，我是通过head也就是第一行的标题的位置来得到下面每行内容的分割位置，得到正确的结果。这里发现是每隔一行为一个仿真器信息。<br>而pyocd list -t 返回可用器件型号，分割方法类似，不过这里不是每隔一行而是连续的每行都是对应结果，一开始这里没看到导致少了一半。</p>
<p>另外这里在使用aardio遇到一个bug就是结构体的值发生了变换（aardio实际上没有结构体而是表），不知道为什么，类似的方法直接赋值给数组就不会出问题。</p>
<h1 id="3-基本实现"><a href="#3-基本实现" class="headerlink" title="3 基本实现"></a>3 基本实现</h1><p>基本就是添加几个框框，根据填入的参数生成命令然后通过调用命令行并获取执行结果显示出来，对于有进度条的执行命令我不知道怎么实时获取，没有看到aardio这样的例子，遂作罢。</p>
<p><img src="http://c.51hei.com/d/forum/202304/25/142034iz7zt6ovv44xttoo.png" alt="基本界面"></p>
<p>除了基本界面，调整了一下布局，让他能缩放合适，内嵌了字体（其实也就俩按键用了这个字体，得意黑，软件凭空大了1M多，本来只有几百kb，主要是好不容易调整好了不想改 ）。<br>添加了一个菜单栏，把一些生成命令的语句例如pyocd gdbserver收纳到了菜单栏，方便配合其他软件使用。<br>例如如果要开启gdb server，例如使用segger embedded studio或者其他软件的时候，启动时候执行的命令就可以用这个GUI来生成，稍微省心一点。</p>
<p>仿真器连接后可以通过刷新来获取，当然，打开软件的时候也会自动获取一次，通过指定uid来保证一次能执行对命令，避免二次选择。</p>
<p>基本就这样。</p>
<p>这里有我上传的：<br><a href="http://www.51hei.com/bbs/forum.php?mod=viewthread&tid=228512">分享一个基于pyocd的单片机GUI下载器 - Cortex M3 M0 M4开发 (51hei.com)</a></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>aardio确实挺好用的，很能缝合，布局上也是自动缩放，要求不高的话很容易调整到还不错的效果。写起来很快，高分屏的问题也自动处理了，第一次用观感不错。不过有部分问题横竖找不到根源，倒是能换个方法解决。</p>
<p>其实pyocd本身就有python api，但是我不想用python的gui的一些库然后打包什么的。其实用这些api有些功能会做出来更好用。</p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>DAP-Link</tag>
        <tag>pyocd</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派RP2040开发环境配置集合版(基于Raspberry Pico)</title>
    <url>/2022/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/0_RP2040%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>这篇文章是一个测试了多种方法开发RP2040并总结的集合，如果只关心一种方法，我推荐阅读：[RP2040配置VSCODE开发环境 —— 一劳永逸版](<a href="https://alwaysmy.github.io/2023/04/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/RP2040%E9%85%8D%E7%BD%AEVSCODE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E7%89%88/">RP2040配置VSCODE开发环境 —— 一劳永逸版 | 加载中… (alwaysmy.github.io)</a>)。</p>
<p>起初我以为RP2040作为一款树莓派出品的单片机会有很成熟的开发方案，等到我过了两年才开始决定找一下的时候，发现网上的配置方法大多数是照着官方给的方法一抄，完全没有解释里面各个部分需要做什么的原因，以及有什么过程需要了解学习，甚至没有说这个配置方案就是<a href="https://datasheets.raspberrypi.com/pico/getting-started-with-pico.pdf">官方入门手册.Chapter 7</a>中给出的方法。</p>
<span id="more"></span>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">（我最开始看的手册还没更新树莓派以外平台的写法，所以蒙圈了好久，以为这些环境配置方法是他们经验丰富才能总结出来的）。</span><br></pre></td></tr></table></figure>

<p>这些网上的博客基本上都是照着文档来配置，好点的会给几个填坑的说明，然后到了调试配置阶段都是直接默认使用官方给出的picoprobe调试器的配置方法或者压根不走调试，实在是让人看了捉急，难道你们开发单片机都不用开Debug吗？</p>
<p>因此就有了这篇文章。</p>
<h1 id="一些基础前置内容"><a href="#一些基础前置内容" class="headerlink" title="一些基础前置内容"></a>一些基础前置内容</h1><p>pico指的是搭载了rp2040单片机的官方出品的PCBA，不过市面上卖的核心开发板基本上兼容官方设计，因此下面文章中不区分pico字样和rp2040字样。</p>
<h2 id="调试使用的Debugger"><a href="#调试使用的Debugger" class="headerlink" title="调试使用的Debugger"></a>调试使用的Debugger</h2><ul>
<li><p>官方版本<br> 他们做了一个特殊的daplink，叫做picoprobe, 就是直接用pico实现了一个swd的功能，相比ARM开源的DAP更简陋。在大部分博客中以及现在的官方入门文档中，都指出这个picoprobe所使用的openOCD需要raspberry分支下的openocd才能用，同样，配置文件也是专用的。</p>
<p>  在Windows下如果用picoprobe需要使用Zadig为其安装驱动为libusb-win32。（不知道现在还是不是这样，网上有的教程还提到了需要复制一个dll文件，但是我看现在的openocd.exe目录下已经包含了这个dll）</p>
</li>
</ul>
<blockquote>
<p>这意味这个版本picoprobe的通用性比较差，因此一般来说没有必要使用这个。</p>
</blockquote>
<ul>
<li>标准CMSIS-DAP<br>标准的cmsis-dap v2是部分可用的，实测v1的似乎都不能连接上多核，单核似乎也不行。<br>手上有一个WCH-Link实测是可用的。</li>
</ul>
<p>        另外也可以使用pico-debug这个固件加载自调试，这个固件同样移植自ARM开源的CMSIS-DAP.</p>
<ul>
<li>Jlink<br>有官方支持，但是需要氪金购买新版，我没有，所以下面不会说。</li>
</ul>
<p>          </p>
<h3 id="配合Debugger使用的上位机"><a href="#配合Debugger使用的上位机" class="headerlink" title="配合Debugger使用的上位机"></a>配合Debugger使用的上位机</h3><p>除了Jlink有官方上位机，PicoProbe和CMSIS-DAP都需要有上位机支持。</p>
<p>PicoProbe使用的是raspberry官方修改的openocd分支，需要单独下载编译。CMSIS-DAP可以使用通用版OpenOCD，也可以使用Pyocd.</p>
<pre><code>尽管PicoProbe和OpenOCD是官方文档提到的方法，但是openocd的bug较多，我不推荐使用，如果使用了发现存在bug，最好办法是更新版本，一般问题会解决。0.12 rc1以及之前版本存在bug。
</code></pre>
<p>Openocd下载来源两个：</p>
<ul>
<li><a href="https://github.com/openocd-org/openocd/releases">Releases · openocd-org&#x2F;openocd (github.com)</a></li>
<li><a href="https://gnutoolchains.com/arm-eabi/openocd/">Download OpenOCD for Windows (gnutoolchains.com)</a></li>
</ul>
<p>但是第二个通常版本相比较旧，我在写这篇文章的时候使用是存在bug的。</p>
<p>而pyocd只需要使用pip安装即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pyocd</span><br></pre></td></tr></table></figure>

<p>就这么简单，相比来说pyocd的文档也更全面。具体使用放到后面介绍。</p>
<h2 id="下载固件的方法"><a href="#下载固件的方法" class="headerlink" title="下载固件的方法"></a>下载固件的方法</h2><h3 id="UF2固件加载"><a href="#UF2固件加载" class="headerlink" title="UF2固件加载"></a>UF2固件加载</h3><p>RP2040内建Bootloader支持插上电脑USB拖入固件烧录。</p>
<p>在RP2040运行前按住boot按键然后运行就会让rp2040进入Boot模式。</p>
<p>最简单的方法是按住按键然后上电就进入boot模式了，然后电脑上就会出现一个叫做RP2-PI的硬盘驱动器，右键UF2文件，点发送到树莓派对应的驱动器。<br>    （btw.如果是win11强烈建议改成win10右键菜单）。</p>
<p>如果不希望重新拔插上电，可以拉低Run引脚后按Boot，然后释放Run引脚，不过官方Pico板并没有给Run引脚添加一个按键。</p>
<p>除此之外，也可以通过代码实现实现跳转bootrom进入bootloader模式，在文章(TODO)中解释。<br>UF2（USB Flashing Format (UF2)）格式参考：<br><a href="https://github.com/microsoft/uf2">microsoft&#x2F;uf2: UF2 file format specification (github.com)</a></p>
<h3 id="加载ELF或BIN文件"><a href="#加载ELF或BIN文件" class="headerlink" title="加载ELF或BIN文件"></a>加载ELF或BIN文件</h3><p>除了通过UF2下载固件，还有传统的SWD烧录的方法，将在环境配置介绍之后的第四章介绍。<br>后文中可能会提前说到自调试固件这个词，这里提前说一下，是一个用RP2040的一个核作为仿真器来调试另外一个核心的项目。来源：<a href="https://github.com/majbthrd/pico-debug">majbthrd&#x2F;pico-debug: virtual debug pod for RP2040 “Raspberry Pi Pico” with no added hardware (github.com)</a></p>
<h2 id="环境配置的解释"><a href="#环境配置的解释" class="headerlink" title="环境配置的解释"></a>环境配置的解释</h2><p>本文都是默认我们配置了环境变量来说的，如果有的地方没有提到什么程序加入了环境变量就用了，那就是忘了说，除了说了可以不加。当然这个也很好理解，遇到需要用到某个程序但是没有写绝对路径，那么基本上就加环境变量就好了。</p>
<h2 id="这篇文章说了些什么"><a href="#这篇文章说了些什么" class="headerlink" title="这篇文章说了些什么"></a>这篇文章说了些什么</h2><p>写这篇文章的时候，我很想知道用什么环境开发RP2040更加顺手，为了具体试一试，所以我找了好几个方案全都列举出来了。</p>
<p>本文主要包含下面几种发开方案：</p>
<ul>
<li>MicroPython</li>
<li>PlatformIO的方法</li>
<li>基于第三方IDE的方法</li>
<li>基于官方C-SDk给出的cmake的配置方法和后续的导入IDE的配置方法。</li>
</ul>
<p>除了最后一种，前面三种基本算是算是开箱即用。</p>
<p>不过如果对于cmake不熟悉，了解一下官方给出的方法还是不错的，已经熟悉的话就很容易明白了。<br>其中，最后一个方法也就是基于官方给出的C-SDK自行配置，本文中的使用的其中的一种方法是配置VSCODE作为IDE，但是也写了其他的IDE用来作为开发环境的方法。</p>
<p>下面就开始一个一个来说了。</p>
<h1 id="MicroPython环境使用"><a href="#MicroPython环境使用" class="headerlink" title="MicroPython环境使用"></a>MicroPython环境使用</h1><p>这个方法是最简单的，初始配置对于Windows和Linux都很友好，而且使用Python来开发。</p>
<p>优势是：<br>开发相对容易，导入包很简单，基本功能都能用，PIO一样可以支持。<br>缺点是：<br>micropython不能支持多核操作。<br>很多函数功能没有适配，例如DMA和PIO还需要手搓寄存器，这个工具是门槛低上限也低。<br>所以这里仅仅简单说一下使用方法作为记录：</p>
<ol>
<li><p><a href="https://www.raspberrypi.org/documentation/pico/getting-started/">Raspberry Pi Documentation - Microcontrollers</a>，选择<strong>Getting Start with MicroPython</strong>，<a href="https://micropython.org/download/rp2-pico/rp2-pico-latest.uf2">下载uf2固件</a>后烧录到rp2040上，打开设备管理器会发现多了一个COM端口（就是串口）。</p>
</li>
<li><p>下载<a href="https://thonny.org/">Thonny IDE</a>, 打开Thonny，右上角点击切换至一般模式，然后点击视图，勾选上这三个：Shell、变量、文件，当然还有别的，这几个最常用。</p>
</li>
<li><p>配置Thonny：工具-设置-解释器-选择Raspberry Pi Pico的解释器，然后选择串口端口，这个端口可以看刚刚设备管理器多出来的那个端口就是的。也可另外用别的工具直接连板子上的串口，波特率是115200。</p>
</li>
<li><p>进入shell直接依次执行python语句测试</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> machine <span class="keyword">import</span> Pin</span><br><span class="line">led = Pin(<span class="number">25</span>, Pin.OUT)</span><br><span class="line">led.value(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>写python文件</li>
</ol>
<p>在Thonny里面编辑文本后保存的时候选择保存到pico就行了，开机默认会自动运行main.py ，也就是刚刚保存的文件。</p>
<ol start="6">
<li>至于开发，随便找个帖子吧：<a href="https://zhuanlan.zhihu.com/p/359823300">目前全网最详细的树莓派 Pico入门指南！ - 知乎 (zhihu.com)</a><br>资料：<br><a href="https://datasheets.raspberrypi.com/pico/raspberry-pi-pico-python-sdk.pdf">Raspberry Pi Pico Python SDK</a>    <a href="https://www.raspberrypi.com/documentation/microcontrollers/micropython.html">Raspberry Pi Documentation - MicroPython</a></li>
</ol>
<p>还有一个VSCODE插件可以用在这个上面：<br><a href="https://marketplace.visualstudio.com/items?itemName=paulober.pico-w-go">Pico-W-Go - Visual Studio Marketplace</a></p>
<h1 id="PlatformIO环境开发"><a href="#PlatformIO环境开发" class="headerlink" title="PlatformIO环境开发"></a>PlatformIO环境开发</h1><p>我感觉这个东西出bug的问题比较大，不过考虑到配置比较简单我还是写一下。</p>
<pre><code>它经常不显示出来主页，不知道为啥给我的感觉就是有点卡。
</code></pre>
<h2 id="Arduino框架环境"><a href="#Arduino框架环境" class="headerlink" title="Arduino框架环境"></a>Arduino框架环境</h2><p>个人认为，如果不在乎那个arduino框架的资源占用，其实还是这个一个很好的开发平台，对仿真器的支持也还可以。</p>
<p><strong>安装方式：</strong></p>
<p>在PlatformIO的board里面搜rp2040或者rasp，安装对应的平台。</p>
<p><strong>文档：</strong><br><a href="https://arduino-pico.readthedocs.io/en/latest/sdk.html">Using the Raspberry Pi Pico SDK (PICO-SDK) — Arduino-Pico 2.6.2 documentation</a></p>
<p><strong>功能：</strong><br>支持arudino框架，配置有arduino风格的函数。<br>因为本身就是基于C-SDK的 , 因此自然也支持在arduino框架下直接使用pico-sdk的函数。</p>
<p><strong>下载调试方法：</strong><br>这个框架一般会自动选择调试工具，如果要更改就在工程下的ini文件里面添加两行，例如：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">upload_protocol</span> = picotool</span><br><span class="line"><span class="attr">debug_tool</span> = cmsis-dap</span><br></pre></td></tr></table></figure>

<p>上面的上传和debug参数可以分别改成：</p>
<ul>
<li>cmsis-dap, 这个就是一般的cmsis-dap调试器（现在应该叫做daplink）</li>
<li>jlink </li>
<li>picotool ，就是UF2文件的上传工具</li>
<li>raspberrypi-swd ，就是用picoprobe作为调试器。</li>
</ul>
<p>注释：</p>
<ul>
<li><p><input disabled type="checkbox"> 
如果手上没有调试器或者不在意使用调试功能，那么点编译后在工程目录下.pio&#x2F;build下有uf2文件，首次需要手动上传arduino框架的uf2固件，之后后面就可以直接用platformio的上传功能，不用拔电上传了，arduino框架固件内置了进入bootrom的代码，会启动到USB PICOBOOT和大容量储存设备模式。观察到确实运行时候点上传会进入大容量设备状态，但是实测接着上传不成功。。。我不知道为什么（别的帖子说是可以的).</p>
</li>
<li><p><input disabled type="checkbox"> 
如果用openocd调试，点击侧边的调试，有一个pio debug的选项。如上所说支持三种外部debugger，不过我用dap v1的时候也不好使 ，自调试固件也不好使，别人说用官方的picoprobe是可以正常调试的（见参考链接）。实测使用WCH-link可以调试，能正常显示双核。点上传似乎不太好使，要点左边的调试，显示为PIO debug。下图为arduino框架下的调试。</p>
</li>
</ul>
<img src="/2022/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/0_RP2040%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/arduino%E6%A1%86%E6%9E%B6%E5%8F%AF%E4%BB%A5%E8%B0%83%E8%AF%95%E5%8F%8C%E6%A0%B8-wchLink.png" class title="arduino框架可以调试双核">

<p>参考链接：<a href="https://community.platformio.org/t/cannot-debug-pi-pico-with-cmsis-dap-cmsis-dap-command-cmd-dap-swj-clock-failed/21300/8">Cannot debug Pi Pico with CMSIS-DAP - “CMSIS-DAP command CMD_DAP_SWJ_CLOCK failed” - PlatformIO IDE - PlatformIO Community</a></p>
<h2 id="基于pico-sdk的裸环境Wiz-IO"><a href="#基于pico-sdk的裸环境Wiz-IO" class="headerlink" title="基于pico-sdk的裸环境Wiz-IO"></a>基于pico-sdk的裸环境Wiz-IO</h2><p><a href="https://github.com/Wiz-IO/wizio-pico">Wiz-IO&#x2F;wizio-pico: Raspberry Pi Pico development platform for PlatformIO (github.com)</a></p>
<p>个人认为，如果这个方法不是存在一点调试的bug的话，应该是最快最完整的C-SDK的方法。目前调试只支持Windows。</p>
<p><strong>安装方式</strong></p>
<ul>
<li>PIO Home &gt; Platforms &gt; Advanced Installation</li>
<li>粘贴： <a href="https://github.com/Wiz-IO/wizio-pico">https://github.com/Wiz-IO/wizio-pico</a></li>
<li>点击INSTALL</li>
</ul>
<p><strong>功能</strong></p>
<p>支持原生C-SDK编写方式，所以功能都能支持，没有arduino框架当然也就不能支持UF2文件的自动上传了。</p>
<p>文章当中写着写着下载支持cmsisdap picoprobe uf2三种方式，目前只支持Windows。</p>
<p><strong>下载调试：</strong></p>
<p>下载默认是uf2下载，需要rp2040先手工进入BOOT模式，稍微有点麻烦，可以参考后面的调试方法里面的一键进入BOOT.</p>
<p>如果要调试，在<code>platformio.ini</code>  里面添加对应的方式，比如</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">upload_protocol</span> = picoprobe</span><br><span class="line"><span class="attr">debug_tool</span> = picoprobe</span><br></pre></td></tr></table></figure>

<p>上面的值可以改成：cmsis-dap，picoprobe, uf2</p>
<p>不过我测试的时候感觉我的wch-link就没被调用过，，可能实际上这个框架里面估计也就picoprobe好使，不清楚是不是我的问题。</p>
<p>这个框架附带了picoprobe的固件，<code>picoprobe.uf2</code> have in <code>tool-pico-openocd</code> folder，看起来作者可能也就写了这么多。</p>
<h1 id="基于第三方IDE配置"><a href="#基于第三方IDE配置" class="headerlink" title="基于第三方IDE配置"></a>基于第三方IDE配置</h1><p>下面这几个都很方便，因为他们都提供了集成的SDK下载和模板工程的创建，不需要官方那一套配置，也就是说开箱即用类型，类似于STM32CUBEIDE,CCS这种，当然，肯定不如别的官方对自己产品优化好。</p>
<h2 id="基于VisualGDB的Visual-Studio创建工程"><a href="#基于VisualGDB的Visual-Studio创建工程" class="headerlink" title="基于VisualGDB的Visual Studio创建工程"></a>基于VisualGDB的Visual Studio创建工程</h2><p>先安装visualGDB,这是一个给VS提供的跨平台包，关键词：VisualGDB的基本使用。</p>
<p>然后按照下面的方法，新建工程选模板，下sdk就好。</p>
<p><a href="https://visualgdb.com/tutorials/raspberry/pico/">Developing Raspberry Pi Pico Projects with Visual Studio – VisualGDB Tutorials</a><br>但是VisualGDB是收费的，所以告辞，看起来很简单，我没试过，也有人说用起来有Bug.</p>
<h2 id="基于-Segger-Embedded-Studio"><a href="#基于-Segger-Embedded-Studio" class="headerlink" title="基于 Segger Embedded Studio"></a>基于 Segger Embedded Studio</h2><p>这个软件社区版本免费，支持Jlink, GDB server，其中gdb server可以选 <code>jlink openocd pyocd st-link</code>这几种。实际上有几个版本中自带的Jlink能使用CMSIS-DAP V1（HID) 。</p>
<p>这个软件支持多平台，工程配置很方便。</p>
<p>自带软件芯片仿真，自带少数几个rp2040例程，不过他的例程都是干寄存器，没有引用官方的pico-sdk，pico-sdk的文件是被包含在内的，只是有一些路径没有被包含，示例程序还是没用上SDK的内容。<br>编译和加载可能是Segger自家技术，速度较快，默认支持printf输出到RTT在窗口上显示。（也可以选semihost，设置-首选项，Code &gt; Library &gt; Library I&#x2F;O）</p>
<p>对于指定的工程，打开之后按F1会给出一些手册和提示。下面是具体的步骤。</p>
<h3 id="安装SDK"><a href="#安装SDK" class="headerlink" title="安装SDK"></a>安装SDK</h3><p>点Tools - Package manager,搜pico，点一下，然后点next，就可以安装好sdk了，不过SDK路径并不会被包含进去。</p>
<h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>点Project-Add project，选树莓派的第一个pico是官方的板子的，不带pico就是裸片的工程，区别不大。</p>
<p>然后是工程配置：</p>
<blockquote>
<p><em>目标处理器选0或者1，对应核心，</em></p>
<p><em>编译器可以选gcc或者segger，</em></p>
<p><em>剩下一些配置默认就行，根据需要选</em></p>
</blockquote>
<p>然后编译，debug。</p>
<p>默认没有生成uf2文件，因为需要调用外部工具生成。</p>
<p>工程配置可以修改C&#x2F;C++的包含路径，工程本身包含了部分pico-sdk的include路径，但是没有完全包含—-不知道具体原因是为啥—-没有被默认配置到包含路径的的包括hardware_xxx下的外设的库，这个路径对应</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">....\SEGGER Embedded Studio\v3\packagesRP2040_Pico_BSP\pico-sdk\src\rp2_common</span><br></pre></td></tr></table></figure>

<p>而且这个pico-sdk是不包含第三方库的。可以自己加上去的，没有仔细试过（不知道会不会出现stdlib不兼容的情况，因为pico的c-sdk里面自己定义了个stdlib.h)，在对应的solution中添加后，后来新建的工程就会默认继承solution的设置。<br>不过按照和前面的Cmakelist的路径添加，应该是可以做到这个工程和官方方法的工程代码兼容的方法的）</p>
<h3 id="仿真下载调试"><a href="#仿真下载调试" class="headerlink" title="仿真下载调试"></a>仿真下载调试</h3><h4 id="J-link"><a href="#J-link" class="headerlink" title="J-link"></a>J-link</h4><p>不支持V10以下的Jlink。。。也有的说能支持，但是反正我的Jlink Lite V9显示不支持multi-drop，也有人说需要Jlink v11才行。</p>
<p>参考链接：<br><a href="https://forum.segger.com/index.php/Thread/7762-SOLVED-RP2040-Support/?s=e9995ac861bb4d522b6c8a0165f8c96f24726aec">[SOLVED] RP2040 Support - J-Link&#x2F;Flasher related - SEGGER - Forum</a><br>官方文档指出至少需要v11:</p>
<ul>
<li>J-Link HW revision 11 or later (J-Link EDU Mini and J-Trace PRO V1 or later also supported)</li>
<li><a href="https://wiki.segger.com/Raspberry_Pi_RP2040">Raspberry Pi RP2040 - SEGGER Wiki</a></li>
</ul>
<p>合着来卖配件了，4块钱的单片机配不上这个尊贵的JLink.</p>
<p>但是可以使用具有HID通信的DAPLink，尽管官方表示支持daplink是个错误，但是有几个版本确实能支持。。。</p>
<h4 id="Daplink"><a href="#Daplink" class="headerlink" title="Daplink"></a>Daplink</h4><p>1、在Shell或命令行里面开一个openocd server等待连接(这一步实际上可选，下面解释)，如：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">openocd -f board/pico-debug.cfg</span><br></pre></td></tr></table></figure>

<p>这里这个配置文件是openocd自带的，其配置实际上调试的是rp2040的core0，也就是调试的是单个核心。</p>
<p>2、配置工程调试选项</p>
<p>工程上右键 - option - debug - debugger- 选gdb server，然后点gdb server选项，选openocd。<br>点Debug就会启动gdb连接到刚刚开的openocd这个gdb server。</p>
<p>实际上第一步中手动开一个openocd的gdbserver等待的过程可以省掉：<br>可以勾选工程选项里面debug下面的 <code>GDB Server-auto start gdb server</code> 为yes </p>
<p>然后填写<code>Debug &gt; GDB Server &gt; GDB Server Command Line</code>：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">openocd.exe -f board/pico-debug.cfg</span><br></pre></td></tr></table></figure>

<p>这个openocd要加入环境变量，或者使用绝对路径。</p>
<p>实测中，单核调试使用自调试固件的单核配置（也就是pico-debug.cfg这个配置），多核使用WCH-link使用标准的配置，都可以正常调试、查看变量寄存器。</p>
<p>如果想调试多核，标准多核的配置为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openocd -f interface/cmsis-dap.cfg -f target/rp2040.cfg</span><br></pre></td></tr></table></figure>

<p>只是如果使用单核的配置的情况下使用外部daplink的时候就不要让它自己启动openocd, 也就是说需要手动启动，不然连接不上，可能是openocd的bug。</p>
<p><font color="#bcaadd">同样，命令可以更换为pyocd的命令，命令更为简单，目前没有遇到bug。</font></p>
<p>只需要使用pip安装好pyocd之后，更换 GDB Server Command Line：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyocd gdbserver -t RP2040 -f 10000k</span><br></pre></td></tr></table></figure>

<p>注意，这里没有指定调试器UID, 因此需要保持电脑上就只插了一个仿真器，否则可能不能正确打开pyocd的gdbserver</p>
<blockquote>
<p>使用pyocd生成调试命令可以参考我写的工具：<a href="https://alwaysmy.github.io/2023/04/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8aardio%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Epyocd%E7%9A%84%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8B%E8%BD%BD%E5%99%A8/">使用aardio写一个基于pyocd的单片机下载器 | 加载中… (alwaysmy.github.io)</a></p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://discuss.em-ide.com/d/199-openocddap">在烧入配置中选择OpenOCD，用DAP仿真器进行下载。 - Embedded IDE Forum (em-ide.com)</a></li>
<li><a href="https://github.com/majbthrd/pico-demos/tree/master/pico-ses">pico-demos&#x2F;pico-ses at master · majbthrd&#x2F;pico-demos (github.com)</a> ，一个工程模板，不过没必要用，这个模板很老了，估计是还不支持rp2040 sdk的时候的时候做的，也是全都是干寄存器，配置的处理器类型也是一个通用M0+。所以按照最上面那样配置就可以了。</li>
</ul>
<p>下载链接：<a href="https://www.segger.com/downloads/embedded-studio/">SEGGER - The Embedded Experts - Downloads - Embedded Studio</a></p>
<h2 id="基于RT-Thread-Studio"><a href="#基于RT-Thread-Studio" class="headerlink" title="基于RT-Thread Studio"></a>基于RT-Thread Studio</h2><p>国产软件，评价很高，社区版免费。<a href="https://www.rt-thread.org/download.html#download-rt-thread-studio">下载链接</a></p>
<p>如果不介意用rt-thread的话，那么可以去使用rt-thread studio（因为目前他仅仅支持rtt的工程使用官方给sdk模板）</p>
<p>支持jlink daplink，不过好像都不怎么好使。。</p>
<p>使用要登陆。。。有点蠢，bug也还不少。。安装的时候会出现超长路径导致不能放到比较长的路径里面（我已经关了路径长度限制）</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>下载SDK, 随便开个窗口或者新建工程点进下载SDK的界面。<br> 对于Pico,只能创建rtt工程，显示三种调试工具可选，点下载程序的小箭头可以改调试下载方式。<br>gdbserver调用的是pyocd，实测我手上的这个daplink v1不支持，已经测过ok的自dap是v2的也不好使，所以不知道好不好使，，，<br>jlink也是需要jlink支持，我的版本不够。<br>stlink不可能支持的。。只是显示出来了。</li>
</ol>
<p>要先点一下调试配置，改一下可执行程序的位置和名称，默认的位置不对。。。点一下搜索项目按钮，选elf那个文件。（目前的版本是这样）</p>
<p>有人使用picoprobe替换驱动为libusb后用来调试（没看见他发调试成功的图啊）<br>我也没成功过，所以不知道调试行不行。但是考虑到有人用这个写，应该是可以的，但是我自己实属体验不好，所以就只能写这么多了。</p>
<p>参考链接：<a href="https://club.rt-thread.org/ask/article/5b94f05666f693db.html">RT-Thread-在 RT-Thread Studio 中使用树莓派 Pico 开发板RT-Thread问答社区 - RT-Thread</a></p>
<h2 id="使用Keil-MDK"><a href="#使用Keil-MDK" class="headerlink" title="使用Keil MDK"></a>使用Keil MDK</h2><p><a href="https://github.com/GorgonMeducer/Pico_Template">GorgonMeducer&#x2F;Pico_Template: An MDK template for Raspberry Pi Pico (github.com)</a><br>用这个模板，看起来还行，我就不测试了，不喜欢Keil。</p>
<p>使用方法：<br>    git clone <a href="https://github.com/GorgonMeducer/Pico_Template">https://github.com/GorgonMeducer/Pico_Template</a> .<br>    git submodule update –init</p>
<h2 id="更多第三方IDE"><a href="#更多第三方IDE" class="headerlink" title="更多第三方IDE"></a>更多第三方IDE</h2><p>基本上就是使用CortexM0+的对应文件并正确包含pico-sdk库的文件就可以了，其实后面CMakelist同理。</p>
<p>我看还有人用CrossWorks for ARM,很贵，不多说了。</p>
<p>上面介绍的方法都是基于工程模板的，下面介绍的就是对应pico官方给出的基于Cmakelist的构建方法。</p>
<h1 id="基于官方C-SDK的开发环境搭建"><a href="#基于官方C-SDK的开发环境搭建" class="headerlink" title="基于官方C-SDK的开发环境搭建"></a>基于官方C-SDK的开发环境搭建</h1><p>关于CMake和CMakelist这里不再赘述，网上内容很多，先了解一下比较好。</p>
<h2 id="官方文档的方法总结"><a href="#官方文档的方法总结" class="headerlink" title="官方文档的方法总结"></a>官方文档的方法总结</h2><p>网上找的方法绝大多数都是基于getting-started-with-pico.pdf这个手册上的方法，最开始这个手册只更新了基于树莓派系统的配置，他是说直接执行setup脚本就行了，后来才更新了其他平台的配置方法。</p>
<p>官方的配置里面很多配置文件有很多问题，比如上面的setup脚本，很可能自己的环境用不了。另外，配置中如果遇到问题，重新git pull或者直接覆盖更新自己之前下载的文件是最有可能能解决问题的方法。</p>
<p>总的来说，建立一个工程需要下载pico-sdk和pico-example（也就是官方例程），还有工程模板生成器(pico-project-generator)来避免自己来配置一个工程重复的部分。</p>
<p>最后需要CMake构建生成对应的makefile并构建，这其中需要对应的c编译器和arm c编译器完成上述过程。</p>
<p>具体过程如下文。</p>
<h2 id="下载必要软件"><a href="#下载必要软件" class="headerlink" title="下载必要软件"></a>下载必要软件</h2><p>这里主要是Windows上的方法，Linux上同理，但是安装软件要更简单，只在有配置区别的地方单独指出。目前我的环境是Windows11,不过Win10同理了。</p>
<ul>
<li><strong>CMAKE</strong><br>pico-project-generator生成的工程是基于cmake构建的，因此这里选择安装CMAKE。<br>安装的时候要勾选添加环境变量for all users。实际上就是系统环境变量。</li>
</ul>
<ul>
<li><p><strong>gcc-arm-none-eabi</strong><br><a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain">Arm GNU Toolchain</a>  ,用于编译ARM可执行文件。这里没啥特殊要求，可以下最新的。安装完了之后需要手动勾选添加到路径，还要检查一下能不能直接在cmd里面使用arm-none-eabi-gcc命令，否则说明他添加的路径有问题，就需要手工改一下（现在的版本应该不存在这个问题）</p>
</li>
<li><p><strong>python</strong>：<br>pico-project-generator是用python写的，因此需要python，后面pyocd也会用到，所以这里装上最好。<br>勾选环境变量，解除长路径限制。</p>
</li>
<li><p>Git<br>需要这个工具来从Github下载，虽然不用也可，但是用了更方便。<br>上面软件的直接到官网下载最新版安装就行了，不用纠结版本要不要旧一点。<br>当然，用别的Git工具也可以 。</p>
</li>
<li><p><strong>编译工具</strong><br>对于windows平台，这里有两种选择，一个是安装visual studio，一个是安装其他的编译器实现比如MinGW。<br>其中，前者的工具为NMake，使用的时候需要先启动vs的工作环境，得到配置好的环境变量（或者直接加载环境变量也可以），<br>后者的工具为Mingw32-make，配置更简单，只需要把bin目录加到环境变量就行，至于其他没有对比。后面就可以用mingw的mingw32-make来替代vs的Nmake，不需要额外加载环境变量。</p>
</li>
</ul>
<p>下面详细说说编译工具的安装：</p>
<p>前者从微软安装vs的社区版就好了，如果本来就有vs同时没有mingw又懒得再装一个，可以就用VS，不然<font color="#9bbb59">还是建议使用MinGW</font>。</p>
<pre><code>因为如果使用vs的nmake工具的话，后面的很多操作都需要从Visual Studio 2022 Developer Command Prompt这里打开其他的应用程序，使其具有内置的环境环境变量，这样会出现很多麻烦。官方手册里面提供的方法是VS,就感觉他们很随便。。。
</code></pre>
<p>VS的安装很简单，勾选C&#x2F;C++工具一路确定就好了，这里不再赘述。</p>
<p>MinGW的安装如下：</p>
<ol>
<li>下载MinGW后安装</li>
<li>把其安装目录下的bin目录加入环境变量, 需要手工添加，添加到用户变量或者系统变量都行。</li>
</ol>
<p><font color="#00b050">下载来源：</font><br>目前mingw新的是mingw-w64,下载网址： <a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW-w64 - for 32 and 64 bit Windows - Browse Files at SourceForge.net</a></p>
<p>点下面的MinGW-W64 GCC-8.1.0标题下面的包，因为如果用在线安装包，压根连不上网，和墙没关系。</p>
<pre><code>选择最新版本（目前是8.1.0）的 x86_64-win32-seh
</code></pre>
<p><a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-win32/seh/x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z">x86_64-win32-seh</a>这个表示64位pc windows系统 seh错误处理的包（具体怎么选可以搜一下mingw-w64的安装，这里贴个别人的链接，当作记录吧：<a href="https://www.jianshu.com/p/0be6d9684a81">mingw-w64 threads: posix vs win32 - 简书 (jianshu.com)</a>)。</p>
<p><font color="#00b050">注释：</font></p>
<p>我尝试直接用电脑上安装的devc++自带的mingw64，发现会编译报错，编译的时候可能会出现类似于<code>&#39;C:/Program&#39; 不是内部或外部命令，也不是可运行的程序</code>这样的问题，似乎并不是路径问题，总之我不太记得了，就不要偷懒还是安装一个最新版吧，这里最终用刚刚下载的新版的mingw-w64，测试OK.</p>
<p>（mingw32下载链接：<a href="https://osdn.net/projects/mingw/#">https://osdn.net/projects/mingw/#</a> 上面是旧版mingw32，2017年就停更了，可能也能用，没试过，放在这里提示不要下错了）</p>
<ul>
<li><p>其他构建工具<br>例如Ninja，我没试过，但是实际应该可行，Cmake是可以生成对应的文件的。</p>
</li>
<li><p><strong>调试或者下载工具</strong></p>
</li>
</ul>
<ol>
<li>openocd</li>
<li>pyocd</li>
</ol>
<p>上述二选一即可，推荐pyocd，本文开头已经说明了如何下载安装。</p>
<h2 id="下载例程、SDK、模板生成工具"><a href="#下载例程、SDK、模板生成工具" class="headerlink" title="下载例程、SDK、模板生成工具"></a><strong>下载例程、SDK、模板生成工具</strong></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、下载工程模板生成器</span></span><br><span class="line">    git clone https://github.com/raspberrypi/pico-project-generator.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、下载pico-sdk</span></span><br><span class="line">    git clone -b master https://github.com/raspberrypi/pico-sdk.git</span><br><span class="line">    cd pico-sdk/</span><br><span class="line">    # 更新子模块</span><br><span class="line">    git submodule update --init </span><br><span class="line">    cd ..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、下载官方例程</span></span><br><span class="line">    git clone -b master https://github.com/raspberrypi/pico-examples.git</span><br></pre></td></tr></table></figure>

<p>这里配置更新子模块的时候如果报错，就更新到最新的SDK，因为有的子模块上游更改了。</p>
<h3 id="配置SDK路径"><a href="#配置SDK路径" class="headerlink" title="配置SDK路径"></a>配置SDK路径</h3><p>上一步中，下好了pico-sdk,examples,还有generator，把pico-sdk放到自己想要放的位置，然后把其目录加到环境变量里面，名称是<strong>PICO_SDK_PATH</strong>. </p>
<p>这个环境变量的路径是给配置出来的CMakelist引用的，还有后面的模板生成器也需要配置这个环境变量，配置方法如下：</p>
<ol>
<li><p>Windows下面直接搜path，就能找到编辑系统环境变量的选项。</p>
<p> (其实这里没加也没关系，有别的方法，但是最好加上，因为generator默认用的是环境变量配置)。</p>
</li>
<li><p>可以使用使用powershell</p>
</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">setx PICO_SDK_PATH <span class="string">&quot;yourpath\pico-sdk&quot;</span> </span><br></pre></td></tr></table></figure>

<pre><code>yourpath指的是你pico-sdk所在文件夹的路径
</code></pre>
<ol start="3">
<li>当然也可以临时配置环境变量，但是没必要这样做, 不然每次都要重新导入环境变量：<br> 临时配置的方法：在powershell内执行</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$env:PICO_SDK_PATH</span>=pico<span class="literal">-sdk</span>的路径</span><br></pre></td></tr></table></figure>


<p><font color="#9bbb59">上面这些步骤配置完了之后就可以找个例程编译测试一下了。</font></p>
<p>Linux下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PICO_SDK_PATH=yourpath/pico-sdk</span><br></pre></td></tr></table></figure>

<p>添加这一行到<code> /etc/profile</code> 即可永久保存，不过也可以在后面CMAKE之前添加到shell即可。</p>
<h2 id="编译例程测试"><a href="#编译例程测试" class="headerlink" title="编译例程测试"></a>编译例程测试</h2><p>前面环境配置好了，例程里面的CMakeLists.txt也是已经写好的，所以这里简单来说就是两步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在example的上级目录生成makefile，当然这个命令具体下来有些变化</span></span><br><span class="line">cmake ..</span><br><span class="line"><span class="comment"># 然后对于linux来说执行make即可，Windows则有一点不同</span></span><br><span class="line"><span class="comment"># 执行构建</span></span><br><span class="line">make </span><br></pre></td></tr></table></figure>

<p>其实编译Example这个步骤不是必须的，但是最好测试一次，同时也演示了不配置IDE怎么编译。</p>
<p>下面详细说一下具体步骤和有什么变化。</p>
<h3 id="使用visual-studio的工具链"><a href="#使用visual-studio的工具链" class="headerlink" title="使用visual studio的工具链"></a>使用visual studio的工具链</h3><p>虽然前面推荐了使用MinGW, 但是如果一定坚持使用visual studio 的工具链，也就是官方手册指出的方法，那么具体步骤如下：</p>
<ol>
<li><p>打开Visual Studio 2022 Developer Command Prompt：</p>
<p> 搜索快捷方式或者WindowsTerminal打开（Windows Terminal点加号旁边的下拉，里面有选项），打开之后会提示：</p>
</li>
</ol>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">**********************************************************************</span><br><span class="line"></span><br><span class="line">** Visual Studio <span class="number">2019</span> Developer Command Prompt v16.<span class="number">7</span>.<span class="number">2</span></span><br><span class="line">** Copyright (c) <span class="number">2020</span> Microsoft Corporation</span><br><span class="line"></span><br><span class="line">**********************************************************************</span><br><span class="line"></span><br><span class="line">[vcvarsall.bat] Environment initialized <span class="keyword">for</span>: &#x27;x86_x64&#x27;</span><br></pre></td></tr></table></figure>
<p>那么这个环境就是正确打开了。✔</p>
<pre><code>这个表示加载了vs的环境，实际上也可以直接打开命令行之后通过执行`` vcvars64.bat ``这个文件来加载环境，也会给出一样的提示。
</code></pre>
<p>总而言是，现在打开了一个命令行或者powershell，继续使用这个加载过环境的命令行界面，然后切换到自己下载的pico-example目录。</p>
<pre><code>如果用cmd，工程切换到别的盘先要换盘符，然后cd进去；powershell可以直接cd带盘符的路径进去.
</code></pre>
<ol start="2">
<li>然后执行下面命令：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 现在打开这个shell的位置是pico-example这个文件下下面</span></span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake .. <span class="literal">-G</span> <span class="string">&quot;NMake Makefiles&quot;</span> </span><br></pre></td></tr></table></figure>

<p>这表示：</p>
<ul>
<li>新建一个build文件夹用于存放等会构建出来的内容。</li>
<li>进入build目录并在build目录内从pico-example(也就是相对build的上层目录)执行cmake，参数<code>-G &quot;NMake Makefiles&quot;</code>用于生成适用于Nmake的makefile.</li>
</ul>
<p>这一步，如果前面正确配置了PICO_SDK_PATH这个环境变量，或者已经导入这个环境变量，并安装了arm-none-eabi-gcc.exe且已经加入到PATH，这一步就能正确执行不会报错。</p>
<ol start="3">
<li>上面这一步在build目录中生成了所有工程的makefile，不用全部编译，进入build目录，找到一个例程例如blink 进入目录继续执行（目前命令行执行位置已经在build文件夹下了）：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blink</span><br><span class="line">nmake</span><br></pre></td></tr></table></figure>

<p>这时候看编译信息，可以看到正常生成的信息。</p>
<p>现在进入build&#x2F;blink，可以找到一个blink.uf2的文件，拿出开发板，按住BOOT按键插到电脑的USB上，右键xxx.uf2, 选择发送到RPI-RP2这个驱动器，发送完会自动运行。</p>
<pre><code>对于pico-example，也可以进入example下的build目录后执行make（对应nmake或者mingw32-make）后直接编译全部例程，但是这样耗时比较长，没有必要这样做。
</code></pre>
<p>这里注意，这里的命令行操作全程没有离开最开始打开的vs的prompt。</p>
<h3 id="使用MinGW工具链"><a href="#使用MinGW工具链" class="headerlink" title="使用MinGW工具链"></a>使用MinGW工具链</h3><p>现在，来到了我推荐的环节，不要管那个什么鸟VS了。直接使用MinGW来编译。</p>
<p>现在你打开了pico-example文件夹，在此处打开命令行，然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake .. -G &quot;MinGW Makefiles&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切到blink生成的目录中</span></span><br><span class="line">cd blink </span><br><span class="line">mingw32-make</span><br></pre></td></tr></table></figure>

<p>有没有发现特别简单？我也不用费劲解释为什么VS必须要打开环境才能用了，更何况后面还可能需要用其他的编辑器配合。</p>
<blockquote>
<p>如果你不幸之前已经使用cmake生成了Nmake的makefile了，再想要换成mingw32-make，这时候直接使用 <code>cmake -G &quot;MinGW32 Makefiles&quot; </code>生成makefile的话，会报错之前使用的不符合现在的配置，与之前的cmake generator不符，需要将build下的cmakecache文件删掉，再指定MinGW Makefiles.(也可以使用cmake-gui.exe直接手动切换)。不过实际操作用generator生成模板的时候可能有好几个cmakecache.txt都要删除，不然还是会报错。所以建议一开始就搞好。</p>
</blockquote>
<h3 id="解释一下上面的语句"><a href="#解释一下上面的语句" class="headerlink" title="解释一下上面的语句"></a>解释一下上面的语句</h3><p>这里cmake是用于生成make构建工具对应的makefile。-G后面的参数用来指定工具，也可以用来生成IDE对应的工程文件。</p>
<p>使用<code>cmake --help</code>可以看到很多指令参数，里面有各种generator的名称，注意大小写,例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Borland Makefiles            = Generates Borland makefiles.</span><br><span class="line">NMake Makefiles              = Generates NMake makefiles.</span><br><span class="line">NMake Makefiles JOM          = Generates JOM makefiles.</span><br><span class="line">MSYS Makefiles               = Generates MSYS makefiles.</span><br><span class="line">MinGW Makefiles              = Generates a make file for use with</span><br><span class="line">                               mingw32-make.</span><br><span class="line">Green Hills MULTI            = Generates Green Hills MULTI files</span><br><span class="line">                               (experimental, work-in-progress).</span><br><span class="line">Unix Makefiles               = Generates standard UNIX makefiles.</span><br><span class="line">Ninja                        = Generates build.ninja files.</span><br><span class="line">Ninja Multi-Config           = Generates build-&lt;Config&gt;.ninja files.</span><br><span class="line">Watcom WMake                 = Generates Watcom WMake makefiles.</span><br></pre></td></tr></table></figure>

<p>比如也有人用Ninja，但是那需要ninja的构建文件，同mingw步骤。</p>
<p>以上就是标准的例程配置方法，现在我们可以考虑新建一个属于自己的工程了。</p>
<h2 id="生成自己的工程并编译"><a href="#生成自己的工程并编译" class="headerlink" title="生成自己的工程并编译"></a>生成自己的工程并编译</h2><p>你完全可以自己写cmakelists.txt，但是既然官方提供了模板生成器，这里就不去深究了。</p>
<p>所以这一步就是使用pico-project-generator生成工程模板，下文中把pico-project-generator称作生成器。</p>
<p><strong>p.s.</strong>  这里提前说一下，如果生成器启动有问题，首先更新pico-project-generator到最新的python源文件；有的早期教程中指出是python解释器的问题，但是现在生成器在windows下面没有问题，能正常使用，不需要改动python的源码等步骤（是新版的python没有这个问题，3.10）。</p>
<p>进入pico-project-generator目录下，右键打开shell，运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python ./pico_project.py --gui</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">python ./pico_project.py -g</span><br></pre></td></tr></table></figure>

<p>这样就可以通过图形界面的方式来配置自己的新建工程。这时候生成的工程会和这个py文件在同一个目录下，所以这里建议找到pico_project.py 647行的</p>
<p><code>self.locationName.set(os.path.abspath(os.getcwd())</code>, 修改改成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.locationName.<span class="built_in">set</span>(os.path.abspath(os.path.join(os.getcwd(), <span class="string">&quot;..&quot;</span>)))</span><br></pre></td></tr></table></figure>

<p>这样默认路径是pico_project.py的上层目录而不是与生成器的python文件在同级目录。这样就可以避免工程的生成位置位于pico-project-generator文件夹中。。。。。</p>
<p>然后建议去掉开头那个logo，，，因为对于高分屏幕话，python的TK-GUI会出现不合适的缩放会导致最后点不到<font color="#548dd4">确定</font>按钮。。。。。就是下面这两行。（也可以通过选择你使用的python.exe,右键更换高DPI兼容模式防止出现主界面超大的情况）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.logo = tk.PhotoImage(file=GetFilePath(<span class="string">&quot;logo_alpha.gif&quot;</span>))</span><br><span class="line">logowidget = ttk.Label(mainFrame, image=self.logo, borderwidth=<span class="number">0</span>, relief=<span class="string">&quot;solid&quot;</span>).grid(row=<span class="number">0</span>,column=<span class="number">0</span>, columnspan=<span class="number">5</span>, pady=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>这样就打开了生成器，然后按照需要勾选内容, 如下：</p>
<img src="/2022/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/0_RP2040%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/pico-project-generator1.png" class>

<p>这样生成器就会根据指定的参数和默认的参数来生成工程需要的cmakelist和其他文件，其中指定参数至少需要指定PICO_SDK_PATH和把armgcc的bin目录加入环境变量，否则生成器会报错，而其他的参数可以使用默认值。</p>
<p>生成器的作用是复制需要的文件和生成对应的cmakelist，同时自动执行<code>cmake -G &#39;xxxmake Makefile&#39;</code>. （个人认为其实这个没有必要每次都执行，后面使用ide的时候也会配置cmake的生成参数的，不过生成器没直接提供不执行cmake -G的方法）</p>
<p>具体可以看<a href="https://github.com/raspberrypi/pico-project-generator">raspberrypi&#x2F;pico-project-generator: Tool to automatically generate a Pico C SDK Project (github.com)</a>项目的readme，或者在命令下加上 –help来查看帮助。生成器本身也可以只在命令环境下执行，看需要自由发挥了。</p>
<p><strong>p.s.这里得注意</strong>，默认情况下，在这个生成器代码中mingw的优先级高于vs，所以配置了两者都有的话，生成器优先生成基于mingw的工程，当然了，只是cmake -G的参数不同，可以改也可以自己切换。</p>
<p>注意，<font color="#953766">在前面配置的编译工具是使用VS的情况下</font> :</p>
<blockquote>
<p>这里如果在生成器中勾选Run build afer generation，那么打开生成器的步骤变化为：<br>先进入Visual Studio 2022 Developer Command Prompt的环境，然后在这个命令行里面执行python命令来打开打开这个生成器，不然没有对应的环境来执行build。<br>不过可以选择不勾选这个选项来避免这一步。</p>
</blockquote>
<p>现在你已经得到自己的项目模板了，下一步是编写代码并编译。</p>
<p>为了简单一点，假设这里只有一个包含main函数的c文件，默认也是生成这个，进入工程目录下，只有一个 <code>工程名.c </code>文件，main函数就在里面。</p>
<p>这时候只有这一个.c文件，也就是cmakelist不需要改动，现在进入工程目录下的build目录，如果没有就新建一个，然后手工编译验证的步骤和上面编译例程一样，下面重复一次：</p>
<h3 id="如果是使用VS"><a href="#如果是使用VS" class="headerlink" title="如果是使用VS"></a>如果是使用VS</h3><p>那么直接从Visual Studio 2022 Developer Command Prompt进入工程下build目录，执行nmake就行了。</p>
<p>如果添加了其他的源文件，就修改cmakelist.txt , 然后重新执行cmake -G “NMake Makefiles”，然后nmake就好.</p>
<h3 id="是MinGW的情况"><a href="#是MinGW的情况" class="headerlink" title="是MinGW的情况"></a>是MinGW的情况</h3><p>正如前面例程编译的情况一样简单，</p>
<p>直接打开生成器生成工程，然后直接在工程目录内的build目录下执行<code>mingw32-make</code> 就可以编译了，需要更新makefile的话就是执行<code>cmake -G &quot;MinGW Makefiles&quot;</code></p>
<p>这时候，由于在Cmakelists.txt中默认配置打开了生成UF2文件，除了ELF文件，编译后生成的uf2，都在工程下build目录里面。</p>
<p>以上，就是标准的工程创建和配置流程。刚刚使用例程的时候已经知道怎么下载UF2了，所以单片机已经可以跑起来自己的程序了。</p>
<p>现在剩下最后一个问题，如何调试？</p>
<blockquote>
<p>至于cmakelist.txt怎么用，参考文档<a href="%E8%BF%99%E9%87%8C%E8%BF%98%E6%B2%A1%E5%86%99">xxxxx</a>（）TODO,cmake的官方文档也很坑就是了。</p>
</blockquote>
<p>p.s 插一句，官方的生成器有很多毛病，不过在这一步不影响，下一章中配置vscode的时候我再介绍。</p>
<h1 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h1><p>这一部分单独拿出来做一个大标题，因为要说的内容比较基础，基本上后面能用上。</p>
<h2 id="调试的硬件连接"><a href="#调试的硬件连接" class="headerlink" title="调试的硬件连接"></a>调试的硬件连接</h2><p>正如前面所说，你需要一个具有SWD接口的ARM Debugger，在本文的开头已经说了有哪些是测试没有问题的。<br>连线不用介绍了，由于官方Pico板子的Debug插座没有供电，因此需要自己接上Pico的供电或者接到排针上，其实不算方便。。。</p>
<p>但是其实还有一个更简单的方法，这里介绍两种方法，这里先介绍这个简单方法。</p>
<h3 id="自调试"><a href="#自调试" class="headerlink" title="自调试"></a>自调试</h3><p>由于RP2040具有双核，有一位老哥开发了一个固件，可以让DAP-Link的固件跑在另外一个核心，程序运行于RAM中，这个核心可以调试另外一个核心，因此只需要插上开发板就可以调试了。</p>
<p>优点：不用说，只需要一根USB线就能调试了。</p>
<p>适用范围：单核开发，不需要调试USB的情况下可以使用，且内存没占满。</p>
<p>缺点：</p>
<ul>
<li><p>占用USB,占用一个核心。不过实际上，如果USB的功能最后再加进去，也可以下载进去，需要开发另外一个核心同理，只是不能调试了。同样，由于USB占用了，所以PLL_USB不能调整，（本来PLL_USB也就是固定48Mhz的吧），使用了PLL_USB的外设自然也不能调整时钟。</p>
</li>
<li><p>GIMMECACHE only: SRAM 0x2003C000 to 0x2003FFFF must not be used by user code），代价是占用16k内存。有两个固件，如果用另外一个固件就会占用flash cache。</p>
</li>
</ul>
<p>步骤：<br>使用USB下载 pico-debug-gimmecache.uf2 固件到rp2040，不下电，然后这里就得到了一个DAPLink了。</p>
<h3 id="外部调试器"><a href="#外部调试器" class="headerlink" title="外部调试器"></a>外部调试器</h3><ol>
<li>买一个rp2040当做一个picoprobe</li>
<li>其他的daplink或者jlink</li>
</ol>
<p>前面说过了，picoprobe需要openocd专用配置，不过pyocd似乎可以直接支持。</p>
<p>仍然优选后者，实测pyocd速度也会更快一点。<br>没有什么特殊的，连上线就好了。</p>
<p>p.s.在旧版的pico-sdk中我曾经遇到过使用外部调试器的时候出现速度奇慢无比,在sleep_ms更是直接卡死的问题,经过测试,新版的pico-sdk似乎修复了这个问题.</p>
<p>下面介绍调试软件使用。</p>
<h2 id="手工调试方法（GDB使用）"><a href="#手工调试方法（GDB使用）" class="headerlink" title="手工调试方法（GDB使用）"></a>手工调试方法（GDB使用）</h2><pre><code>参考资料：getting-started-with-pico.pdf 5.3章节 第六节
</code></pre>
<p>这一部分不是必要，但是如果了解了，对于这一堆东西会有更好的理解。<br>在上一步中，获得了一个ELF文件，也就是可执行文件，现在要做两件事：</p>
<ol>
<li>加载这个文件到单片机中</li>
<li>加载之后还能调试</li>
</ol>
<p>其实如果已经有嵌入式开发的经验，这里就很好理解，我们需要一个gdb来调试，而需要有一个工具来启动一个gdbsever.</p>
<p>好了现在回到了最开头说的，Debugger的上位机，官方教程给出的方法是使用OpenOCD来作为调试上位机，这里也先介绍一下，然后介绍pyocd的方法。</p>
<h3 id="使用openocd打开GDB-server"><a href="#使用openocd打开GDB-server" class="headerlink" title="使用openocd打开GDB server"></a>使用openocd打开GDB server</h3><ol>
<li><p>添加openocd.exe到环境变量</p>
</li>
<li><p>执行下述命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openocd -f board/pico-debug.cfg</span><br></pre></td></tr></table></figure>

<p>这时候回显会提示：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Warn : rp2040-core0.cfg configuration file is deprecated and will be removed <span class="keyword">in</span> the next release. Use following parameters instead: -c <span class="string">&#x27;set USE_CORE 0&#x27;</span> -f target/rp2040.cfg</span><br></pre></td></tr></table></figure>

<p>大致解释一下，这个pico-debug.cfg实际上内容就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source [find interface/cmsis-dap.cfg]</span><br><span class="line">adapter speed 4000</span><br><span class="line">set CHIPNAME rp2040</span><br><span class="line">source [find target/rp2040-core0.cfg]</span><br></pre></td></tr></table></figure>

<p>因此最上面这个命令等效于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openocd -f interface/cmsis-dap.cfg -f target/rp2040-core0.cfg -c  <span class="string">&#x27;adapter speed 4000&#x27;</span> -c <span class="string">&#x27;set CHIPNAME rp2040&#x27;</span></span><br></pre></td></tr></table></figure>

<p>按照提示,下面的方法会得到一样效果（<code>-c &#39;set USE_CORE 0&#39;</code>要放中间）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openocd -f interface/cmsis-dap.cfg -c <span class="string">&#x27;set USE_CORE 0&#x27;</span>-f target/rp2040.cfg  -c <span class="string">&#x27;adapter speed 4000&#x27;</span> -c <span class="string">&#x27;set CHIPNAME rp2040&#x27;</span> </span><br></pre></td></tr></table></figure>

<pre><code>不过实际上,openocd可能有bug，上面两个命令可能有时候会出现不一样的结果，一个好用一个不好用。所以继续看下面。
</code></pre>
<p>总而言之，这一步用openocd打开了一个gdbserver.</p>
<h3 id="使用pyocd打开GDBserver"><a href="#使用pyocd打开GDBserver" class="headerlink" title="使用pyocd打开GDBserver"></a>使用pyocd打开GDBserver</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyocd gdbserver -t RP2040 -f 10000k</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定目标RP2040 ,指定速度10M,希望能加载快一些。</span></span><br></pre></td></tr></table></figure>

<p>现在已经打开了pyocd内置的gdbserver. 相比使用openocd，这个参数<font color="#9bbb59">超级简单！！！</font>，有更多更简单的参数配置，如果有需要在命令行中调试，可以参考我写的<a href="https://alwaysmy.github.io/2023/04/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8aardio%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Epyocd%E7%9A%84%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8B%E8%BD%BD%E5%99%A8/">使用aardio写一个基于pyocd的单片机下载器 | 加载中… (alwaysmy.github.io)</a> 利用这个工具配置命令。</p>
<p>好了，现在不管怎么样，都用一个上位机工具打开了gdbserver连接了目标单片机。下面要进行调试了。</p>
<h3 id="GDB调试使用例子"><a href="#GDB调试使用例子" class="headerlink" title="GDB调试使用例子"></a>GDB调试使用例子</h3><p>上一步中打开了一个gdbserver, 不要关闭那个命令行界面，它会监听端口等待连接。另外开一个terminal， 然后需要attach gdb to the server.</p>
<p>假设前面已经编译得到了picoboard_blinky.elf这个固件，在固件同级目录下打开终端，然后</p>
<ol>
<li><p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux下输入：</span></span><br><span class="line">gdb-multiarch picoboard_blinky.elf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在Windows下输入：</span></span><br><span class="line">arm-none-eabi-gdb.exe picoboard_blinky.elf</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>吐个槽，manjaro还需要借arch的包安装gdb-multiarch</p>
</blockquote>
<p>这时候另外一个等待的命令行就可以看到连接信息。这边连接之后，命令行会变成<br><code>(gdb)</code>开头，这是自带的开头，不用自己输入。</p>
<ol start="2">
<li>然后连接gdb上去。<br>输入    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">target remote localhost:3333 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span>  </span><br><span class="line">target remote :3333 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span>  </span><br><span class="line">target extended-remote :3333</span><br></pre></td></tr></table></figure>

同理，也可以远程调试，比如 <code>target remote 192.168.31.16:3333</code> 当然，远程连接的时候要先检测对应端口有没有被防火墙拦。<br>观察到的效果是：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) target remote localhost:3333 </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>加载 picoboard_blinky.elf 到 flash:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) load</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行下面命令开始运行程序：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) monitor reset init</span><br><span class="line">(gdb) continue</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如果需要下断点，提前使用命令下好然后continue，也可以在编译之前时候就下好断点，这里演示了在main函数处添加一个breakpoint：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) monitor reset init</span><br><span class="line">(gdb) b main # 在main函数添加一个断点</span><br><span class="line">(gdb) continue</span><br></pre></td></tr></table></figure>
<p>如果提前配置好了断点，程序会运行到断点的时候停止，然后执行continue即可。</p>
<p>p.s.连接的时候会提示这个单片机有多少硬件断点，这个是不能超过这个断点量的，不然会出错。<br>（JLink有自己的软件断点技术，那个另外说）。</p>
<ol start="6">
<li><p>也可以中途使用 <code>file filename.elf</code> 来更换执行文件，更换后用<code>load</code>加载。Ctrl+c来暂停正在运行的程序。</p>
</li>
<li><p>windows下输入<code>exit</code>或者ctrl-d退出gdb调试。</p>
</li>
</ol>
<p>注意使用自调试固件的时候下不要尝试调试带usb的程序，会出bug，因为daplink本身就用了USB, 会导致daplink失效，不过这样依然能把程序通过SWD烧录进去。</p>
<h2 id="官方方法工程配置总结"><a href="#官方方法工程配置总结" class="headerlink" title="官方方法工程配置总结"></a>官方方法工程配置总结</h2><p>其实前面说过了，姑且当他首尾呼应吧。</p>
<ol>
<li>配置好环境，下好官方sdk和例程还有生成器，配置好环境变量。</li>
<li>使用生成器生成工程（其实自己写cmakelists或者复制例程里面的cmakelist改一改然后复制必要的文件，自己做成模板是也可以）</li>
<li>使用make（mingw32-make)或者nmake编译</li>
<li>编译得到的uf2可以直接使用USB加载到Flash中后经过自带Bootloader启动；编译得到的elf可以使用swd烧录或调试（调试需要之前就编译参数指定为debug），bin文件可以直接烧录到flash。</li>
<li>注意工程路径最好不要有中文。</li>
</ol>
<h1 id="配置自己的IDE"><a href="#配置自己的IDE" class="headerlink" title="配置自己的IDE"></a>配置自己的IDE</h1><p>这一步基于上一步的C-SDK开发环境来完成，而不是前面说的已经集成模板配置完全的那些IDE。<br>上一步中，直接打开文件夹里面文件编辑和编译，配置文件也不方便，编译烧录调试更不方便，这些都需要在命令行里面执行。</p>
<ol>
<li><p><strong>首先选的可以是使用CMakelist作为配置的ide</strong>，这样直接建立工程就能用而不需要修改配置。比如：</p>
<ul>
<li>QtCreator</li>
<li>Netbeans</li>
<li>KDevelop Kdevelop 使用CMake作为其主要的项目配置方式。除此之外还支持qmake、makefile</li>
<li>codelite</li>
<li>Clion</li>
</ul>
<p>然而这里先说结论，除了CLion，其他的似乎都没有对嵌入式编程的调试有任何优化，编译很容易，但是调试很难配置，调试起来也麻烦，下面说。</p>
</li>
<li><p><strong>其他IDE</strong><br>CMake能够生成一些IDE的工程配置文件（如Visual Studio、CodeBlocks、XCode，Kate，CodeLite），比如Eclipse就有MCU的插件（这也是官方文档给出的方法之一），具体生成参数还是使用cmake –help来查询。</p>
</li>
<li><p>VSCODE这种宇宙第一(?)编辑器<br>这个方法后面单独说。</p>
</li>
</ol>
<p><strong>一般配置方法</strong></p>
<p>无论哪种方法，如果前面没有配置系统环境变量，那么需要在IDE内配置环境变量，但是如果之前配置过了系统环境变量，或者比如有的IDE集成了armgcc可选，那么这一步就忽略就好了：</p>
<p><code>PICO_SDK_PATH=D:\MyProgramData\MCU_SDK\pico-sdk</code></p>
<p><code>PICO_TOOLCHAIN_PATH=C:\Program Files (x86)\GNU Arm Embedded Toolchain\10 2021.10\bin\arm-none-eabi-gcc.exe</code></p>
<p>把这两条添加到IDE中对应的位置。<br>（其实这个arm gcc电脑上各个单片机开发的IDE内的都下了好几个了，甚至和platformio下载的共用一个都行）</p>
<h2 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h2><p>使用CMakelist来构建的IDE其中最有名的可能是CLion了，官方start文档也给出了怎么配置基于CLion来配置.</p>
<p>如果需要配置环境，打开Clion后点设置，选 构建、执行、部署 ，CMake，点环境：增加用户环境变量。</p>
<p>在Clion中文件的路径，来源，函数来源都显示很清楚，引用的sdk也能直接显示出来，使用是比较方便的。</p>
<p>他确实方便，直接打开前面步骤中配置好的文件夹为Clion工程，配置一下openocd就可以用了。文件编辑什么的都很方便。</p>
<p>编译比vscode快不少。</p>
<p>具体方法：我的文档【CLion配置rp2040工程】（TODO:未上传，总之很简单。。。）</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p>官方文档：getting-started-with-pico.pdf 10.2. Using CLion<br><a href="https://www.stlee.tech/2021/06/14/CLion-%E4%B8%AD%E5%BC%80%E5%8F%91-RaspberryPi-Pico/">CLion 中开发 RaspberryPi Pico | St.Lee的个人站 (stlee.tech)</a></p>
<h2 id="VScode作为IDE"><a href="#VScode作为IDE" class="headerlink" title="VScode作为IDE"></a>VScode作为IDE</h2><p>这一部分实际上我写了个简化版：<a href="https://alwaysmy.github.io/2023/04/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/RP2040%E9%85%8D%E7%BD%AEVSCODE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E7%89%88/">RP2040配置VSCODE开发环境 —— 一劳永逸版 | 加载中… (alwaysmy.github.io)</a></p>
<p>通过插件支持完成对嵌入式设备的调试和对Cmake的支持。需要安装CMakeTool cortex-debug，因为配置了cmake或者cortex-debug之后就不用自己写task.json了，还算方便。下面是步骤。</p>
<ol>
<li><p>安装CMake插件</p>
<p> 打开设置，搜索 CMake Tools Configuration</p>
<p> 找到Configure Environment, 添加上面最开始说的两个环境变量（如果已经有配置好的系统或者用户环境变量就可以不用配置）</p>
<p> 找到CMake Tools Configuration - Generator，设置为NMake Makefiles或者MinGW Makefiles. 前者是对应使用VS的编译器，后者是对应使用mingw的编译器。</p>
<p> 打开项目文件夹，第一次打开的时候会提示选择工具包，点一下选择有arm-none-eabi的这一项。选错过了也没关系，就在最下面的底边栏。如下图</p>
</li>
</ol>
<img src="/2022/12/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/0_RP2040%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E5%BA%95%E8%BE%B9%E6%A0%8F%E9%80%89%E6%8B%A9%E5%B7%A5%E5%85%B7%E7%AE%B1.png" class title="s">

<ol start="2">
<li><p>安装插件：cortex-Debug</p>
<p> 打开文件夹之后，按F7是Cmake的build，F5是cortex-debug的调试，当然具体快捷键是什么得看自己vscode的配置，这两种都能编译，后者会编译后启动openocd进行调试。</p>
</li>
<li><p>创建配置了vscode的工程</p>
<p>前面使用生成器的时候，勾选IDE Options上的创建vscode project，会自动生成vscode的配置.vscode。不过目前这个生成器的参数是有问题的，后面自己改一下保存成模板，以后自己复制到工程文件夹就行。</p>
</li>
</ol>
<p>p.s.关于这个生成器修改成直接可以用的版本<a href="https://github.com/alwaysmy/pico-project-generator_fix">alwaysmy&#x2F;pico-project-generator_fix</a></p>
<p><strong>额外事项：</strong><br>如果前面使用的是vs的工具链而不是mingw，可以直接从Windows terminal里面加号打开Visual Studio 2022 Developer Command Prompt，这个实际上是<code>%comspec% /k &quot;C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\Tools\VsDevCmd.bat</code>  </p>
<p>然后输入code打开vscode(vscode安装的时候默认添加到环境变量里面了,所以可以输入code来打开)</p>
<p>说个简单点的启动方法：</p>
<p>找到电脑上的<code>C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat </code>如果是32位机器就选后缀32的（现在应该不会还有人用32位机器吧），然后打开这个批处理，然后执行code。</p>
<p>所以可以写成脚本：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> &quot;C:\Program Files\Microsoft Visual Studio\<span class="number">2022</span>\Community\VC\Auxiliary\Build\vcvars64.bat&quot;</span><br><span class="line">code</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>配置vscode 的Debug</li>
</ol>
<p>这一部分依然推荐看我的文章<a href="https://alwaysmy.github.io/2023/04/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/RP2040%E9%85%8D%E7%BD%AEVSCODE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E7%89%88/">RP2040配置VSCODE开发环境 —— 一劳永逸版</a>在附录中添加的修改后的生成器代码，下面就当作是解释了。<br>这里关键是配置项目文件夹内.vscode下的配置json文件, 这些文件在使用生成器的时候会自动生成，下面分每个文件说一下。<br>launch.json：<br>    首先是gdb的路径没有适配系统，原来默认gdbPath是gdb-multiarch, 在Windows下要改成 arm-none-eabi-gdb.exe<br>    然后configFiles的内容根据自己用的仿真器修改。</p>
<p>setting.json：<br>    全局设置已经配置好的话，这里可以不修改，也可以把之前的插件设置的全局设置挪到这里来变成工程设置，比如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  &quot;cortex-debug.armToolchainPath&quot;: &quot;&quot;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &quot;cortex-debug.openocdPath.windows&quot;: &quot;D:\\MyPrograms\\1_DevelopTools\\MCU_Tools\\openocd-04887d3b6-i686-w64-mingw32\\bin\\openocd.exe&quot;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &quot;cortex-debug.openocdPath&quot;: &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;cmake.generator&quot;: &quot;MinGW Makefiles&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;cmake.generator&quot;: &quot;NMake Makefiles&quot;</span></span><br></pre></td></tr></table></figure>

<p>同时cmaketool的几个按钮它默认候隐藏了，实际上确实没啥用，可以单独把Build按钮显示出来方便单独编译，就是改成default。</p>
<p>extensions.json：<br>就是推荐的插件</p>
<p>另外，打开工程后，会提示使用Cmake的智能感知，这会在build下添加一个json用来给c_cpp的智能感知添加一个包含路径的配置，这样就能正确识别SDK的文件路径，所以c_cpp_properties.json没啥用了。</p>
<p>总结：<br>使用vscode的缺点是启动相当慢,差不多要两分钟，后面每次大概半分钟，应该可以改编译配置吧，没仔细看。<br>启动调试快捷键是ctrl+shift+D或者F5 ,F7只能编译。<br>不知道怎么支持RTT输出或者semihost的方法输出打印，所以还是用串口调试吧。</p>
<h2 id="其他IDE配置"><a href="#其他IDE配置" class="headerlink" title="其他IDE配置"></a>其他IDE配置</h2><p>下面的配置都不太好用我觉得。。当作记录吧，有的根本没写完。</p>
<h3 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -G &quot;Eclipse CDT4 - MinGW Makefiles&quot;</span><br></pre></td></tr></table></figure>

<p>参考官方教程，很详细。如果不想单独下个eclipse的话，看看电脑上哪个基于eclipse的IDE不是阉割的可以直接拿来用,不过我没找到。。</p>
<h3 id="Kdevelop："><a href="#Kdevelop：" class="headerlink" title="Kdevelop："></a>Kdevelop：</h3><p><a href="https://www.kdevelop.org/download">Download | KDevelop</a></p>
<p>结论：不好用不会用。</p>
<p>更新有点慢，上次更新还是两年前。。怎么用Windows编译器的文档上次更新还是六年前。。。</p>
<p>然而，这个IDE没啥用，添加文件还是要自己写cmakelist。。。。并没有方便，虽然cmakelist可以图形管理。。<br>甚至编译后生成的文件都要重新加载才能显示。</p>
<p>debug配置方法：</p>
<p>运行-配置启动-然后更改gdb选项就可以用gdb调试了。</p>
<p>for the target set it to executable and the path to <code>build/your-project-name.elf</code></p>
<p>Click on the Debug part of the launch configuration and set the debugger executable to <code>/usr/bin/arm-none-eabi-gdb</code></p>
<p>Set the Run gdb script to the script created in the previous step. Click apply.</p>
<p>脚本内容：<br>    target remote localhost:3333<br>    # monitor arm semihosting enable<br>    mon reset halt<br>    # openocd must be running in the correct dir for the relative paths to work<br>    # Flash<br>    mon flash write_image erase unlock build&#x2F;your-project-name.bin 0x08000000<br>    mon verify_image build&#x2F;your-project-name.bin 0x08000000<br>    mon reset halt<br>    # Not sure why but this is needed for KDevelop<br>    file build&#x2F;your-project-name.elf<br>    load<br>    mon reset halt<br>    disconnect<br>    target remote localhost:3333</p>
<p>然后：<br>    openocd -f interface&#x2F;stlink.cfg -f board&#x2F;stm32h7x3i_eval.cfg</p>
<p>下面是参考资料：</p>
<p><a href="https://github.com/KDE/kdev-embedded">KDE&#x2F;kdev-embedded: Plugin for KDevelop to support the development of embedded systems (github.com)</a></p>
<p><a href="https://www.codelv.com/blog/2019/7/use-kdevelop-with-openocd-and-mbed-os">Use KDevelop with OpenOCD and mbed-os - CodeLV</a></p>
<p>放弃，我这里会提示elf不是启动文件，上面的教程是kdevlop3.</p>
<p>至于那个插件，是七年前的了。</p>
<p>安装，工程-打开&#x2F;导入-选择刚刚生成的工程文件夹，点构建就可以构建了。<br>使用yay -S gdb-multiarch 安装gdb-multiarch </p>
<p>linux下可以直接打开工程并构建，linux下的版本也更新，5.9到了。</p>
<h3 id="Kate"><a href="#Kate" class="headerlink" title="Kate"></a>Kate</h3><p>这个编辑器倒是算是正常。</p>
<p>不过仍然是linux下比较正常，windows下有bug，而且没有默认的gdb前端插件，所以没法调试，可能可以写插件来支持。。。</p>
<p>在linux下<br>使用yay -S gdb-multiarch 安装gdb-multiarch<br><a href="https://aur.archlinux.org/packages/gdb-multiarch">https://aur.archlinux.org/packages/gdb-multiarch</a><br>如果报错patch的话就显pamac install patch</p>
<p>点下面的构建，然后<br>构建插件编写为：<br>cd .&#x2F;build &amp;&amp; make<br>添加一个cmake构建命令<br>cmake -G “Kate - Unix Makefiles”&#x2F;&#x2F;或者Kate - MinGW Makefiles<br>添加一个构建cmake并编译命令<br>cmake -G “Kate - Unix Makefiles”&amp;&amp;cd .&#x2F;build &amp;&amp; make</p>
<p>这样就可以完成编译功能了。</p>
<p>调试功能：（只有linux下支持这个插件。。）</p>
<p>配置GDB<br>点下面的调试<br>GDB 设置<br>高级设置<br>改成远程TCP<br>自定义初始化脚本：不知道咋搞，应该和上面kdevelop的差不多。</p>
<p>如果不需要这个gdb前端的功能只需要烧录的话，可以使用外部工具的功能执行命令来调用swd烧录elf文件。</p>
<h3 id="Codelite"><a href="#Codelite" class="headerlink" title="Codelite"></a>Codelite</h3><p>这个IDE也是可以基于Cmake的，可以直接用cmake -G “CodeLite - MinGW Makefiles”来转一个工程出来。</p>
<p>实测能用，效果还不错，但是配置调试比较麻烦，而且不管调试器连接没连上，都会提示连上了。。。而且似乎压根没法调试。但是确实能连上openocd而且烧录进入了。</p>
<p>利用外部工具执行烧录还是可以的。</p>
<p>同理，cmake的命令配置为<br>CodeBlocks - MinGW Makefiles</p>
<p>参考：下面这是个stm32的配置<a href="https://blog.csdn.net/u012750409/article/details/52516653">https://blog.csdn.net/u012750409/article/details/52516653</a></p>
<h3 id="Embedded-IDE-on-vscode（EIDE）"><a href="#Embedded-IDE-on-vscode（EIDE）" class="headerlink" title="Embedded IDE on  vscode（EIDE）"></a>Embedded IDE on  vscode（EIDE）</h3><p>这个插件很强大，同时支持导入eclipse gcc的项目，所以可以通过<br>cmake -G “Eclipse CDT4 - MinGW Makefiles”来生成eclipse的GCC项目导入到vscode 的embedded IDE</p>
<p>就是这样有点麻烦。<br>由于 Eclipse CDT 和 EIDE 之间的设计差异，EIDE 暂时不能兼容 Eclipse 项目中的一些项目属性和构建设置<br>导入完成后，将生成一个 <code>.warning.txt</code> 文件，其中记录了所有不兼容的 Eclipse 项目属性</p>
<p>您需要根据这些属性的 <code>名称</code> 和 <code>值</code> 的含义修改 EIDE 项目的 <code>构建器选项</code>，直到可以正确编译</p>
<p>但是，它同样需要cortex-debug插件来支持调试。所以。。。没啥意义似乎。</p>
<p>其实作者写了一个rp2040的模板可以直接用：<br><a href="https://discuss.em-ide.com/d/180-rp2040-pico">RP2040 Pico 项目模板 - Embedded IDE Forum (em-ide.com)</a></p>
<h1 id="其他另类方法"><a href="#其他另类方法" class="headerlink" title="其他另类方法"></a>其他另类方法</h1><p><a href="https://make.playpiper.com/">Piper Make (playpiper.com)</a><br>拖拽式网页图形编程。</p>
<h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><h2 id="Linux环境的配置的补充"><a href="#Linux环境的配置的补充" class="headerlink" title="Linux环境的配置的补充"></a>Linux环境的配置的补充</h2><p>安装软件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install cmake gcc-arm-none-eabi libnewlib-arm-none-eabi libstdc++-arm-none-eabi-newlib make</span><br></pre></td></tr></table></figure>

<p>然后配置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> pico-sdk</span><br><span class="line"><span class="built_in">export</span> PICO_SDK_PATH=`<span class="built_in">pwd</span>` </span><br></pre></td></tr></table></figure>

<h3 id="基于WSL安装PICO-C-SDK环境"><a href="#基于WSL安装PICO-C-SDK环境" class="headerlink" title="基于WSL安装PICO C-SDK环境"></a>基于WSL安装PICO C-SDK环境</h3><p>大可不必。<br>但是如果遇到了，有一些额外的问题。</p>
<ol>
<li><p>编译的时候提示cmake版本不够，我尝试编译新版的cmake, 然后发现是国内源的问题，先换回官方源了.</p>
</li>
<li><p>如果是WSL下需要先需要手工安装tkinter来打开生成器（一般不需要）<br>sudo apt-get install python3-tk<br>打开生成器。<br>python3 pico_project.py –gui</p>
</li>
</ol>
<h2 id="使用SWD下载烧录方法"><a href="#使用SWD下载烧录方法" class="headerlink" title="使用SWD下载烧录方法"></a>使用SWD下载烧录方法</h2><p>这里是直接下载。</p>
<p>如果使用openocd，那么</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openocd -f interface/raspberrypi-swd.cfg -f target/rp2040.cfg -c &quot;program blink.elf verify reset exit&quot;</span><br><span class="line">openocd -f interface/cmsis-dap.cfg -f target/rp2040.cfg -c &quot;program blink.elf verify reset exit&quot;</span><br></pre></td></tr></table></figure>

<p>如果使用Pyocd，那么</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyocd flash --erase chip --target rp2040 blink.elf</span><br></pre></td></tr></table></figure>

<p>我依然推荐我写的GUI工具：<br><a href="https://alwaysmy.github.io/2023/04/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8aardio%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Epyocd%E7%9A%84%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8B%E8%BD%BD%E5%99%A8/">使用aardio写一个基于pyocd的单片机下载器 | 加载中… (alwaysmy.github.io)</a><br>&#96;</p>
<h2 id="USB串口调试的问题"><a href="#USB串口调试的问题" class="headerlink" title="USB串口调试的问题"></a>USB串口调试的问题</h2><p>默认的usb串口的printf需要打开上位机打开流控才能接收。自己用tinyusb来做似乎没这个问题。</p>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>svd file就是CMSIS SVD(System View Description) ，相当于给编译器看的数据手册。</p>
<h3 id="openocd问题"><a href="#openocd问题" class="headerlink" title="openocd问题"></a>openocd问题</h3><p>这里只是记录，我强烈推荐使用pyocd。</p>
<p>使用openocd的时候出现错误连接提示最好升级openocd，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[rp2040.cpu] Could not find MEM-AP to control the core</span><br></pre></td></tr></table></figure>
<p>说明见：<br><a href="https://github.com/Marus/cortex-debug/blob/master/debug_attributes.md">cortex-debug&#x2F;debug_attributes.md at master · Marus&#x2F;cortex-debug (github.com)</a></p>
<p>正常连接应显示</p>
<p>正常的时候多核和单核的连接：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:\Users\AlwaysTS&gt; openocd <span class="operator">-f</span> interface/cmsis<span class="literal">-dap</span>.cfg  <span class="operator">-f</span> target/rp2040.cfg  <span class="literal">-c</span> <span class="string">&#x27;adapter speed 4000&#x27;</span> <span class="literal">-c</span> <span class="string">&#x27;set CHIPNAME rp2040&#x27;</span></span><br><span class="line">Open On<span class="literal">-Chip</span> Debugger <span class="number">0.12</span>.<span class="number">0</span><span class="literal">-rc2</span>+dev<span class="literal">-00988-g04887d3b6</span> (<span class="number">2022</span><span class="literal">-12-03-09</span>:<span class="number">30</span>)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line"><span class="keyword">For</span> bug reports, read</span><br><span class="line">        http://openocd.org/doc/doxygen/bugs.html</span><br><span class="line">adapter speed: <span class="number">4000</span> kHz</span><br><span class="line"></span><br><span class="line">rp2040</span><br><span class="line">Info : Listening on port <span class="number">6666</span> <span class="keyword">for</span> tcl connections</span><br><span class="line">Info : Listening on port <span class="number">4444</span> <span class="keyword">for</span> telnet connections</span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: SWD supported</span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: <span class="built_in">FW</span> Version = <span class="number">2.0</span>.<span class="number">0</span></span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: Interface Initialised (SWD)</span><br><span class="line">Info : SWCLK/TCK = <span class="number">1</span> SWDIO/TMS = <span class="number">1</span> TDI = <span class="number">0</span> TDO = <span class="number">0</span> nTRST = <span class="number">0</span> nRESET = <span class="number">1</span></span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: Interface ready</span><br><span class="line">Info : clock speed <span class="number">4000</span> kHz</span><br><span class="line">Info : SWD DPIDR <span class="number">0</span>x0bc12477, DLPIDR <span class="number">0</span>x00000001</span><br><span class="line">Info : SWD DPIDR <span class="number">0</span>x0bc12477, DLPIDR <span class="number">0</span>x10000001</span><br><span class="line">Info : [<span class="type">rp2040.core0</span>] Cortex<span class="literal">-M0</span>+ r0p1 processor detected</span><br><span class="line">Info : [<span class="type">rp2040.core0</span>] target has <span class="number">4</span> breakpoints, <span class="number">2</span> watchpoints</span><br><span class="line">Info : [<span class="type">rp2040.core1</span>] Cortex<span class="literal">-M0</span>+ r0p1 processor detected</span><br><span class="line">Info : [<span class="type">rp2040.core1</span>] target has <span class="number">4</span> breakpoints, <span class="number">2</span> watchpoints</span><br><span class="line">Info : starting gdb server <span class="keyword">for</span> rp2040.core0 on <span class="number">3333</span></span><br><span class="line">Info : Listening on port <span class="number">3333</span> <span class="keyword">for</span> gdb connections</span><br><span class="line">Info : starting gdb server <span class="keyword">for</span> rp2040.core1 on <span class="number">3334</span></span><br><span class="line">Info : Listening on port <span class="number">3334</span> <span class="keyword">for</span> gdb connections</span><br><span class="line">shutdown command invoked</span><br><span class="line"><span class="built_in">PS</span> C:\Users\AlwaysTS&gt; openocd <span class="operator">-f</span> interface/cmsis<span class="literal">-dap</span>.cfg <span class="literal">-c</span>  <span class="string">&#x27;set USE_CORE 0&#x27;</span> <span class="operator">-f</span> target/rp2040.cfg  <span class="literal">-c</span> <span class="string">&#x27;adapter speed 4000&#x27;</span> <span class="literal">-c</span> <span class="string">&#x27;set CHIPNAME rp2040&#x27;</span></span><br><span class="line">Open On<span class="literal">-Chip</span> Debugger <span class="number">0.12</span>.<span class="number">0</span><span class="literal">-rc2</span>+dev<span class="literal">-00988-g04887d3b6</span> (<span class="number">2022</span><span class="literal">-12-03-09</span>:<span class="number">30</span>)</span><br><span class="line">Licensed under GNU GPL v2</span><br><span class="line"><span class="keyword">For</span> bug reports, read</span><br><span class="line">        http://openocd.org/doc/doxygen/bugs.html</span><br><span class="line"><span class="number">0</span></span><br><span class="line">adapter speed: <span class="number">4000</span> kHz</span><br><span class="line"></span><br><span class="line">rp2040</span><br><span class="line">Info : Listening on port <span class="number">6666</span> <span class="keyword">for</span> tcl connections</span><br><span class="line">Info : Listening on port <span class="number">4444</span> <span class="keyword">for</span> telnet connections</span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: SWD supported</span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: <span class="built_in">FW</span> Version = <span class="number">2.0</span>.<span class="number">0</span></span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: Interface Initialised (SWD)</span><br><span class="line">Info : SWCLK/TCK = <span class="number">1</span> SWDIO/TMS = <span class="number">1</span> TDI = <span class="number">0</span> TDO = <span class="number">0</span> nTRST = <span class="number">0</span> nRESET = <span class="number">1</span></span><br><span class="line">Info : CMSIS<span class="literal">-DAP</span>: Interface ready</span><br><span class="line">Info : clock speed <span class="number">4000</span> kHz</span><br><span class="line">Info : SWD DPIDR <span class="number">0</span>x0bc12477, DLPIDR <span class="number">0</span>x00000001</span><br><span class="line">Info : [<span class="type">rp2040.core0</span>] Cortex<span class="literal">-M0</span>+ r0p1 processor detected</span><br><span class="line">Info : [<span class="type">rp2040.core0</span>] target has <span class="number">4</span> breakpoints, <span class="number">2</span> watchpoints</span><br><span class="line">Info : starting gdb server <span class="keyword">for</span> rp2040.core0 on <span class="number">3333</span></span><br><span class="line">Info : Listening on port <span class="number">3333</span> <span class="keyword">for</span> gdb connections</span><br></pre></td></tr></table></figure>



<h3 id="基于VSCode的自调试"><a href="#基于VSCode的自调试" class="headerlink" title="基于VSCode的自调试"></a>基于VSCode的自调试</h3><p>这一步直接看我修改的模板生成器，这些配置已经写在里面了，不用自己手动改了：<br><a href="https://github.com/alwaysmy/pico-project-generator_fix">alwaysmy&#x2F;pico-project-generator_fix</a></p>
<p>这里当个记录。</p>
<p>前面的配置步骤还是一样，就是哪些使用picoprobe的程序配置，后面只需要更改launch.json文件里面的：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">configuration<span class="punctuation">:</span></span><br><span class="line"></span><br><span class="line">                <span class="attr">&quot;configFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;/interface/picoprobe.cfg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;/target/rp2040.cfg&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;configFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;interface/cmsis-dap.cfg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;target/rp2040-core0.cfg&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;openOCDLaunchCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;transport select swd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;adapter speed 4000&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>或者替换为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;configFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;interface/cmsis-dap.cfg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;target/rp2040.cfg&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;openOCDLaunchCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">   <span class="string">&quot;set USE_CORE 0&quot;</span></span><br><span class="line">    <span class="string">&quot;transport select swd&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;adapter speed 4000&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>然后，把configurations下面的花括号以及其内容复制一份，加个逗号后加在后面做一些修改，用来增加一份配置方便切换。目的是方便在单核自调试和外部仿真器调试多核中切换。</p>
<p>同样的方法可以添加一份linux的配置。用来方便跨平台。</p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>rp2040</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>RP2040配置VSCODE开发环境 —— 一劳永逸版</title>
    <url>/2023/04/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/RP2040%E9%85%8D%E7%BD%AEVSCODE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E2%80%94%E2%80%94%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E7%89%88/</url>
    <content><![CDATA[<p>上一篇文章：树莓派RP2040开发环境配置集合版(基于Raspberry Pico)。<br>前面的环境搭建基本上介绍了所有的开发环境配置，也对比了各个环境的优劣。如果是非商业开发的话，个人可能Segger Embedded Studio是最好的IDE，但是我不太习惯他的使用方式，这个会另外开一篇谈。<br>而通吃的方案则是使用VSCODE+ARMGCC+GCC，PlatformIO也是不错的，但是我个人不太习惯后者，而且经常出错。</p>
<p>因此最后仍然选择了VSCODE作为开发工具。由于上一篇写的太杂了所以单独写一篇只负责在VSCODE下配置环境的。</p>
<p>更新：整合包杀死了比赛：<a href="https://www.raspberrypi.com/news/raspberry-pi-pico-windows-installer/">Raspberry Pi Pico Windows Installer - Raspberry Pi</a><br>（未测试，但是肯定能用）</p>
<span id="more"></span>

<p>其实这篇文章起源是重装了系统，所以决定找一个尽量不依赖环境变量的方法，比如有些软件可以不安装运行，重装后不需要重新安装，可以直接使用，也懒得追加环境变量。另外尽可能减少手工操作。所谓一劳永逸不是装好不管，而是下次崩坏还能迅速有条理地重建。</p>
<p>其实官方的工程生成器已经尽可能减少手工操作了，但是那个是针对Linux的，本身安装也十分简单。所以这里要做一点修改，这里的教程也是按照Windows来做。<br>再一个就是官方的方法有些方法并不好，这里也做出一些改进。</p>
<h1 id="安装软件和免安装软件配置"><a href="#安装软件和免安装软件配置" class="headerlink" title="安装软件和免安装软件配置"></a>安装软件和免安装软件配置</h1><p>这一步是我尽量避免的，但是之前有些软件装在C盘，重装后直接没了，所以还是得走这一步，所以这一步我也没有验证如果直接使用之前下载好的可执行文件会不会踩什么坑。下面就是按照顺序安装就可以了。</p>
<h2 id="gcc-arm-none-eabi"><a href="#gcc-arm-none-eabi" class="headerlink" title="gcc arm none eabi"></a>gcc arm none eabi</h2><p>点安装包直接安装就好了。<br>我的安装目录改到 <code>D:\MyPrograms\InstalledProgram\10 2021.10</code><br>这里就安装的时候先把环境变量加进去，毕竟只需要打个钩。<br>然后这个就不用管了，同时他有个选项是注册这个编译器，我不知道如果不用安装包的话这一步的影响是什么。  </p>
<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>这个不用自己加路径，所以直接用安装包安装，勾选添加到Path.</p>
<h2 id="pyocd"><a href="#pyocd" class="headerlink" title="pyocd"></a>pyocd</h2><p>由于是python安装的所以重新安装一次就行。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install –U pyocd</span><br></pre></td></tr></table></figure>
<p>其实这个和openocd工具二选一即可，推荐用这个。</p>
<pre><code>pyocd这个工具配置安装极为简单，一个软件支持rp2040的所有仿真器，而且连接稍微快一点点，（同一个工程openocd 15s ,pyocd 14s，真就一点点), 自带gdb配置，不知道为啥网上很少再rp2040的教程中提到。一次只能连接一个核心。
</code></pre>
<h2 id="免安装软件配置"><a href="#免安装软件配置" class="headerlink" title="免安装软件配置"></a>免安装软件配置</h2><h3 id="mingw-w64"><a href="#mingw-w64" class="headerlink" title="mingw-w64"></a>mingw-w64</h3><p>之前下好的，可以不用再次安装，直接找到之前部署的路径，我这里是：<br><code>D:\MyProgramData\Toolchain\mingw-w64\mingw64\bin </code><br>所以对应的<code>mingw32-make</code> 路径位于：<br><code>D:\MyProgramData\Toolchain\mingw-w64\mingw64\bin\mingw32-make.exe</code></p>
<p>如果要安装的话，安装包来源：<a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW-w64 - for 32 and 64 bit Windows - Browse Files at SourceForge.net</a><br>点下面的MinGW-W64 GCC-8.1.0标题下面的包，因为如果用在线安装包压根连不上。<br>选择最新版本（8.1.0）的 x86_64-win32-seh</p>
<h3 id="openocd-（可选）"><a href="#openocd-（可选）" class="headerlink" title="openocd （可选）"></a>openocd （可选）</h3><p>直接添加到环境里面。虽然可以配置到cortex-debug的路径里面，但是这个工具比较有用（不如pyocd），可能有时候会在命令行里面用一用。</p>
<h2 id="工程部署"><a href="#工程部署" class="headerlink" title="工程部署"></a>工程部署</h2><p>利用树莓派官方提供的生成工程脚本（pico-project-generator）还需要提供 PICO_SDK_PATH 这个环境变量用于生成cmakelists.txt, 这里只需要在环境变量中添加这个名称和填写SDK的路径即可；<br>同样，用于编译生成工具的make工具链也需要增加到环境变量Path，前面说过一次了。</p>
<p>这里为了方便操作，直接做了一个BAT批处理来处理环境变量并打开pico-project-generator。</p>
<pre><code>实际上完全可以在启动器的python脚本内部完成这个事情，但是我不太想改那个庞大的代码加上参数什么的，于是就把这些简单的东西分离出来。
</code></pre>
<p>由于这个生成器本身就要加上–gui参数来启动图形界面，所以一起集成到了BAT文件里面：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="comment">@REM &quot;设置文字编码UTF8(不然这里中文是UFT8,在命令行中会默认不是UTF8会出现斤拷棍,但是还是可能有问题建议不要用)&quot;</span></span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">65001</span>&gt;<span class="built_in">nul</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@REM &quot;下面是要自己指定的部分(=左右不要空格)，后面都是set来设定临时环境变量，如果希望直接设置好，改成setx就行，写了检测，不会重复&quot;</span></span><br><span class="line"><span class="built_in">set</span> picosdkpath_temp=D:\MyProgramData\MCU_SDK\pico-sdk</span><br><span class="line"><span class="comment">@REM mingw32-make.exe</span></span><br><span class="line"><span class="built_in">set</span> &quot;make_bin_path=D:\MyProgramData\Toolchain\mingw-w64\mingw64\bin&quot;</span><br><span class="line"><span class="built_in">set</span> make_exe_name=mingw32-make.exe</span><br><span class="line"><span class="comment">@REM 初始化一下环境变量,获取系统的环境变量</span></span><br><span class="line"><span class="built_in">set</span> &quot;env_path=<span class="variable">%PATH%</span>&quot;</span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">@REM &quot;起手就问工程名称，免得还要写一次,不要写空格&quot;</span></span><br><span class="line"><span class="built_in">set</span> /p projectname=your projectname:</span><br><span class="line"><span class="built_in">echo</span> your projectname is <span class="variable">%projectname%</span> </span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@REM 检测PICO_SDK，如果不存在就添加</span></span><br><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">defined</span> PICO_SDK_PATH (</span><br><span class="line">    <span class="built_in">echo</span> Environment variable PICO_SDK_PATH is <span class="keyword">not</span> <span class="built_in">set</span></span><br><span class="line">    <span class="built_in">echo</span> now, <span class="built_in">set</span> it to <span class="variable">%picosdkpath_temp%</span></span><br><span class="line">    <span class="built_in">set</span> PICO_SDK_PATH=<span class="variable">%picosdkpath_temp%</span></span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> Environment variable PICO_SDK_PATH is <span class="built_in">set</span> to <span class="variable">%PICO_SDK_PATH%</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">@REM &quot;检测PICO_SDK，如果不存在就添加（用if not exist mingw32-make.exe会一直显示不存在，只能查找字符串。或者findstr /C:%make_bin_path%&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> &quot;<span class="variable">%path%</span>&quot; | <span class="built_in">find</span> /i &quot;<span class="variable">%make_bin_path%</span>&quot; &gt;<span class="built_in">nul</span>  </span><br><span class="line"><span class="keyword">if</span> <span class="variable">%errorlevel%</span> <span class="keyword">equ</span> <span class="number">0</span> (</span><br><span class="line"><span class="comment">    @REM &quot;存在就显示一下好了&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> mingw toolchain has been <span class="built_in">set</span> to <span class="variable">%make_bin_path%</span></span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line"><span class="comment">    @REM &quot;不存在就添加一下&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> mingw toolchain is <span class="keyword">not</span> <span class="built_in">set</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @REM &quot;追加变量&quot;</span></span><br><span class="line">    @<span class="built_in">set</span> &quot;<span class="built_in">path</span>=<span class="variable">%env_path%</span>;<span class="variable">%make_bin_path%</span>&quot;</span><br><span class="line">    <span class="built_in">echo</span> mingw toolchain is <span class="built_in">set</span> to <span class="variable">%make_bin_path%</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@REM &quot;调用tsv文件，虽然默认也是这个，设置名称，默认打开vscode&quot;</span></span><br><span class="line">python pico_project.py  <span class="variable">%projectname%</span>  -t pico_configs.tsv -p vscode --gui</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@REM &quot;完事打开code&quot;</span></span><br><span class="line">code ../<span class="variable">%projectname%</span></span><br></pre></td></tr></table></figure>

<p>这里没有配置用户环境变量，而是使用临时环境变量，不过我还是自己手动在Windows中配置了环境变量，这个批处理就当作记录了。</p>
<pre><code>如果要一次配置好，就把里面的 ``set`` 命令改成``setx``，就可以把环境变量添加到用户变量了(系统变量需要提权，没必要）。
</code></pre>
<p>其中，这个批处理调用<strong>pico_project.py</strong> 文件的时候，添加了几个参数，一个是在启动BAT文件的时候要求输入工程名称，因为我觉得这种方式最方便，没必要像原来那样打开生成器之后，点击名称位置，删掉原来的默认名称后修改自己的。那样很麻烦。</p>
<p>另一个是添加默认勾选配置vscode，使用配置文件从tsv文件加载预设值(这个文件可以用excel打开)，虽然默认也是这个，但是记下来方便修改。</p>
<pre><code>我尝试给他添加默认特性，例如PIO,但是似乎在图形界面里面不生效，没注意看原因。

这个--feature 我实在是没看明白,试了一下它没啥用，写进去什么参数都不报错。。
</code></pre>
<p>然后就可以启动生成器了，关闭生成器后会自动在刚刚生成的项目文件夹下打开vscode。</p>
<p>但是这还不够，下面是工程生成器（pico-project-generator）的修改。</p>
<h2 id="生成器修改点"><a href="#生成器修改点" class="headerlink" title="生成器修改点"></a>生成器修改点</h2><p>先说槽点，也就是为什么要修改这个修改器：<br>1、LOGO图片太大，小屏幕塞不下好吧（虽然可以通过DPI兼容来解决）<br>2、工程生成路径和python文件在同一层，就离谱，一堆零散文件里面塞个工程。<br>3、daplink只配置了自己的专用Link，这TM能用？<br>4、vscode配置文件只配置了linux下自己的Link的配置，这TM能用？不然在Windows下每次都要复制vscode的配置文件。<br>5、个人爱好，包含主函数的文件就叫main.c而不是工程名</p>
<p>下面一个一个修改。</p>
<h3 id="去掉LOGO和修改显示设置"><a href="#去掉LOGO和修改显示设置" class="headerlink" title="去掉LOGO和修改显示设置"></a>去掉LOGO和修改显示设置</h3><p>不记得在哪里了，反正就是找那个图案的路径。然后是勾选python.exe，兼容性-&gt;勾选高DPI-&gt;改成应用程序，不然打开很模糊。 </p>
<pre><code>显示设置每次换电脑或者更换python版本都要做一次，这个没办法，Windows的问题。
</code></pre>
<h3 id="1、工程路径修改到当前生成器的上一层"><a href="#1、工程路径修改到当前生成器的上一层" class="headerlink" title="1、工程路径修改到当前生成器的上一层"></a>1、工程路径修改到当前生成器的上一层</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">        self.locationName.<span class="built_in">set</span>(os.path.abspath(os.path.join(os.getcwd(), <span class="string">&quot;..&quot;</span>)))</span><br></pre></td></tr></table></figure>
<p>查找这个函数名找到后替换set内容即可。</p>
<h3 id="2、添加daplink-debugger选项"><a href="#2、添加daplink-debugger选项" class="headerlink" title="2、添加daplink debugger选项"></a>2、添加daplink debugger选项</h3><p>默认是第一个可以用通用的DAPLink，所以直接加到第一个，对应配置文件是cmsis-dap.cfg</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">debugger_list = [<span class="string">&quot;DapLink&quot;</span>,<span class="string">&quot;raspSWD&quot;</span>, <span class="string">&quot;PicoProbe&quot;</span>]</span><br><span class="line"></span><br><span class="line">debugger_config_list = [<span class="string">&quot;cmsis-dap.cfg&quot;</span>,<span class="string">&quot;raspberrypi-swd.cfg&quot;</span>, <span class="string">&quot;picoprobe.cfg&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>这里这个选项其实是给Openocd的参数用的，如果是只用pyocd来调试，这个选项没啥用，因为pyocd配置没这么麻烦。。</p>
<h3 id="3、vscode生成-vscode文件部分"><a href="#3、vscode生成-vscode文件部分" class="headerlink" title="3、vscode生成.vscode文件部分"></a>3、vscode生成.vscode文件部分</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateProjectFiles</span>(<span class="params">projectPath, projectName, sdkPath, projects, debugger</span>):</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它这里是直接一行一行写在python文件里面每一行都带个单引号，修改起来真是脑溢血，但是我当时改的时候脑抽了，所以最后都是按照他那个格式写的。下面是加进去的内容。</p>
<h4 id="3-1-生成启动文件部分"><a href="#3-1-生成启动文件部分" class="headerlink" title="3.1 生成启动文件部分"></a>3.1 生成启动文件部分</h4><ul>
<li>启动文件为<code>launch.json</code><br>首先，修改第一个配置为Pyocd的配置，因为pyocd兼容性最好，配置也最简单。<br>然后，添加多个Openocd的选项，分别为：<br>指定pico-debug固件作为debugger的仿真Core0;<br>另外一个据说不会过时的指定core0的命令方法;<br>以及理论上是同时连接双核的调试方法，但是实际上cortex-debug的双核调试还在路上。<br>其中Pyocd的配置如下：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rp2040_core0 Debug with PyOcd&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;executable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cortex-debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;servertype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pyocd&quot;</span><span class="punctuation">,</span></span><br><span class="line">       <span class="comment">//可以修改为rp2040_core1  </span></span><br><span class="line">      <span class="attr">&quot;targetId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rp2040_core0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;showDevDebugOutput&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;svdFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;env:PICO_SDK_PATH&#125;/src/rp2040/hardware_regs/rp2040.svd&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;runToEntryPoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// Give restart the same functionality as runToEntryPoint - main</span></span><br><span class="line">      <span class="attr">&quot;postRestartCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;break main&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;continue&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
具体Pyocd的配置和cortex-debug的联合使用见我另外写的PyOCD配置。（我还没写）</li>
</ul>
<p>TODO: ARM也出了一个调试插件，但是要装好几个插件，而且对应rp2040还有点问题，文档太少了，我就没折腾出来，不知道这个会不会更好，以后没问题了再加上去。</p>
<ul>
<li><p>同时，写入文件添加指定编码utf-8,以便使用vscode默认utf-8编辑之后输出支持中文。</p>
<p>  吐槽,他这个生成器代码写的好挫.</p>
</li>
<li><p>添加自动判断对应系统应该用什么gdb server的名字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> isWindows:</span><br><span class="line">        gdb_path = <span class="string">&#x27;arm-none-eabi-gdb&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb_path = <span class="string">&#x27;gdb-multiarch&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改设置,默认显示build按钮，方便使用</p>
</li>
<li><p>推荐扩展文件添加一个<code> twxs.cmake</code></p>
</li>
</ul>
<p>最后，c_cpp_properites.json 中它写的也不对，只有linux的配置，而且如果是Windows写入的路径也没有转换。但是这个配置打开vscode的时候点配置会被替换掉，也不影响使用，所以无所谓，就先不改了。</p>
<ul>
<li>预计其他增加（以后有精力再说）<br>task.json 来实现只烧录 参考arm的Arm Embedded Debugger的方式，当然也可以用pyocd来做。<br>使用PICO TOOL，就是前面说过的PICO USB那个东西，可以实现烧录和简单的启动停止。<br>推荐扩展增加Arm Embedded Debugger以及Arm Device Manager，如果可用的话。</li>
</ul>
<p>完成这些之后，直接点击前面的启动脚本，就可以直接生成可用的工程并打开vscode了，总算有点IDE的样子了。</p>
<h2 id="vscode配置点（踩坑点）"><a href="#vscode配置点（踩坑点）" class="headerlink" title="vscode配置点（踩坑点）"></a>vscode配置点（踩坑点）</h2><p>如果是从头配置起来的基本上不会遇到下面这些问题，这里做个记录。</p>
<h3 id="cmake-tools"><a href="#cmake-tools" class="headerlink" title="cmake tools"></a>cmake tools</h3><p>插件如果是之前备份的到新电脑的，需要重新安装，否则插件加载不出来。</p>
<p>Cmake编译的时候会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMake Error: CMake was unable to find a build program corresponding to &quot;MinGW Makefiles&quot;.  CMAKE_MAKE_PROGRAM is not set.  You probably need to select a different build tool.</span><br></pre></td></tr></table></figure>

<p>似乎可以通过添加 CMAKE_MAKE_PROGRAM 来解决，但是由于没有环境变量，这还需要指定编译器位置，虽然可以通过cmake tools的脚本解决，但是那还需要额外添加一个文件。设置里面的设置cmake 环境变量似乎并不能给命令用。</p>
<p>所以最简单的办法就是<strong>添加mingw32的目录到环境变量</strong>。</p>
<p>如果追求极致不要修改环境变量，那么就在启动vscode的时候添加临时环境变量，这个文件放在工程文件夹下面。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">...  前面就和启动生成器里面添加环境变量的脚本一样</span><br><span class="line">code ../</span><br></pre></td></tr></table></figure>

<p><a href="https://www.codenong.com/6141608/">关于Makefile：找不到CMAKE_MAKE_PROGRAM | 码农家园 (codenong.com)</a><br>上面这个老哥说了，很多方法都不如加个环境变量。<br>但是这个mingw32-make确实很常用，就加到系统里面去吧。</p>
<h3 id="cortex-debugger"><a href="#cortex-debugger" class="headerlink" title="cortex-debugger"></a>cortex-debugger</h3><p>之前备份的会启动不了。。。重新安装也不行。只好全部移除了vs配置文件。</p>
<h3 id="Arm-Embedded-Debugger"><a href="#Arm-Embedded-Debugger" class="headerlink" title="Arm Embedded Debugger"></a>Arm Embedded Debugger</h3><p>vscode上除了cortex-debugger<br>Arm Embedded Debugger 似乎也可以：<br><a href="https://github.com/ARM-software/vscode-embedded-debug">ARM-software&#x2F;vscode-embedded-debug: Extension support for VS Code Embedded Debug Extension (github.com)</a><br>但是官方文档还不全，给的方法也有问题。。。。我试了一下还是连不上, 报错RDDI-ERROR 13 但是工具本身应该没问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;command:device-manager.getSerialNumber&#125;</span><br></pre></td></tr></table></figure>
<p>上面这句命令要安装一个arm device manager扩展才行，但是还是会报错没有连接的设备，指定串号之后可以连接上（串号可以用keil中的配置看到或者使用”pyocd list”命令找到设备的uid），用的是wch-link, 自调试固件不行，不知道是不是被复位了。但是即使连接上了会进入断点进不了主程序，不知道缺什么。<br>所以暂时不搞了，估计效果不会超过pyocd。</p>
<h3 id="由于armgcc工具链移动路径导致的原来cmakelist失效的问题需要迁移原工程"><a href="#由于armgcc工具链移动路径导致的原来cmakelist失效的问题需要迁移原工程" class="headerlink" title="由于armgcc工具链移动路径导致的原来cmakelist失效的问题需要迁移原工程"></a>由于armgcc工具链移动路径导致的原来cmakelist失效的问题需要迁移原工程</h3><p>直接编译或者选择对应的kit都会会报错找不到正确的工具链吧啦吧啦。<br>所以我的建议是不要移动工具链的位置，保持原来的路径。。。。。这样可以套用上次的设置。<br>不过迁移很简单：<br>在cmake插件的选择kit的按钮上，点选unspecified ，然后编译一下，再选对应的arm gcc就可以了。当然，不选回去也行，能用就算成功。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这些配置，就可以做到同步到另一台电脑上也可以直接使用，只需要修改脚本中的环境变量的路径，如果工具本身被同步了，不用修改也可以直接使用。<br>同时ARM GCC是被自动查找的，所以路径不影响，只要之前安装过就行。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>修改后的pico-project-generator:<br><a href="https://github.com/alwaysmy/pico-project-generator_fix">alwaysmy&#x2F;pico-project-generator_fix: Tool to automatically generate a Pico C SDK Project with VSCODE also supported in Windows (github.com)</a></p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>rp2040</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的MSP430单片机学习（二）</title>
    <url>/2021/04/20/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84MSP430%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>在认识了一款单片机产品之后，了解了它的开发方式和特点，就可以考虑使用它的资源了进行开发了。</p>
<h1 id="1-单片机的资源简介"><a href="#1-单片机的资源简介" class="headerlink" title="1 单片机的资源简介"></a>1 单片机的资源简介</h1><p>这里并不会用太多的篇幅，因为不同的单片机外设不一样，资源不一样，所以重要的是如何去了解。</p>
<span id="more"></span>

<p>烂尾了。。。430没啥意思，TI都把430办公室搬到印度去了，现在开始推M0了，最终还是走进了ARM的怀抱。转战RP2040了，顺便说一句ST也降价了，中间断更硬是把国产给撑起来了，现在都卷起来了。</p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>MSP430</tag>
        <tag>8051</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机学习入门（一）</title>
    <url>/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>单片机学习本身是一个了解学习一个技术的过程，学习的过程中不应该拘泥于某一款，而是要了解学习的方法。</p>
<p>同时学习技术较快的方法是完成一个完整的项目，同时记录学习中遇到的问题整个培训下来会提供一个或者多个具体的例子供学习，也可自由发挥。</p>
<p>教程首先会简述单片机的学习方法，然后讲解具体的细节，然后讲解具体的项目来完成学习过程。</p>
</blockquote>
<p>本教程会以 MSP430 单片机为主进行讲解，对于接触单片机的初学者，同时推荐阅读《Launchpad口袋实验平台 （指导书）》.</p>
<hr>
<span id="more"></span>
<h1 id="从零开始的MSP430单片机学习（一）"><a href="#从零开始的MSP430单片机学习（一）" class="headerlink" title="从零开始的MSP430单片机学习（一）"></a>从零开始的MSP430单片机学习（一）</h1><h2 id="1-MSP430单片机开发介绍"><a href="#1-MSP430单片机开发介绍" class="headerlink" title="1.MSP430单片机开发介绍"></a>1.MSP430单片机开发介绍</h2><h3 id="1-1-前情提要"><a href="#1-1-前情提要" class="headerlink" title="1.1 前情提要"></a>1.1 前情提要</h3><p>MSP430单片机是德州仪器（ TI ）出品的以超低功耗为主要特点的16位单片机系列产品，采用精简指令集（ RISC ），其称为混合信号处理器，其单片集成了数字、模拟模块以及处理器。</p>
<p>TI 官方提供了一些板卡（ launchpad ），作为仿真器和核心板在一块板的方式提供用来学习开发。</p>
<p>例如我们即将用到的 MSP-EXP430G2(-ET) 。</p>
<p>对于其他类型的单片机，市面上常见的8051系列产品（如STC、WCH等），ARM产品（如ST、NXP等)，有的也有官方提供的核心板或者网上有卖家提供的产品。</p>
<h3 id="1-2-G2-launchpad-介绍"><a href="#1-2-G2-launchpad-介绍" class="headerlink" title="1.2 G2 launchpad 介绍"></a>1.2 G2 launchpad 介绍</h3><ul>
<li><p><em>对于已有的资源，首先进行了解方便后续的学习</em></p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/%E5%8D%95%E7%89%87%E6%9C%BA%E5%B0%81%E9%9D%A2.png" class title="单片机封面">

<h4 id="1-2-1-从官方下载板卡资料。"><a href="#1-2-1-从官方下载板卡资料。" class="headerlink" title="1.2.1 从官方下载板卡资料。"></a>1.2.1 从官方下载板卡资料。</h4><p>从官网可以找到 <a href="https://www.ti.com.cn/tool/cn/MSP-EXP430G2?keyMatch=EXP%20G2&tisearch=search-everything">MSP-EXP430G2</a> 的产品资料，对于 TI 的产品还有别的方法进行下载，将在后面开发环境章节进行介绍。</p>
<p>找到 <em><strong>MSP-EXP430G2 Hardware Design Files</strong></em> ，其中包含了设计原理图（有助于在硬件连接的时候进行参考），设计PCB文件。</p>
<p>在这个产品提供的硬件设计资源（原理图和PCB文件）为 <a href="http://eagle.autodesk.com/">Eagle</a> 所制造，其文件可以用Eagle或者 <a href="https://www.autodesk.com.cn/products/fusion-360/overview">Fusion 360</a> 打开查看：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405185841746.png" alt="image-20210405185841746" style="zoom:75%;">

<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405185950827.png" alt="image-20210405185950827" style="zoom:75%;">

<p>一般查看PDF文件即可。</p>
<hr>
<p>在PDF查看原理图的时候，可以看到电路分为三部分，其中包含了接口，仿真器和单片机最小系统（后面称之为核心板）。</p>
<p>简单介绍一下 Launchpad 的组成:</p>
<p>下载器通过单片机的SWD接口可以下载程序到单片机，同时可以访问单片机内部资源因此可以仿真，这个下载器是TI的专用下载器，在 MSP-EXP430G2 这块开发板上，使用的下载器限制较大，只能下载部分MSP430单片机，同时提供一个串口用来连接调试。在新版的 MSP430G2553 开发板 <a href="https://www.ti.com.cn/tool/cn/MSP-EXP430G2ET">MSP-EXP430G2ET</a> 上，以及其他430 launchpad 上，使用的下载器为硬件开源的 <a href="http://software-dl.ti.com/msp430/msp430_public_sw/mcu/msp430/MSP430_ezFETLite/latest/index_FDS.html">MSP430_ezFETLite</a> ，具有更好的性能，可以下载几乎所有的MSP430系列单片机，同时提供串口。</p>
</li>
</ul>
<h4 id="1-2-2-从官方下载芯片数据和用户指南手册以及例程。"><a href="#1-2-2-从官方下载芯片数据和用户指南手册以及例程。" class="headerlink" title="1.2.2 从官方下载芯片数据和用户指南手册以及例程。"></a>1.2.2 从官方下载芯片数据和用户指南手册以及例程。</h4><p>  不同的单片机厂商都会在其产品主页提供用户手册和产品数据表供使用。对于 TI 的产品，可以直接在其官网搜索对应的产品型号并点击进入，或者在CCS中下载其产品支持包，这个方法在开发环境章节中讲解。顺便一提，如果使用Bing或者Google作为搜索引擎，直接搜索找数据表和手册是一件很容易的事情。</p>
<p>  同时，对于单片机类产品，通常官方会提供例程供开发使用，因为单看手册就写有点麻烦。这里以MSP430G2553 为例，讲解一下如何在毫无了解的情况下进行入门：</p>
  <img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405192138665.png" class title="image-20210405192138665">

<p>  进入产品主页之后，首先可以看到数据表（datasheet）和用户指南。这些肯定是要查看的。</p>
<p>  同时，点击技术文档，可以看到 TI 提供的更多相关技术的文档 ，可以进行下载阅读。</p>
<p>  比较重要的是，<strong>设计与开发</strong>，点击后，可以看到 TI 提供了指示，提示应该用什么方法进行开发，使用什么软件，最后一项：</p>
  <img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405193131040.png" class title="image-20210405193131040">

<p>  提供了代码例程。</p>
<p>  对于其他厂商的单片机同理，不过这里可以先不下载，因为有更方便的方法。</p>
<p>  可以看到，设计与开发中，其指示了用于MSP的 集成开发环境。</p>
<p>  这就是下一章节所需要讲解的。</p>
<h4 id="1-2-3-硬件信息补充"><a href="#1-2-3-硬件信息补充" class="headerlink" title="1.2.3 硬件信息补充"></a>1.2.3 硬件信息补充</h4><p>  针对 TI 的开发板，其只是一个核心板，因此如果需要扩展功能，可以引线出来，也可以通过外接拓展板，这个拓展板子TI为其提供了一个通用的格式，称之为 <a href="https://github.com/adrianF-TI/BuildYourOwnBoosterPack">BoosterPack</a> 插件，可以通过这个模板进行自己的开发。</p>
<h3 id="1-3-集成开发环境介绍"><a href="#1-3-集成开发环境介绍" class="headerlink" title="1.3 集成开发环境介绍"></a>1.3 集成开发环境介绍</h3><p>要进行单片机开发，首先选择合适的集成开发环境（ IDE )，并基于这个IDE进行开发。</p>
<p>首先，可以认为，官方所提供开发的集成开发环境通常是最方便的，因为能得到较好的技术支持，而且官方提供的 IDE 通常是免费的。</p>
<p>在上一章节中，在<strong>设计与开发</strong>内，TI 介绍了<a href="https://www.ti.com.cn/tool/cn/CCSTUDIO-MSP"> Code Composer Studio (CCS)</a> ，也介绍了<a href="https://www.ti.com.cn/tool/cn/IAR-KICKSTART">IAR 嵌入式工作平台 Kickstart - 免费 8KB 版本</a>.</p>
<p>其中，可以看到：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405194214472.png" alt="image-20210405194214472" style="zoom:80%;">

<p>CCS 作为官方IDE,内容是更多的。可以从官网获得更多技术支持。</p>
<p>在区别上，CCS内建的编译器和IAR的编译器存在一些不同，同时还有开源产品<a href="https://www.ti.com.cn/tool/cn/MSP430-GCC-OPENSOURCE">MSP430-GCC</a> 也可以用来编译代码，所以在官方提供的例程中可以看到一些预编译的符号用来区分不同的编译器。</p>
<p>CCS 是基于 eclipse（开源的 IDE）开发，瑞萨的 E2studio ,意法半导体（ST）的 STM32CUBEIDE 都是基于 Eclipse 设计，所以基本用法类似，所以使用IDE的快捷键以及操作可以通过在搜索引擎上以 Eclipse 为关键词进行搜索。</p>
<p>同时 CCS 也是 TI 官方推荐使用的IDE , TI甚至提供了基于云端的CCS cloud 可以进行开发。加之CCS更具专业性，后面所讲的开发环境都会基于CCS讲解。</p>
<hr>
<p>说到专业性，TI 也提供了一个不那么专业的 IDE —- <a href="https://energia.nu/">Energia</a> , 其实就是一个红色版本的 Arduino ，只不过可以使用 TI 自家的板卡。其使用了与 Arduino  相同的语法和库，所以开发板卡在某些应用上更快更简单，但是如果想要使用开源社区的库以及社区提供的更多的板卡支持，推荐使用基于 <a href="https://code.visualstudio.com/">VS code</a>  的 <a href="https://platformio.org/">platform IO</a> 代替 Energia , 其具备更好的技术支持，同时VS code 的编辑功能也更加强大，由于非常简单且可以参考Arduino学习，这里只做简单介绍，后面不在赘述，可自行学习。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405195810787.png" alt="image-20210405195810787" style="zoom:40%;">

<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405200009851.png" alt="image-20210405200009851" style="zoom:54%;">

<hr>
<h1 id="2-使用CCS开发自己的第一个单片机程序–Blink"><a href="#2-使用CCS开发自己的第一个单片机程序–Blink" class="headerlink" title="2.使用CCS开发自己的第一个单片机程序–Blink"></a>2.使用CCS开发自己的第一个单片机程序–Blink</h1><p>单片机到手第一件事情–正如一门编程语言第一件事是输出hello word – 便是点亮一个LED ( 有的 MSP430 单片机可以通过调试台输出 Hello world，G2553 不行，因为资源不足 ) 。</p>
<p>这里如果更愿意查看视频，可以选择查看视频教程：<a href="https://b23.tv/PVyOq4">新建工程</a> <a href="https://b23.tv/hHMsnp">资源搜索器</a>  <a href="https://b23.tv/AVMvt3">调试功能使用</a></p>
<h2 id="2-1学习使用CCS"><a href="#2-1学习使用CCS" class="headerlink" title="2.1学习使用CCS"></a>2.1学习使用CCS</h2><h3 id="2-1-1-新建工程与导入导出工程"><a href="#2-1-1-新建工程与导入导出工程" class="headerlink" title="2.1.1 新建工程与导入导出工程"></a>2.1.1 新建工程与导入导出工程</h3><pre><code>首先是CCS 进行安装，这个需要注意安装包路径以及安装路径以及电脑用户名（因为使用了临时目录包含用户名）不要包含中文以及其他非ASCII码值的符号。
</code></pre>
<p>打开CCS后首先选择工作空间，即放置工程的文件夹。</p>
<p>然后新建一个CCS工程。</p>
<p>不同的版本可能有不同，但是整体上都是点击顶部菜单栏-File - new -project(CCS project),或者直接选择菜单栏上的Project - new CCS project.</p>
<hr>
<p><em>如果需要导入外部工程，点击File -import -CCS project ，跳出弹窗 ：</em></p>
<ol>
<li><em>select search directory 为选择工程所在的文件夹；</em></li>
<li><em>select archive file 为选择打包的工程文件压缩包。</em></li>
</ol>
<p><em>然后选择导入，最好选择Copy Projects into workspace.</em></p>
<p><em>同样，导出选择File export  选择archive file，实际上这个就是个压缩包功能。</em></p>
<hr>
<p>新建工程的界面可以看到：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405211710941.png" alt="image-20210405211710941" style="zoom:50%;">

<ol>
<li>其中 Target 可以直接搜索所使用的单片机，这里我们使用的单片机型号是MSP430G2553，所以进行选择。</li>
<li>Connection 是连接单片机的方式，这里保持默认也就是使用板载仿真器。</li>
<li>然后命名你的工程 Project name , 推荐工程使用文件名加日期方便管理加信息（例如 <em>demo_blink_20210401_ver1</em> )</li>
<li>其他Tool-chain选择保持默认，最下面提示的<strong>Resource Explorer</strong> 将在后面介绍。</li>
<li>在最下面的模板中，可选择空工程或者基本例程，这里点击基本例程 blink the LED， 对这个例程进行讲解。</li>
</ol>
<hr>
<blockquote>
<p>补充：集成开发环境（IDE）的作用在于简化流程，这样不必使用命令行进行编译，不用使用make等工具来编辑编译参数，而是使用图形化的方式来进行配置，因此，每一个工程都有配置，一个源文件只有在工程内部才能进行正确的编译。</p>
<p>而工程的概念对于使用C语言的的初学者可能不是很明确，因为在以往的学习中通常编译单个文件较多，建议复习C语言部分或者通过其他方式加深学习C语言问题。</p>
<p>简言之，这是一个C语言的编译的问题。</p>
</blockquote>
<p>例如，右键你的工程，最下面的properties,可以看到，</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405215210503.png" alt="image-20210405215210503" style="zoom: 67%;">

<p>这里可以进行配置编译选项，这里暂时不多说。</p>
<h3 id="2-1-2使用资源浏览器（Resource-Explorer"><a href="#2-1-2使用资源浏览器（Resource-Explorer" class="headerlink" title="2.1.2使用资源浏览器（Resource Explorer )"></a>2.1.2使用资源浏览器（<strong>Resource Explorer</strong> )</h3><p>在第一章节中提到，如何从官方获取资料，针对TI 的产品，可以点击CCS 顶部菜单栏 -View -<strong>Resource Explorer</strong>  点开之后，</p>
<p>例如现在学习的是G2553, 那么直接搜索，可以看到</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405212620621.png" alt="image-20210405212620621" style="zoom:67%;">

<ol>
<li><p>首先点击 install 进行安装 MSP430Ware ,</p>
</li>
<li><p>点击MSP-EXP430G2展开，它集成包含了我们现在所用的板卡的所有资源。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405212820390.png" alt="image-20210405212820390" style="zoom:50%;"></li>
</ol>
<p>Demo中包含了一些应用例程，而Peripheral Examples（外设例程）选择MSP430G2553，可以看到Assembly –也就是汇编 ，和Register Level ( 寄存器级例程 )，也就是这里只有寄存器编程没有库函数编程。</p>
<p>下面的 xx.c 文件指示了不同外设的例程，例如需要使用IO,</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405213926925.png" alt="image-20210405213926925" style="zoom:67%;">

<p>这些文件是下载后（也就是前面的install）存在本地的，路径与CCS安装路径相同，推荐安装软件 <a href="https://www.voidtools.com/zh-cn/">everything</a> 搜索对应的文件名，可以直接点击到文件夹查看。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405214238500.png" class title="image-20210405214238500">

<h3 id="2-1-3使用调试功能（debug）"><a href="#2-1-3使用调试功能（debug）" class="headerlink" title="2.1.3使用调试功能（debug）"></a>2.1.3使用调试功能（debug）</h3><p>回到刚刚新建的例程Blink the LED。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405214618665.png" class title="image-20210405214618665">

<ul>
<li>点击菜单栏上的锤子，也就是Build进行编译。</li>
</ul>
<hr>
<p><em>简单说一下，如果没有点击编译，点击Build会首先编译程序，但是如果程序编译后修改了再点击debug，会载入上一个程序，但是有一个技巧就是，再debug中如果修改了程序，点击编译，可以勾选自动载入新的程序，这样比停在再debug更快。</em></p>
<hr>
<p>编译完成之后点击绿的虫子图标进行debug，所谓debug，在PC上进行程序debug时候可以进行单步运行或者查看变量，这里同样。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405215857561.png" class title="image-20210405215857561">

<p>点击箭头即可开始运行，关于其他图标的作用，可以鼠标挪到图标上等待出现文字提示，其中有暂停，停止，单步运行，单步跳过，单步返回。</p>
<p>在程序中可以在代码前面行号上双击<strong>添加断点</strong>。其实这些是一些基本调试方法。</p>
<ul>
<li>在调试中可以查看变量的值或者寄存器的状态。</li>
</ul>
<p>首先点击顶部菜单栏 View ，可以分别打开Expressions 、Registers</p>
<p>在Expressions  中可以查看想要的变量，手动填写或者在程序中选择要添加的变量，右键，然后：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405220511081.png" alt="image-20210405220511081" style="zoom:67%;">

<p>对于MSP430单片机，在程序中添加断点，当程序暂停才可以查看添加的变量当前的值。</p>
<p>同理，Register窗口可以查看所有寄存器的值。</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405220652715.png" alt="image-20210405220652715" style="zoom:67%;">

<p>对于上述操作，可以查看<a href="https://b23.tv/AVMvt3">调试功能使用</a> 视频演示。</p>
<h2 id="2-2-开始学习第一个程序"><a href="#2-2-开始学习第一个程序" class="headerlink" title="2.2 开始学习第一个程序"></a>2.2 开始学习第一个程序</h2><p>回到例程，在2.1章节中讲到，G2553官方只提供了寄存器级别的例程，因此这里开发也会基于寄存器。</p>
<p>往往通过例程会更简单，因此这里首先查看例程进行学习。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;msp430.h&gt;</span>                    <span class="comment">//首先包含头文件      </span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * blink.c</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       WDTCTL = WDTPW | WDTHOLD;        <span class="comment">// stop watchdog timer</span></span><br><span class="line">   P1DIR |= <span class="number">0x01</span>;                    <span class="comment">// configure P1.0 as output</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> i;        <span class="comment">// volatile to prevent optimization</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">       P1OUT ^= <span class="number">0x01</span>;                <span class="comment">// toggle P1.0</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">10000</span>; i&gt;<span class="number">0</span>; i--);     <span class="comment">// delay</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 这个程序是例程Blink the LED ,回到第一章节中的原理图，可以看到在G2 launchpad上，P1.0引脚通过跳线帽连接了一个LED.</p>
<p> 因此任务目标是使P1.0循环输出高低电平。</p>
<h3 id="2-2-1-GPIO"><a href="#2-2-1-GPIO" class="headerlink" title="2.2.1 GPIO"></a>2.2.1 GPIO</h3><p> 所谓GPIO,就是通用输入输出的缩写，其作为数字IO,只能输出高电平或者低电平，由于MSP430G2553 使用3.3V供电（也可以更低）</p>
<p> ，当前输出的高电平就是3.3V.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WDTCTL = WDTPW | WDTHOLD;        <span class="comment">// stop watchdog timer</span></span><br><span class="line">P1DIR |= <span class="number">0x01</span>;                    <span class="comment">// configure P1.0 as output</span></span><br></pre></td></tr></table></figure>

<p> 在程序的主函数的开始，首先第一句要关闭看门狗，看门狗是放置单片机程序跑飞的一个外设，具体会在后面讲解，由于这里不需要这种功能，所以关闭，这里先不讨论其具体含义。</p>
<p> 然后程序写了P1DIR  &#x3D; P1DIR | 0x01;</p>
<p> 表示读取P1DIR寄存器并和0x01做或运算并写入P1DIR;</p>
<p> 这里P1DIR就是一个寄存器，包含八个bit，控制着P1整个端口8个IO的输入输出方向的配置，其每一个bit控制着一个IO</p>
<p> 回到单片机的用户指南，《<a href="https://www.ti.com.cn/cn/lit/ug/slau144j/slau144j.pdf?ts=1617611245296&ref_url=https%253A%252F%252Fwww.ti.com.cn%252Fproduct%252Fcn%252FMSP430G2553">MSP430G2553用户指南</a>》，在数字IO部分（P327)：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405221926400.png" alt="image-20210405221926400" style="zoom:50%;">

<p> 可以看到，寄存器的功能在于配置引脚的方向。</p>
<p> 在《<a href="https://www.ti.com.cn/cn/lit/ds/symlink/msp430g2553.pdf?ts=1617617669592&ref_url=https%253A%252F%252Fwww.ti.com.cn%252Fproduct%252Fcn%252FMSP430G2553%253FkeyMatch%253DMSP430G2553%2526tisearch%253Dsearch-everything%2526usecase%253DGPN">MSP430G2553datasheet</a>》中可以看到引脚结构：</p>
 <img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405222304730.png" class title="image-20210405222304730">

<p> 初学者接触可能感觉比较混乱，可以先不管上面这张图。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    P1OUT ^= <span class="number">0x01</span>;                <span class="comment">// toggle P1.0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">10000</span>; i&gt;<span class="number">0</span>; i--);     <span class="comment">// delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后这里控制了P1OUT，并与0x01做异或运算。</p>
<p> 也就是说，从P1OUT第0位到第7位，分别于0 0 0 0 0 0 0 1 做异或运算（同为0，异为1），那么，对于从第1位到第7位，值不会改变，只有最后一位随着每次运算都会翻转，这样通过一句代码完成P1.0的点亮和熄灭。</p>
<p> 下一句的10000次的循环是一个简单的延时。</p>
<p> 如果对于二进制的数值没有那么敏感，可以使用头文件包含的宏定义 BIT0-BIT7;</p>
<p> 例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    P1OUT ^= BIT0;                <span class="comment">// toggle P1.0</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">10000</span>; i&gt;<span class="number">0</span>; i--);     <span class="comment">// delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在CCS中，按住Ctrl键，同时点击变量即可查看变量的定义位置，按住Ctrl点击BIT0, 可以看到其宏定义的内容：</p>
<img src="/2021/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210405223334092.png" alt="image-20210405223334092" style="zoom:50%;">

<p> 顺便一提，在CCS中代码自动补全的快捷键是Alt+&#x2F;。</p>
<p> 当然这些快捷键是可以自定义的。</p>
<h3 id="2-2-2-继续点灯"><a href="#2-2-2-继续点灯" class="headerlink" title="2.2.2 继续点灯"></a>2.2.2 继续点灯</h3><p> 对于launchpad板卡，可以观察到有2个LED灯，从原理图上可以看到，这两个LED分别连接于P1.0和P1.6 , 因此下一个任务是点亮两个LED。</p>
<p> 这里应该完成练习然后查看下面答案。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    P1OUT ^= (BIT0|BIT6);                <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">10000</span>; i&gt;<span class="number">0</span>; i--);     <span class="comment">// delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    P1OUT ^= <span class="number">0x41</span>;                <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">10000</span>; i&gt;<span class="number">0</span>; i--);     <span class="comment">// delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 或者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    P1OUT ^= <span class="number">0x41</span>;                <span class="comment">// </span></span><br><span class="line">    __delay_cycles(<span class="number">1000000</span>);     <span class="comment">// delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里的不同在于调用了一个__delay_cycles(1000000)；</p>
<p> 这个__delay_cycles();是调用一段汇编，进行N次空操作，也就是一个延时，但是由于使用汇编语句，所以相比for或者while循环更为准确。其参数只能是一个定值。</p>
<p> 同样，程序可以写成交替点亮两个LED.</p>
<p>至此，单片机入门的第一个Hello world完成了。</p>
<p> 有了前面的基础，后面的学习将有效率。</p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>MSP430</tag>
        <tag>8051</tag>
      </tags>
  </entry>
  <entry>
    <title>关于音响想到的一些杂谈</title>
    <url>/2023/06/20/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E5%85%B3%E4%BA%8E%E9%9F%B3%E5%93%8D%E6%83%B3%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>我不是一个什么特别有主见的人，所以对于铺天盖地而来的观点往往会首先逼迫自己认同，然后慢慢考虑到底发生了什么。所以，对于音响的营销，我是完全没有抵抗力的，唯一阻碍我购物的就是我的钱包（以及我的购买习惯）。</p>
<span id="more"></span>

<p>小时候课文（《长城砖》.人教版.四年级.上，旧版）上说宇航员在太空能看到长城，这是非常骄傲的–我就寻思这长城虽然长但是他似乎不宽啊，我也没有去过长城，最直观的了解是一本思想品德书（人教版.七年级.上，旧版）的封面是可以看到长城的，但是我百思不得其解，图中似乎宽度也只能看到五六个人并排，看到这幅图的我就更难受了，思考着：那么这是为什么呢。<br>有一天做梦，梦见，原来长城的城墙特别厚，虽然在图上只能看见城墙之间只能容纳五六个人宽，实际上旁边城墙还有好几米咧–难怪太空能看见。</p>
<div align="center"><img src="/2023/06/20/%E7%94%9F%E6%B4%BB%E6%B8%B8%E7%8E%A9/%E5%85%B3%E4%BA%8E%E9%9F%B3%E5%93%8D%E6%83%B3%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9D%82%E8%B0%88/coverbig.jpg" width="180"></div>

<pre><code>我一直以为这本思想品德书是小学的，没想到是初一的教材，我没想到我会纠结这个问题纠结三年，我反复去确认了小学的思想品德的封面插画都是漫画而不是照片才能确定，同时也高估了我小学时期的认知能力，见识少能想到长城没有很宽也挺不错了（摆手。
</code></pre>
<p>在梦中了悟得了这么个解释，似乎一切就合理起来了，犹如醍醐灌顶般，吃饭香了，睡觉也安稳了，从此不再纠结这个问题。</p>
<p>然后到了互联网时代，可能是2018年前后？（太惨了蒙在鼓里这么多年,虽然后面主要是没有心思去追究了），有人发文指出小学课文的错误，我一下子回想起来当时我考虑过的问题，淦！还是吃了没见识的亏。</p>
<pre><code>真正去回想时间线才发现，自己的认知水平到了大学才大幅提高。就像阳关灿烂的日子中的马小军，他的记忆是主观拼凑的，我的记忆也都是随便压缩时间的，一直以为自己以前见识也不少，现在才发现有时间获取信息了才有自己的想法。小时候可能时间最丰富的时期是初中三年，不过当时班主任不允许看闲书和新闻，只能偷偷带些儿童文学青年文摘一类书籍传阅。
</code></pre>
<p>瞎掰扯扯远了，这和音响有什么关系呢？我想说的是，我是不是那个会被最容易获取到的数据推着走的人。</p>
<p>最早接触听音设备应该是当时爸爸在我六年级的时候两千块钱配的AMD速龙CPU的台式机送的音响，这对音响我在高中还用过。其后接触专用听音设备应该是初中的时候借用同学的一个带有一个2inch电阻屏的纽曼mp3，连歌曲也是白嫖的，然后是后来有一个酷派手机，用着手机送的耳机，当时还是酷狗的时代，音乐也没有版权概念，都可以随便下载，再后来借由想要听歌线下买了一个纽曼的MP3，为什么还是纽曼呢，因为我只认识这一个牌子，觉得还不错。99元，记不起来型号了，不过我发现那个和飞利浦SA2208长得非常像。。。它声称是入门HiFi，这可能是我第一次见识到HiFi这个词。</p>
<p>在这个MP3上，我开始下载歌曲，我了解了有不同的格式，mp3，ape，flac，wav，由于在音乐软件上对于无损格式会专门标注出来，所以逐渐的我下载的歌曲从mp3变成了flac以及ape格式，为什么没有wav呢，这个后面解释。我相信，这个有着特殊标记的歌曲一定会听起来更能传达作曲者的意思，从此开始逐渐替换mp3格式的歌曲从各路音乐网站收集无损格式的歌曲。</p>
<p>但是我当时发现一个问题，这个标着HiFi的mp3，似乎听起来没有手机上放的好听。<br>“也许这是真正的声音？但是这么便宜也不至于真特别好吧，可是它说了它是HiFi诶”<br>到了高中，班级流行着买一个mp3听英语听力，也偷偷听听歌还有听听广播，但是校外的小卖店会进什么样的货呢，就是那种拼多多上十块钱包邮的类型，可能有贵一点有一个屏幕，总而言之，不会带有HiFi标志。这种通常杂音较大（信噪比不足），让我相信我的MP3是足够HiFi的。这时候当然就有人想要追求更好的设备了，但是不是我，因为我没有钱。一日一同学氪金500大洋买了一个看起来很牛比的学林xxx, 不记得型号–虽然我们当时感觉似乎索尼更好，但是五百大洋只能买到二手索尼– 我试听了一下，嗨，感觉和手机没有区别啊，我寻思，也许是下载的歌曲不够好。</p>
<blockquote>
<p>什么，你说耳机？十元包邮的耳机，我不知道耳机为啥贵啊，我自然买便宜的。</p>
</blockquote>
<p>又扯远了，本来是想说音响的，但是说着说着说到耳机上了。现在回到音响上。</p>
<p>初中的时候还有用过的就是妈妈的运动音响，骑车的时候放车上，声音特别大，我特别喜欢，说实在我记不起来到底感觉好不好听了，因为骑车确实很累。后来，电脑旁边添置了一组漫步者R101V，我的感受是，我去，原来的音响是什么垃圾，这个新音响这低音，这清晰度，简直了打开了新世界。原来音响也可以接近耳机的效果。<br>很长一段时间内，我看到低音足的标语我就觉得，这个耳机或者喇叭非常好。</p>
<p>而高音部分呢，实际上我不在乎，都是动次打次怎么会在乎，去看高音部分的资料是我在制作等离子扬声器的时候，大家都说他的特点是高音好，这时候我才去看看高音部分有什么音响。当时我认为我做的等离子扬声器非常好，可能是因为自己亲手制作的，有不少主观滤镜在里面，幸好保留了视频让我可以重新审视。</p>
<p>这里又扯到DIY上了，哦正是这些DIY让我瞎填志愿专业的时候把电子信息这个专业放到了第一位。</p>
<p>再后来，我觉得我可以自己做音响了，大概是高二的时候吧，看了贴吧别人用三合板加TDA2030的功放，我买了手锯，但是拿来的木板是实木，不知道是什么树，非常难锯，最后在开孔上放弃了，那时候我才意识到，我需要趁手的工具。但是看书的时候，我的认知是，做一个箱子装上喇叭就好了。不过，由于实施难度太高，我直接放弃了，一个多年的大坑至今没有填。</p>
<p>最后高考结束了，我寻思首先我要买个耳机，还要降噪耳机，无奈囊中羞涩，挑选来挑选去最后选中了亚马逊洋垃圾，90元送一盒小米彩虹电池。当时降噪耳机没有太多选择，基本上就是bose和sony之间选择，四位数的价格当时对于我来说想都不敢想。<br>买来之后，戴上这个头戴式耳机，我发现听觉的世界清晰多了，尤其是打开降噪开关，噪声降低的同时，耳机中的声音也清晰了不少，层次分明。</p>
<p>这个耳机随着我到了大学。当时还有一个一直想买的耳机，就是圈铁耳机，据说它分开处理高频和低频，感觉应该会更加HiFi。但是这类产品都很贵，当时没有低价的选择，最后我试了试同学的唐麦F3, 我发现这又是入耳式的全新体验，遂买了F1，发现听感不一样，然后还是买了同款F3，这个耳机陪伴我到了大二，是我当时最贵的一手耳机，我觉得这就是说明，提升几十块钱就有这么大提升了，不过可惜这个耳机再一次去硬件部之后不见了，这时候小米圈铁pro降价了，一百一十就可以买到，我就买了一条，这个耳机现在还在用，当时对这款耳机的批评很多，主要是说齿音，我很不理解，齿音究竟是什么，简直如同行业内的黑话，我听起来很好啊。</p>
<pre><code>后来才知道，小米的品控不怎么样，可能买三条，每条听起来都不一样。其中就有高音过重的类型的。
</code></pre>
<p>同期购买的还有一款号称HiFi性价比入门的耳机，造型很不错，听起来似乎也就高频比小米圈铁pro弱一点。</p>
<p>但是，似乎可以通过音效调节来解决这个问题，当时有一个插件叫做蝰蛇，基本能很好解决这个问题。我这时候开始考虑，那么，能软件调整的话，这些细微的区别影响大吗。</p>
<p>不能老说耳机了，还是回到音响。<br>尽管我已经买了好几条耳机了，总算认识到太便宜的耳机确实不想，但是我还是对音箱有好奇之心，大家都说音响的效果是耳机不能比拟的，在大一的生日，胁迫室友送了我一对我在淘宝上看中的迷宫音响，99元没有功放。然后自己买了一个功放，使用D类功放芯片。<br>买来之后的第一想法是，这个产品真的不错，这个价格就有这么好的效果，就是低音有点闷，怎么办呢，想到了之前高中准备做音响时候买的高音单元，直接按照淘宝评论区所说添加一个4.7uf电容串联扬声器后并联到原来的音响上，这时候再一次体验到世界清晰的感觉。<br>这时候我在想，这是真的HiFi吗，还是只是我自己听着舒服？</p>
<p>HiFi这个概念是不是并不是如其名，高保真，而是让人听起来更好？</p>
<p>一个小转折是到了大二的暑假，电赛培训做了一个麦克风放大器，测试的时候使用手机播放音频，测试不同的频率，当时播放到17khz的时候我已经听不见声音了，这时候我同学说，听得见，我愣住了，联想到初中物理中降噪的三个途径，我就明白了，我这是接收端出了问题。<br>每个人的体验都不一样，高保真真的能保证每个人的体验吗。</p>
<p>说到电赛，那就必须要说信号了，我的专业多少要和电信号打交道，我理解的高保真也就是更低的失真，但是如果说保证低失真，似乎是仪器就能测试的，为什么那么多厂家能说那么多结果出来还有不同的音频曲线呢，这个曲线如果不是平直的是不是说明这不是高保真的放送呢。我对声学一窍不通，对主观声学更是不理解，不理解人耳对声音的主观评估。</p>
<p>那么更换线材有用吗，有多大用处呢？</p>
<p>说来惭愧，虽然我自己是电子的学生，但是在早期我对这些玄学深信有疑，但是我有疑有很大一部分来源于我没有钱购买而不是因为我有什么知识储备。但是我又有些叛逆，我故意用着最普通的线材来连接，来证明我最叛逆的想法是正确的，但是我不确定。</p>
<p>不过，总而言之，大学时期室友赠送的音响陪过我过了整个大学期间，小米圈铁pro也没有换过，顶多是添置了蓝牙耳机，在蓝牙耳机使用SBC还是AAC抑或是AptX中间纠结对音质的影响，它们都让我感觉良好，我也逐渐能认识到这个玄学怪圈一部分来自于商家的营销，但是我还是止不住相信我总能通过微操获得更高的听音体验。</p>
<p>大学毕业之后，拿到工资的时候，我开始想我要买什么我之前想买的东西。首先我买了一个开放式头戴式耳机，飞利浦x1s，二手，常年的购物习惯还是让我不舍得花费太多钱购买一个不知道效果如何的东西。好在实际体验还不错，开放式耳机确实有其他耳机没有的优点。<br>然后我开始琢磨音响了，毕竟有了自己的房间和一个比较大的台面。挑选了好久，在各类营销文章里面反复选择，最后我选择了一个看起来比较好看的惠威x3，没错，我就是这么想的，同时也考虑了惠威也出了一些不错的产品，当时购买全新需要1800左右，最后我在闲鱼上购买了二手。</p>
<p>这时候又有新的概念了，监听，所谓监听就是要还原音乐的音色，我又想到了之前并非HiFi的HiFi这个词语。</p>
<p>到手之后，发现音响除了使用铸铁箱体，似乎没有什么特别的设计，连接好之后开始试听，哎，怎么回事儿，听起来和我大学区别不大啊，可是我价格加了个0啊。</p>
<pre><code>这时候会有人蹦出来说，你的驱动不够，你要独立解码。不好意思，解码和DAC我都写过文章了，这里总算不用再在这里继续添加废话了。
</code></pre>
<p>感觉两千有一大半用在这个铸铁箱体上。</p>
<pre><code>我一直习惯于按照BOM成本来衡量购买的商品，我知道要设计，但是积累了这么多年，也没听说国内谁有自己的comsol或者是ansys。
当然了，最开始我确实不知道设计音响是什么概念，以为就是加个箱子就好了。这也是后来累积了设计经验才反应过来这些东西是可以仿真的。
</code></pre>
<p>要是说以前做功放还免不了调试和不错的分立元件设计能力（也可能是抄袭日本的能力），现在大约都是面向FAE的设计了，我当时就觉得我是大冤种。</p>
<p>这时候我开始认真审视自己记忆中杂糅的概念了，正确的量化和理论应该认真考虑而不是凭着以前学来的二手知识和营销文章来感觉。</p>
<pre><code>前面说了为什么最开始我没下wav，因为没有人吹这个啊，这个概念很好理解，flac和ape都是无损算法，为什么要费更大的空间来储存同样无损的wav文件呢，但是有这么一段时间，我隐约相信，wav格式能获得更好的音质，因为虾米给了它金标。
</code></pre>
<p>不过，总体来说，也没有明显的缺点，也就这么用下去了。</p>
<p>下一个转折点正如第一次发现听力不同于人一样，是我自己制作设备的时候发现的问题。在使用4.5V电源给TL072供电的时候，用于混音器提供给耳机，当我接上示波器测试动态范围的时候，我发现，当波形出现明显上下截止失真的时候，我听不出来区别。</p>
<blockquote>
<p>实际上人耳能分辨的THD大约在2%左右，对于动辄0.1%甚至更低的现代芯片来说，这个值已经非常高了。</p>
</blockquote>
<p>另外说一句，测试这些，首先你得有个示波器。<br>这时候，我开始删除电脑上的wav格式的文件了。</p>
<p>买了没有多久，漫步者出了一款设备，也叫做监听音响，我一直考虑我已经有设备了，不要再想有的没的了，一直拖到现在（两年后），我考虑卖掉惠威x3似乎还能回收几百块钱，于是领券下单一气呵成，350元，基本四分之一于惠威的价格。</p>
<p>买来后第一反应是，真大，做工真廉价，果然是用最普通的物料来做到能发挥的最佳效果。测试后的反应是，薄纱惠威x3. </p>
<pre><code>一开始是能听出来有那些地方不足的，不过习惯了之后就不明显了，这大概就是煲耳朵吧。
人脑确实是适应能力很强的，我记得我配这副眼镜的时候，我能明显发现透过眼镜存在边缘畸变，物体看起来不是直的，看起来非常晕，但是一段时间后就适应了。不过话不能说绝了，超出一定范围的自然是能发现的，现在我有意去观察物体边缘并和不戴眼镜对比也是能看出镜片带来的畸变的。
</code></pre>
<p>其实这其中很多玄学说法是不能自圆其说的，只要稍微有些了解，这些谎言便能不攻自破。例如，精密设备上使用什么线材来保证信号不失真？例如万用表，六位半可能还是用的普通接头，对于部分nv表和高位表，接头使用低热电势金属接头来减小热电势的影响，但是在音频玄学中，无非是镀金镀银单晶铜几个词翻来覆去，不排除在某些方面具有效果，但是可以回想，这样我们能识别出来吗，还是我们一厢情愿？去钻牛角尖觉得人的能力是无限的？或者说，影响因素是唯一的吗，到底量化标准在哪里呢。</p>
<p>有些东西写着写着就忘记了，回头想起来再说吧。</p>
<p>但是个人的认知水平如果不提高，是很难认识到自己又不知道的东西的，也就是，可能有的人以为什么东西是自己不了解的是可以分辨的，但是真实情况是，有的东西如果压根不懂，可能压根不知道自己的错误，甚至按照自己的一些了解去强行凑。</p>
<p>我之前听到别人说版图的时候，我第一反应就是PCB，我就马上说我也会，然后认真bing之后发现，这特么是画芯片的。就像我之前从来不知道声学的概念和声学器材设计的方法，直到找了公司内部的文档看了看才了解到大致概念，同时认识到，这个东西要学还是得费精力而不是想当然的。</p>
<p>但是如果我再把这么一篇拿出来，放到以前的我面前，我大概还是会好奇这些事情究竟对不对，我想如果要真正去了解这些东西背后能刻画他们本质的特征，还是得用更好的工具去测试解释，而不是一厢情愿说服自己。</p>
<pre><code>卡尔·萨根的《魔鬼出没的世界THE DEMON-HAUNTED WORLD》中描绘了一个车库中的飞龙(The Dragon in My Garage)，他不能被任何方法探测到，但是&quot;我&quot;坚称飞龙是存在的，那这么说不存在的空车库和有飞龙的区别是什么呢。
</code></pre>
<p>当然我没有实际专门去做声学设备，这类资料通常不是很好找，被淹没在垃圾营销信息之中，如果不知道如何开头会被阻碍一段时间，但是我后来大致能了解，不只是看了一些文档，也是自己设计了电路，了解了更多的设计方法之后才联想到，声学设计同样有他对应的方法，如同机械，电子、光，这才按照如此理解去查找资料才能找到正确的资料。当然了，后来我发现都很麻烦，例如仿真，正如前面所说，仿真工具都是国外长期积累的产品。</p>
<pre><code>当然了，很多人不要仿真也能设计，很早的时候电子电路仿真也非常困难但是不耽误人们完成任务，不过后者通常测试指标更容易，毕竟很多不是面向主观的人而是客观标准。而前者据我所知还有很多人甚至没有正确的测试环境，这似乎不是说明这个东西好做，而是人耳标准宽泛----不必严格设计也能拼出来不错的听感觉。那么设计的作用是是什么呢，流程标准化，效率的提高，能用电脑就能修改的设计自然比实物生产容易，能得到量化的指标来对比，分离了主观的部分留给其他职能部门。
</code></pre>
<p>但是不管怎么样，可能归结为一句话：</p>
<blockquote>
<p>人的正确思想是从哪里来的?是从天上掉下来的吗?不是。是自己头脑里固有的吗?不是。人的正确思想，只能从社会实践中来，只能从社会的生产斗争、阶级斗争和科学实验这三项实践中来。 – 《中共中央关于目前农村工作中若干问题的决定（草案）》</p>
</blockquote>
<p>不过一个错误认知可能就是，有些时候理解为这种认知只能被动获取，例如只会去买不同的产品，听了之后仍然是主观的，没有考虑过产品是如何生产的，即使退一步，没有考虑如何有效地对比—-拒绝盲测依然有很大地生存空间—-。</p>
<p>当然我并不是想说各种产品就不是没有区别没有好坏之分的，但是这是一个主观的评估，我觉得更重要的是人的大脑的适应能力是很强的，而且对于音频信息很多之后我们关注的是其中的信息（虽然高保真可能也确实有更多的音乐信息），如果信息内容本身足够吸引人，其实有的东西也没那么重要。</p>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>这篇文本意是记录一下买的MR4和原来的惠威x3的参数对比和实际感觉，不过现在给说忘了，这里补一下。<br>MR4的背板RCA输入和前面板的AUX 3.5mm输入都是-10dBV标准，也就是0.316Vrms，TRS输入的6.35mm（1&#x2F;4 inch）接口的平衡输入标称输入电平则是+4dBu(1.228Vrms)。<br>功率21Wx2. 频响60-20k hz，信噪比85dBA. 失真低于0.2%. 共4.5Kg<br>来源：<a href="https://zh-cn.manuals.plus/edifier/mr4-studio-monitor-speaker-manual">EDIFIER MR4 监听音箱用户手册 (manuals.plus)</a></p>
<blockquote>
<p>dbA：通过A计权特性测得的分贝读数，由于人耳对不同频率的声音敏感程度不同，表现为相同 dB值的声音，2kHz 比100Hz听起来更响一些。为了使测量得到的值更符合人的主管感觉，在此引入A率加权。A计权针对人耳分辨声音的特点进行了修正，这样得出的dBA值更容易贴近人耳的感受。</p>
</blockquote>
<p>惠威X3:<br>输入最大峰值：3V<br>单个功率28W,失真度330Hz-20kHz≤1%( 80dB&#x2F;1m)，输入阻抗为12kΩ，信噪比＞96dB<br>频响：75Hz-20kHz(±2.5dB，freespace)<br>输入灵敏度 350mV<br>来源：<a href="https://www.hivi.com/product/view?id=78">Swan惠威X3 (hivi.com)</a></p>
<pre><code>80dB/1m指在距离音箱1米的地方，得到了80dB的声压级。
</code></pre>
<p>关于X3还有MR4，还有8010A，具体的测试参考这个：<a href="https://www.zhihu.com/question/453887667">(8 条消息) 国产音响真的不如国外品牌的音响吗？如惠威X系列和真力比较？ - 知乎 (zhihu.com)</a></p>
<p>结论是水太深。</p>
<pre><code>有太多的信息不对称，有的东西自己把握不住的。
</code></pre>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>这篇文章通篇没有分段，因为想到的太多了害怕搞忘记了。<br>本来我只是想写一下新买的MR4薄纱惠威x3，但是一写开头就离题万里，就想到了《禅与摩托车维修艺术》这本书通篇在疯狂insert自己的想法。</p>
<pre><code>卡尔萨根的作品都值得一看，《魔鬼出没的世界》这本书有很多非常不错的观点，具体解释了如何反驳非科学的思考方式和观点，可惜当时我看的版本翻译非常烂，硬是把中文翻译出了长难句，阅读观感非常不好，不过某种程度上来说，强行延长阅读时间倒是增强了我对这本书内容的印象。
</code></pre>
<h1 id="附加：听音测试"><a href="#附加：听音测试" class="headerlink" title="附加：听音测试"></a>附加：听音测试</h1><p><a href="https://www.klippel.de/listeningtest/?page=instructions">Listening Test - Instructions (klippel.de)</a></p>
]]></content>
      <categories>
        <category>生活游玩</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>【RP2040】跳转Bootloader实现IAP</title>
    <url>/2023/08/29/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA%E5%BC%80%E5%8F%91/RP2040-JumpIntoBootloader-IAP/</url>
    <content><![CDATA[<p>对于单片机来说，跳转BOOTLOADER一般可以通过自己实现一个BOOTLOADER来实现，同样，RP2040也可以这样来做，不过，如果没有特别的要求，也可以使用更简单的方法。</p>
<span id="more"></span>
<h1 id="1、利用bootrom跳转USB-boot"><a href="#1、利用bootrom跳转USB-boot" class="headerlink" title="1、利用bootrom跳转USB boot"></a>1、利用bootrom跳转USB boot</h1><p>RP2040的片上ROM固化了一个Bootloader，这个bootloader可以通过实现一个USB大容量设备来在电脑上加载UF2格式的固件，这个Bootloader是默认上电的时候检查Flash不可用或者Flash中没有可启动的程序的时候会自动跳转。</p>
<p>如果希望在程序中跳转进入Bootloader，可以借用这个自带的Bootloader，对于一些简单应用可以省去很多事情，或者用于用于免下电免调试器下载固件。</p>
<p>为了不用操作RUN这个引脚或者下电之后按住BOOT引脚（FLASH的CS）重新进Bootloader，而是直接在程序内根据触发条件运行，通过代码来实现内部跳转显然是有必要的，实际上官方手册已经给出了详细方法，能够让RP2040可以直接跳转到Bootrom直接进入USB大容量模式来下载UF2固件。</p>
<pre><code>WCH或者STC的单片机，他们默认支持串口下载或者USB下载，跳转到USB或者串口下载模式只需要跳转到ROM指定地址，只需要在代码中添加跳转地址并调用即可。同样，RP2040也是类似。

RP2040的启动顺序见Datasheet. 片上16k rom位于0x00000000地址，不过库函数提供了方法，不需要自己找对应的执行位置。
</code></pre>
<h2 id="1-0-实现方法"><a href="#1-0-实现方法" class="headerlink" title="1.0 实现方法"></a>1.0 实现方法</h2><p>这个方法在官方例程中没有单独列出，实际上这个功能已经在bootrom.h内实现，而是在数据手册中解释了，可能是实现这个太简单了因此没有单独拿出来说。</p>
<p>只需要在代码中加入下面这部分内容即可，然后每次调用enter_usb_dfu_bootloader()即可进入RP2040自带的Bootloader.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pico/stdlib.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pico/bootrom.h&quot;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_usb_dfu_bootloader</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">    reset_usb_boot(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reset_usb_boot这一句实际上是实现了重启到指定位置。<br>这里函数可以传入两个参数。<br>第一个是IO设置，0是表示禁用，其他数字表示设置单个bit的IO,在USB大容量模式下主机活动的时候，IO会被拉高，说白了进入Bootloader之后可以选用一个下载指示灯，这个可以指定GPIO。<br>第二个参数是要使用的接口：</p>
<ul>
<li>选0：同时开启了USB大容量模式和USB PICOBOOT接口（与正常的冷启动相同）</li>
<li>参数为1：只使用USB PICOBOOT接口</li>
<li>参数为2：只使用USB大容量模式。<br>例如，如果只需要启用USB 大容量储存模式，换成下面这个参数即可：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reset_usb_boot(<span class="number">0</span>, <span class="number">2</span>);<span class="comment">//禁用PICOBOOT模式 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>实际上这个函数就是类似于下面这种方法，跳转地址执行，但是SDK中已经配置好了准确的地址，并能根据参数选择不同配置：<br>（未验证）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*bootrom)(<span class="type">void</span>) = (<span class="type">void</span> (*)(<span class="type">void</span>))(<span class="number">0x00000000</span> + <span class="number">4</span>); </span><br><span class="line">bootrom();<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个指针<code>bootrom</code>，指向0x00000004的地址，即bootrom的入口地址。然后调用该指针即可跳转到bootrom。需要注意的是，为了确保正确的跳转，必须将指针类型强制转换为<code>void (*)(void)</code>，但是跳转到BOOTROM并不会直接进入USBBOOT.</p>
<pre><code>tips：如果启用PICOBOOT，Windows下会显示RP2 BOOT的USB设备，显示没有驱动，因为没有WinUSB的MSOS支持，不过依然可以手动加载WINUSB驱动或者使用LIBUSB.
这种方法也就是和RP2040的Arduino框架中使用的相似的方法（arudino大概是基于PICOBOOT传输固件）。
</code></pre>
<h2 id="1-1-实际使用"><a href="#1-1-实际使用" class="headerlink" title="1.1 实际使用"></a>1.1 实际使用</h2><p>有了这个方法，对于有按键的开发板，可以设置一键进入Bootrom。<br>例如我买的这个板子上24号引脚用作了用户按键，因此加入引脚配置为输入并上拉：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUTTON_GPIO 24</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usr_btn_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个板子上的按键有个问题，因为设计了阻容，导致上电需要一段时间才能充满，如果用电平判断的话，这个处理器太快了电容还没充够就开始判断了。。。因此如果不是检测边沿，初始化必须延时，</span></span><br><span class="line">    gpio_init(BUTTON_GPIO);</span><br><span class="line">    <span class="comment">//gpio_set_dir(BUTTON_GPIO, GPIO_IN);</span></span><br><span class="line">    gpio_pull_up(BUTTON_GPIO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查按键下降沿</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_btn_task</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint16_t</span> lastLevel=<span class="number">0</span>;<span class="comment">//初始认为是低电平，按键上拉建立之后才是高电平</span></span><br><span class="line">  <span class="comment">//检测到按键按下就跳转</span></span><br><span class="line">  <span class="keyword">if</span>(gpio_get(BUTTON_GPIO)==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(lastLevel==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      enter_usb_dfu_bootloader();<span class="comment">//检测电平下降沿</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      lastLevel=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    lastLevel = <span class="number">1</span>;<span class="comment">//更新电平状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主程序循环中添加</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">···</span><br><span class="line">    check_btn_task();</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用中断来完成这个功能，可能更方便：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usr_btn_callback</span><span class="params">(uint gpio, <span class="type">uint32_t</span> events)</span> &#123;</span><br><span class="line">    <span class="comment">// Put the GPIO event(s) that just happened into event_str</span></span><br><span class="line">        <span class="comment">//     &quot;LEVEL_LOW&quot;,  // 0x1</span></span><br><span class="line">        <span class="comment">// &quot;LEVEL_HIGH&quot;, // 0x2</span></span><br><span class="line">        <span class="comment">// &quot;EDGE_FALL&quot;,  // 0x4</span></span><br><span class="line">        <span class="comment">// &quot;EDGE_RISE&quot;   // 0x8</span></span><br><span class="line">    <span class="comment">// sleep_ms(20); //不要尝试在回调函数里面使用这个函数，会造成错误退出</span></span><br><span class="line">    <span class="keyword">if</span>(gpio_get(BUTTON_GPIO)==<span class="number">0</span>)</span><br><span class="line">        enter_usb_dfu_bootloader();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... 主函数中添加：</span><br><span class="line"></span><br><span class="line">usr_btn_init(); <span class="comment">//用户按键初始化</span></span><br><span class="line">gpio_set_irq_enabled_with_callback(BUTTON_GPIO, GPIO_IRQ_EDGE_FALL, <span class="literal">true</span>, &amp;usr_btn_callback);<span class="comment">//配置IO中断</span></span><br></pre></td></tr></table></figure>


<h2 id="1-2-参考来源"><a href="#1-2-参考来源" class="headerlink" title="1.2 参考来源"></a>1.2 参考来源</h2><ol>
<li>RP2040 Datasheet:<br>2.8章节说明了bootrom，其中包括有关USB PICOBOOT模式的详细说明和电气特性。（简单来说这是一个基本接口，提供了一些读写擦除RAM、FLASH、重启等简单的调试功能，除了手册上详细的描述，还可以看<strong>picoboot.h</strong>）</li>
<li>Raspberry Pi Pico C&#x2F;C++ SDK:<br>这里面也对USB PICOBOOT的部分场合做了解释，不过不多，直接搜索即可。</li>
</ol>
<h1 id="2、实现自己的Bootloader"><a href="#2、实现自己的Bootloader" class="headerlink" title="2、实现自己的Bootloader"></a>2、实现自己的Bootloader</h1><p>见 文章 RP2040的自定义Bootloader</p>
]]></content>
      <categories>
        <category>嵌入式与单片机</category>
      </categories>
      <tags>
        <tag>rp2040</tag>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title>SEPIC+Ćuk正负电源设计制作和测试（1）</title>
    <url>/2023/10/25/Work%20with%20the%20world/SEPIC+%C4%86uk%E6%AD%A3%E8%B4%9F%E7%94%B5%E6%BA%90%E8%AE%BE%E8%AE%A1%E5%88%B6%E4%BD%9C%E5%92%8C%E6%B5%8B%E8%AF%95%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>在模拟信号链中经常用到负电源以处理负信号，同时也有正电源轨。但是从直流单电源得到正负双电源是不如使用交流电得到双电源那般容易的。TODO:这句话也挪到下面这篇文章里面开头。得到正负双电源在小功率电源中有几种方法来实现，见另一篇文章【正负电源方案简介】。这篇文章则详细介绍一个SEPIC+Ćuk组合拓扑来实现的正负电源的设计和制作测试。</p>
<span id="more"></span>

<h1 id="拓扑简介"><a href="#拓扑简介" class="headerlink" title="拓扑简介"></a>拓扑简介</h1><h2 id="SEPIC"><a href="#SEPIC" class="headerlink" title="SEPIC"></a>SEPIC</h2><h2 id="Cuk"><a href="#Cuk" class="headerlink" title="Ćuk"></a>Ćuk</h2><h1 id="选型和参数计算"><a href="#选型和参数计算" class="headerlink" title="选型和参数计算"></a>选型和参数计算</h1><h2 id="DC-DC芯片选型"><a href="#DC-DC芯片选型" class="headerlink" title="DC-DC芯片选型"></a>DC-DC芯片选型</h2><p>这里使用SEPIC作为主输出，因此可以选用Boost控制器或者Boost转换器来完成这个要求，可以直接使用非同步整流Boost芯片。</p>
<p>MOS<br>耐压 输入+输出+余量</p>
<p>电流 输入+输出+纹波电流</p>
<p>输入耐压</p>
<p>输出</p>
<p>占空比要求</p>
<p>为了设计简单，同时这里设计要求不高，因此选用的DCDC芯片为MT3608或者SX1308，两者虽然厂家不同但是丝印一致，手册几乎一致。选用这个主要是因为便宜，只要三毛。</p>
<p>这个芯片的开关限流标称为设计上4A，不过按照国产IC的尿性，这个大概是达不到，而且SOT23-6的热阻太大。SW最大电压30V.</p>
<p>实际第一版测试中选用的是MT3608L，开关限流为2.5A，手册上标注为经过测试保证而非前面的理论值。SW最大电压22V.</p>
<h2 id="电感"><a href="#电感" class="headerlink" title="电感"></a>电感</h2><h2 id="二极管"><a href="#二极管" class="headerlink" title="二极管"></a>二极管</h2><h2 id="输入电容"><a href="#输入电容" class="headerlink" title="输入电容"></a>输入电容</h2><p>SEPIC Ćuk输入端并不是连续的，因此使用这个电源会对前级造成较大的纹波，适当提高输入电容来减小对前级的影响。</p>
<p>电容的耐压考虑一定余量即可</p>
<h2 id="输出电容"><a href="#输出电容" class="headerlink" title="输出电容"></a>输出电容</h2><p>输出反馈电阻</p>
<p>FB Input Bias Current 50nA-10nA</p>
<h1 id="仿真设计"><a href="#仿真设计" class="headerlink" title="仿真设计"></a>仿真设计</h1><p>其实上面的选型没有仿真模型，我做的时候也没提前仿真，不过为了完整性这里还是找一个接近的芯片来仿真一下。</p>
<h1 id="输出Π型滤波器设计"><a href="#输出Π型滤波器设计" class="headerlink" title="输出Π型滤波器设计"></a>输出Π型滤波器设计</h1><p>如果我们想获得一个更为干净的电源，那么开关电源的输出可以进一步处理。<br>开关电源输出存在开关频率的噪声，以及由于开关和输入信号混频导致的低频噪声。SEPIC输出是不连续的，存在大量开关谐波分量，Ćuk虽然输出连续但是依然要考虑尽量减小输出开关噪声。</p>
<p>当然， 也不要过度设计（过于HIFI），如果后级器件本身的PSRR够用， 那么这里可以减配。例如TL072的PSRR大约80-100dB，对于一般的应用可能已经足够。</p>
<h2 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h2><p>DCDC转换器的工作频率往往比较高，其开关噪声包含了对应的工作频率和其高次谐波，此次设计中使用的MT3608L标称1.2Mhz，实测1.05Mhz左右。</p>
<p>一般的线性稳压器对于较高频率噪声的抑制能力往往会大幅低于低频端。</p>
<p>例如TPS7A4901，在$C_{NR}&#x3D;10nF$，$C_{FF}&#x3D;10nF$, Cout&#x3D;10uF的情况下，对于100-1Khz的PSRR大约有70dB,而其PSRR@1Mhz只有35dB,也就是大约为0.0178，下图为手册截图。</p>
<img src="/2023/10/25/Work%20with%20the%20world/SEPIC+%C4%86uk%E6%AD%A3%E8%B4%9F%E7%94%B5%E6%BA%90%E8%AE%BE%E8%AE%A1%E5%88%B6%E4%BD%9C%E5%92%8C%E6%B5%8B%E8%AF%95%EF%BC%881%EF%BC%89/TPS7A4901_PSRRvsFre.png" class title="TPS7A49_Figure">
<p>负压的LDO TPS7A3001也差不多，在$C_{NR}&#x3D;10nF$，$C_{FF}&#x3D;10nF$, Cout&#x3D;10uF的情况下，对于100-1Khz的PSRR大约有70dB,而其PSRR@1Mhz只有40dB</p>
<img src="/2023/10/25/Work%20with%20the%20world/SEPIC+%C4%86uk%E6%AD%A3%E8%B4%9F%E7%94%B5%E6%BA%90%E8%AE%BE%E8%AE%A1%E5%88%B6%E4%BD%9C%E5%92%8C%E6%B5%8B%E8%AF%95%EF%BC%881%EF%BC%89/TPS7A3001_PSRRvsFre.png" class title="TPS7A30_Figure">
<p>传统的三端稳压器78xx系列只标注了PSRR@120Hz,其值通常在60-70dB左右。而79xx系列的负压线性稳压器的PSRR则稍微低一些，一般为54dB-60dB.</p>
<pre><code>只有120Hz点因为美国电网是60Hz，传统三端稳压器早期主要用于工频变压器输入整流后稳压。
</code></pre>
<p>只有ST的手册对于78xx给出了PSRR随着频率变化的图，但是似乎完全和他手册里面的写出来的指标对不上，不算保守。而且低频PSRR也太高了，感觉是以前测试方法有些不同出现的。</p>
<img src="/2023/10/25/Work%20with%20the%20world/SEPIC+%C4%86uk%E6%AD%A3%E8%B4%9F%E7%94%B5%E6%BA%90%E8%AE%BE%E8%AE%A1%E5%88%B6%E4%BD%9C%E5%92%8C%E6%B5%8B%E8%AF%95%EF%BC%881%EF%BC%89/L7805_PSRRvsFre.png" class title="L7805_Figure">

<p>国产的78L05系列则PSRR更低，只有49dB@120Hz.(你国产的也只标120Hz就离谱)</p>
<p>TI的LM317新手册中给出的PSRR则看起来比较正常，</p>
<img src="/2023/10/25/Work%20with%20the%20world/SEPIC+%C4%86uk%E6%AD%A3%E8%B4%9F%E7%94%B5%E6%BA%90%E8%AE%BE%E8%AE%A1%E5%88%B6%E4%BD%9C%E5%92%8C%E6%B5%8B%E8%AF%95%EF%BC%881%EF%BC%89/LM317_TI_PSRRvsFre.png" class title="LM317_Figure">

<p>而LM337的PSRR则给出为</p>
<img src="/2023/10/25/Work%20with%20the%20world/SEPIC+%C4%86uk%E6%AD%A3%E8%B4%9F%E7%94%B5%E6%BA%90%E8%AE%BE%E8%AE%A1%E5%88%B6%E4%BD%9C%E5%92%8C%E6%B5%8B%E8%AF%95%EF%BC%881%EF%BC%89/LM337_TI_PSRRvsFre.png" class title="LM317_Figure">



<p>整体上可以看见，这种传统的三端稳压器，<strong>基本上最好情况是正压稳压器到1Mhz依然有20dB抑制，而负压可能更低只能到10dB@1Mhz</strong>。</p>
<p>不过,地表最强LDO-LT3045的PSRR在1Mhz达到了76dB(对应的负压LDO-LT3094则是74dB@1Mhz).在低频段更是超过100dB. 不过一般应用中，这种超级LDO还是稍微有点贵了。</p>
<p>所以，对于一般应用，不要太指望通过线性稳压器来抑制开关噪声。</p>
<h2 id="Then-How-to-Do"><a href="#Then-How-to-Do" class="headerlink" title="Then How to Do ?"></a>Then How to Do ?</h2><p>不过好消息是，对于PCB路径上的高频噪声，无源滤波器很容易就能实现较好的抑制效果。（这里暂不考虑通过空间辐射耦合到输出端的情况）</p>
<p>考虑一个理想的RC低通滤波器，R&#x3D;0.23Ω，C&#x3D;10uF,计算得到的-3dB截止频率为69.23Khz，在1Mhz处的衰减为<br>$$<br>Gain &#x3D; \frac{1}{\sqrt{(\frac{f}{fp})^2+1}}<br>$$<br>计算得到为0.064，即-23.86dB。加上一个传统线性稳压器L7805的抑制效果-20dB，好消息，这已经差不多赶上单个TPS7A49的效果了。</p>
<p>但是仅仅使用RC滤波器，只有一个极点，衰减下降还是不够快，而且电阻也不能加太大否则会有压降，电容增加则会影响瞬态响应，而且成本也会增高。</p>
<p>对于一个10uF 50V耐压的1206封装电容，实际使用中在12V偏压下，只有3uF左右（使用村田仿真工具数据），因此这里电容在体积限制的应用里面也不方便加入太多。</p>
<p>那么如何改善呢？加入电感。<br>不过，使用单一电感来设计考虑较多（主要是我不会），直接使用磁珠产品更为简单。<br>下面是使用村田的仿真模型来设计一个Π滤波器，电容为GRM188R61E106MA73，磁珠为BLM18AG601SN1</p>
<img src="/2023/10/25/Work%20with%20the%20world/SEPIC+%C4%86uk%E6%AD%A3%E8%B4%9F%E7%94%B5%E6%BA%90%E8%AE%BE%E8%AE%A1%E5%88%B6%E4%BD%9C%E5%92%8C%E6%B5%8B%E8%AF%95%EF%BC%881%EF%BC%89/%CE%A0FIlter1.png" class title="LM317_Figure">

<p>仿真得到的传递特性为</p>
<img src="/2023/10/25/Work%20with%20the%20world/SEPIC+%C4%86uk%E6%AD%A3%E8%B4%9F%E7%94%B5%E6%BA%90%E8%AE%BE%E8%AE%A1%E5%88%B6%E4%BD%9C%E5%92%8C%E6%B5%8B%E8%AF%95%EF%BC%881%EF%BC%89/%CE%A0FIlter1_mag_freq.png" class title="LM317_Figure">
<p>可以看到，使用磁珠的Π滤波器在1Mhz的时候衰减达到了-60dB，不过在30Khz的地方存在尖峰，主要是LC存在谐振点，一般考虑把这个谐振点推到不影响应用的频率处即可，也可以通过增加电容或者换更大阻抗的磁珠来减小谐振峰增益，不过这种方法同时也会改变谐振点，需要权衡考虑不影响工作。如下图增加10uF电容为5个。</p>
<img src="/2023/10/25/Work%20with%20the%20world/SEPIC+%C4%86uk%E6%AD%A3%E8%B4%9F%E7%94%B5%E6%BA%90%E8%AE%BE%E8%AE%A1%E5%88%B6%E4%BD%9C%E5%92%8C%E6%B5%8B%E8%AF%95%EF%BC%881%EF%BC%89/%CE%A0FIlter2_mag_freq.png" class title="LM317_Figure">

<p>当然了，把谐振点推到更低频可以更容易通过LDO来消除这个频率的噪声，也就是如果后级使用现代LDO,对于10Khz级别的噪声已经可以很好抑制了。</p>
<p>不过，顺便一提，在仿真中，Spice模型并没有考虑直流偏压对电容的容量影响，而是取偏压为0V的容量，因此这里实际使用中需要考虑电容的实际容量。</p>
<p>这里下面测试中输出Π型滤波器的磁珠选型为BLM18PG121SN1D，输出电容为10uFx2.</p>
<pre><code>为什么前面仿真中RC滤波的R取值0.23Ω？因为这是上面仿真用到的磁珠的直流阻抗。
</code></pre>
<h1 id="PSRR"><a href="#PSRR" class="headerlink" title="PSRR"></a>PSRR</h1><p>虽然感觉上，开关电源的输出不怎么干净，但是不要忘了他依然是一个稳压器，他具有一定的输入电源纹波抑制能力，只要设计合理，开关电源完全可以让更垃圾的输入电源转换为更符合预期的输出。</p>
<p>这里测不了，只能单独拉一个较差的输入信号和对应的输出信号来展示一下。</p>
<p>一个应用场合是USB VBUS输入，由于各个厂商在PC上整板处理各有不同，USB VBUS的质量一言难尽，对于部分音频应用，就需要改善USB电源质量。</p>
<pre><code>当然，很多情况不需要高于5V的电压，直接使用磁珠滤波加上LDO已经足够使用。
</code></pre>
<h1 id="纹波测试"><a href="#纹波测试" class="headerlink" title="纹波测试"></a>纹波测试</h1><h2 id="无Π型滤波器输出"><a href="#无Π型滤波器输出" class="headerlink" title="无Π型滤波器输出"></a>无Π型滤波器输出</h2><h2 id="有Π型滤波器输出"><a href="#有Π型滤波器输出" class="headerlink" title="有Π型滤波器输出"></a>有Π型滤波器输出</h2><h2 id="有Π型滤波器输出（减配电容）"><a href="#有Π型滤波器输出（减配电容）" class="headerlink" title="有Π型滤波器输出（减配电容）"></a>有Π型滤波器输出（减配电容）</h2><h2 id="添加线性稳压器输出"><a href="#添加线性稳压器输出" class="headerlink" title="添加线性稳压器输出"></a>添加线性稳压器输出</h2><h2 id="减少输出电容-线性稳压器输出"><a href="#减少输出电容-线性稳压器输出" class="headerlink" title="减少输出电容+线性稳压器输出"></a>减少输出电容+线性稳压器输出</h2><h1 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h1><h1 id="负载不对称测试"><a href="#负载不对称测试" class="headerlink" title="负载不对称测试"></a>负载不对称测试</h1><p>实际上，负压输出依赖于正压的反馈，因此负压其实是开环输出。</p>
<p>不过对于使用耦合电感的SEPIC+Ćuk电源，由于正负两路的电感耦合在一起，在负载不对称的情况下表现则会更好。</p>
<h1 id="还需要测试但是我没设备了"><a href="#还需要测试但是我没设备了" class="headerlink" title="还需要测试但是我没设备了"></a>还需要测试但是我没设备了</h1><h1 id="开关节点波形和电感上的电压波形"><a href="#开关节点波形和电感上的电压波形" class="headerlink" title="开关节点波形和电感上的电压波形"></a>开关节点波形和电感上的电压波形</h1><p>电流波形我测不了，没有电流探头。</p>
]]></content>
      <categories>
        <category>Work with the world</category>
      </categories>
      <tags>
        <tag>SMPS</tag>
        <tag>SEPIC</tag>
        <tag>Ćuk</tag>
        <tag>正负电源</tag>
      </tags>
  </entry>
</search>
